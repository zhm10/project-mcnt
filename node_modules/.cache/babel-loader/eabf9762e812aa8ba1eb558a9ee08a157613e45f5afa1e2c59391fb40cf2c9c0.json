{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  ConcatSource\n} = require(\"webpack-sources\");\nconst {\n  UsageState\n} = require(\"../ExportsInfo\");\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst Template = require(\"../Template\");\nconst propertyAccess = require(\"../util/propertyAccess\");\nconst {\n  getEntryRuntime\n} = require(\"../util/runtime\");\nconst AbstractLibraryPlugin = require(\"./AbstractLibraryPlugin\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryOptions} LibraryOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryType} LibraryType */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compilation\").ChunkHashContext} ChunkHashContext */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").RenderContext} RenderContext */\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").StartupRenderContext} StartupRenderContext */\n/** @typedef {import(\"../util/Hash\")} Hash */\n/** @template T @typedef {import(\"./AbstractLibraryPlugin\").LibraryContext<T>} LibraryContext<T> */\n\nconst KEYWORD_REGEX = /^(await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|super|switch|static|this|throw|try|true|typeof|var|void|while|with|yield)$/;\nconst IDENTIFIER_REGEX = /^[\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}]*$/iu;\n\n/**\n * Validates the library name by checking for keywords and valid characters\n * @param {string} name name to be validated\n * @returns {boolean} true, when valid\n */\nconst isNameValid = name => {\n  return !KEYWORD_REGEX.test(name) && IDENTIFIER_REGEX.test(name);\n};\n\n/**\n * @param {string[]} accessor variable plus properties\n * @param {number} existingLength items of accessor that are existing already\n * @param {boolean=} initLast if the last property should also be initialized to an object\n * @returns {string} code to access the accessor while initializing\n */\nconst accessWithInit = (accessor, existingLength, initLast = false) => {\n  // This generates for [a, b, c, d]:\n  // (((a = typeof a === \"undefined\" ? {} : a).b = a.b || {}).c = a.b.c || {}).d\n  const base = accessor[0];\n  if (accessor.length === 1 && !initLast) return base;\n  let current = existingLength > 0 ? base : `(${base} = typeof ${base} === \"undefined\" ? {} : ${base})`;\n\n  // i is the current position in accessor that has been printed\n  let i = 1;\n\n  // all properties printed so far (excluding base)\n  /** @type {string[] | undefined} */\n  let propsSoFar;\n\n  // if there is existingLength, print all properties until this position as property access\n  if (existingLength > i) {\n    propsSoFar = accessor.slice(1, existingLength);\n    i = existingLength;\n    current += propertyAccess(propsSoFar);\n  } else {\n    propsSoFar = [];\n  }\n\n  // all remaining properties (except the last one when initLast is not set)\n  // should be printed as initializer\n  const initUntil = initLast ? accessor.length : accessor.length - 1;\n  for (; i < initUntil; i++) {\n    const prop = accessor[i];\n    propsSoFar.push(prop);\n    current = `(${current}${propertyAccess([prop])} = ${base}${propertyAccess(propsSoFar)} || {})`;\n  }\n\n  // print the last property as property access if not yet printed\n  if (i < accessor.length) current = `${current}${propertyAccess([accessor[accessor.length - 1]])}`;\n  return current;\n};\n\n/**\n * @typedef {Object} AssignLibraryPluginOptions\n * @property {LibraryType} type\n * @property {string[] | \"global\"} prefix name prefix\n * @property {string | false} declare declare name as variable\n * @property {\"error\"|\"static\"|\"copy\"|\"assign\"} unnamed behavior for unnamed library name\n * @property {\"copy\"|\"assign\"=} named behavior for named library name\n */\n\n/**\n * @typedef {Object} AssignLibraryPluginParsed\n * @property {string | string[]} name\n * @property {string | string[] | undefined} export\n */\n\n/**\n * @typedef {AssignLibraryPluginParsed} T\n * @extends {AbstractLibraryPlugin<AssignLibraryPluginParsed>}\n */\nclass AssignLibraryPlugin extends AbstractLibraryPlugin {\n  /**\n   * @param {AssignLibraryPluginOptions} options the plugin options\n   */\n  constructor(options) {\n    super({\n      pluginName: \"AssignLibraryPlugin\",\n      type: options.type\n    });\n    this.prefix = options.prefix;\n    this.declare = options.declare;\n    this.unnamed = options.unnamed;\n    this.named = options.named || \"assign\";\n  }\n\n  /**\n   * @param {LibraryOptions} library normalized library option\n   * @returns {T | false} preprocess as needed by overriding\n   */\n  parseOptions(library) {\n    const {\n      name\n    } = library;\n    if (this.unnamed === \"error\") {\n      if (typeof name !== \"string\" && !Array.isArray(name)) {\n        throw new Error(`Library name must be a string or string array. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);\n      }\n    } else {\n      if (name && typeof name !== \"string\" && !Array.isArray(name)) {\n        throw new Error(`Library name must be a string, string array or unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);\n      }\n    }\n    return {\n      name: ( /** @type {string | string[]} */name),\n      export: library.export\n    };\n  }\n\n  /**\n   * @param {Module} module the exporting entry module\n   * @param {string} entryName the name of the entrypoint\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {void}\n   */\n  finishEntryModule(module, entryName, {\n    options,\n    compilation,\n    compilation: {\n      moduleGraph\n    }\n  }) {\n    const runtime = getEntryRuntime(compilation, entryName);\n    if (options.export) {\n      const exportsInfo = moduleGraph.getExportInfo(module, Array.isArray(options.export) ? options.export[0] : options.export);\n      exportsInfo.setUsed(UsageState.Used, runtime);\n      exportsInfo.canMangleUse = false;\n    } else {\n      const exportsInfo = moduleGraph.getExportsInfo(module);\n      exportsInfo.setUsedInUnknownWay(runtime);\n    }\n    moduleGraph.addExtraReason(module, \"used as library export\");\n  }\n\n  /**\n   * @param {Compilation} compilation the compilation\n   * @returns {string[]} the prefix\n   */\n  _getPrefix(compilation) {\n    return this.prefix === \"global\" ? [compilation.runtimeTemplate.globalObject] : this.prefix;\n  }\n\n  /**\n   * @param {AssignLibraryPluginParsed} options the library options\n   * @param {Chunk} chunk the chunk\n   * @param {Compilation} compilation the compilation\n   * @returns {Array<string>} the resolved full name\n   */\n  _getResolvedFullName(options, chunk, compilation) {\n    const prefix = this._getPrefix(compilation);\n    const fullName = options.name ? prefix.concat(options.name) : prefix;\n    return fullName.map(n => compilation.getPath(n, {\n      chunk\n    }));\n  }\n\n  /**\n   * @param {Source} source source\n   * @param {RenderContext} renderContext render context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {Source} source with library export\n   */\n  render(source, {\n    chunk\n  }, {\n    options,\n    compilation\n  }) {\n    const fullNameResolved = this._getResolvedFullName(options, chunk, compilation);\n    if (this.declare) {\n      const base = fullNameResolved[0];\n      if (!isNameValid(base)) {\n        throw new Error(`Library name base (${base}) must be a valid identifier when using a var declaring library type. Either use a valid identifier (e. g. ${Template.toIdentifier(base)}) or use a different library type (e. g. 'type: \"global\"', which assign a property on the global scope instead of declaring a variable). ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);\n      }\n      source = new ConcatSource(`${this.declare} ${base};\\n`, source);\n    }\n    return source;\n  }\n\n  /**\n   * @param {Module} module the exporting entry module\n   * @param {RenderContext} renderContext render context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {string | undefined} bailout reason\n   */\n  embedInRuntimeBailout(module, {\n    chunk,\n    codeGenerationResults\n  }, {\n    options,\n    compilation\n  }) {\n    const {\n      data\n    } = codeGenerationResults.get(module, chunk.runtime);\n    const topLevelDeclarations = data && data.get(\"topLevelDeclarations\") || module.buildInfo && module.buildInfo.topLevelDeclarations;\n    if (!topLevelDeclarations) return \"it doesn't tell about top level declarations.\";\n    const fullNameResolved = this._getResolvedFullName(options, chunk, compilation);\n    const base = fullNameResolved[0];\n    if (topLevelDeclarations.has(base)) return `it declares '${base}' on top-level, which conflicts with the current library output.`;\n  }\n\n  /**\n   * @param {RenderContext} renderContext render context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {string | undefined} bailout reason\n   */\n  strictRuntimeBailout({\n    chunk\n  }, {\n    options,\n    compilation\n  }) {\n    if (this.declare || this.prefix === \"global\" || this.prefix.length > 0 || !options.name) {\n      return;\n    }\n    return \"a global variable is assign and maybe created\";\n  }\n\n  /**\n   * @param {Source} source source\n   * @param {Module} module module\n   * @param {StartupRenderContext} renderContext render context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {Source} source with library export\n   */\n  renderStartup(source, module, {\n    moduleGraph,\n    chunk\n  }, {\n    options,\n    compilation\n  }) {\n    const fullNameResolved = this._getResolvedFullName(options, chunk, compilation);\n    const staticExports = this.unnamed === \"static\";\n    const exportAccess = options.export ? propertyAccess(Array.isArray(options.export) ? options.export : [options.export]) : \"\";\n    const result = new ConcatSource(source);\n    if (staticExports) {\n      const exportsInfo = moduleGraph.getExportsInfo(module);\n      const exportTarget = accessWithInit(fullNameResolved, this._getPrefix(compilation).length, true);\n      for (const exportInfo of exportsInfo.orderedExports) {\n        if (!exportInfo.provided) continue;\n        const nameAccess = propertyAccess([exportInfo.name]);\n        result.add(`${exportTarget}${nameAccess} = ${RuntimeGlobals.exports}${exportAccess}${nameAccess};\\n`);\n      }\n      result.add(`Object.defineProperty(${exportTarget}, \"__esModule\", { value: true });\\n`);\n    } else if (options.name ? this.named === \"copy\" : this.unnamed === \"copy\") {\n      result.add(`var __webpack_export_target__ = ${accessWithInit(fullNameResolved, this._getPrefix(compilation).length, true)};\\n`);\n      /** @type {String} */\n      let exports = RuntimeGlobals.exports;\n      if (exportAccess) {\n        result.add(`var __webpack_exports_export__ = ${RuntimeGlobals.exports}${exportAccess};\\n`);\n        exports = \"__webpack_exports_export__\";\n      }\n      result.add(`for(var i in ${exports}) __webpack_export_target__[i] = ${exports}[i];\\n`);\n      result.add(`if(${exports}.__esModule) Object.defineProperty(__webpack_export_target__, \"__esModule\", { value: true });\\n`);\n    } else {\n      result.add(`${accessWithInit(fullNameResolved, this._getPrefix(compilation).length, false)} = ${RuntimeGlobals.exports}${exportAccess};\\n`);\n    }\n    return result;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Set<string>} set runtime requirements\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {void}\n   */\n  runtimeRequirements(chunk, set, libraryContext) {\n    // we don't need to return exports from runtime\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Hash} hash hash\n   * @param {ChunkHashContext} chunkHashContext chunk hash context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {void}\n   */\n  chunkHash(chunk, hash, chunkHashContext, {\n    options,\n    compilation\n  }) {\n    hash.update(\"AssignLibraryPlugin\");\n    const fullNameResolved = this._getResolvedFullName(options, chunk, compilation);\n    if (options.name ? this.named === \"copy\" : this.unnamed === \"copy\") {\n      hash.update(\"copy\");\n    }\n    if (this.declare) {\n      hash.update(this.declare);\n    }\n    hash.update(fullNameResolved.join(\".\"));\n    if (options.export) {\n      hash.update(`${options.export}`);\n    }\n  }\n}\nmodule.exports = AssignLibraryPlugin;","map":{"version":3,"names":["ConcatSource","require","UsageState","RuntimeGlobals","Template","propertyAccess","getEntryRuntime","AbstractLibraryPlugin","KEYWORD_REGEX","IDENTIFIER_REGEX","isNameValid","name","test","accessWithInit","accessor","existingLength","initLast","base","length","current","i","propsSoFar","slice","initUntil","prop","push","AssignLibraryPlugin","constructor","options","pluginName","type","prefix","declare","unnamed","named","parseOptions","library","Array","isArray","Error","COMMON_LIBRARY_NAME_MESSAGE","export","finishEntryModule","module","entryName","compilation","moduleGraph","runtime","exportsInfo","getExportInfo","setUsed","Used","canMangleUse","getExportsInfo","setUsedInUnknownWay","addExtraReason","_getPrefix","runtimeTemplate","globalObject","_getResolvedFullName","chunk","fullName","concat","map","n","getPath","render","source","fullNameResolved","toIdentifier","embedInRuntimeBailout","codeGenerationResults","data","get","topLevelDeclarations","buildInfo","has","strictRuntimeBailout","renderStartup","staticExports","exportAccess","result","exportTarget","exportInfo","orderedExports","provided","nameAccess","add","exports","runtimeRequirements","set","libraryContext","chunkHash","hash","chunkHashContext","update","join"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/library/AssignLibraryPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { ConcatSource } = require(\"webpack-sources\");\nconst { UsageState } = require(\"../ExportsInfo\");\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst Template = require(\"../Template\");\nconst propertyAccess = require(\"../util/propertyAccess\");\nconst { getEntryRuntime } = require(\"../util/runtime\");\nconst AbstractLibraryPlugin = require(\"./AbstractLibraryPlugin\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryOptions} LibraryOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryType} LibraryType */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compilation\").ChunkHashContext} ChunkHashContext */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").RenderContext} RenderContext */\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").StartupRenderContext} StartupRenderContext */\n/** @typedef {import(\"../util/Hash\")} Hash */\n/** @template T @typedef {import(\"./AbstractLibraryPlugin\").LibraryContext<T>} LibraryContext<T> */\n\nconst KEYWORD_REGEX =\n\t/^(await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|super|switch|static|this|throw|try|true|typeof|var|void|while|with|yield)$/;\nconst IDENTIFIER_REGEX =\n\t/^[\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}]*$/iu;\n\n/**\n * Validates the library name by checking for keywords and valid characters\n * @param {string} name name to be validated\n * @returns {boolean} true, when valid\n */\nconst isNameValid = name => {\n\treturn !KEYWORD_REGEX.test(name) && IDENTIFIER_REGEX.test(name);\n};\n\n/**\n * @param {string[]} accessor variable plus properties\n * @param {number} existingLength items of accessor that are existing already\n * @param {boolean=} initLast if the last property should also be initialized to an object\n * @returns {string} code to access the accessor while initializing\n */\nconst accessWithInit = (accessor, existingLength, initLast = false) => {\n\t// This generates for [a, b, c, d]:\n\t// (((a = typeof a === \"undefined\" ? {} : a).b = a.b || {}).c = a.b.c || {}).d\n\tconst base = accessor[0];\n\tif (accessor.length === 1 && !initLast) return base;\n\tlet current =\n\t\texistingLength > 0\n\t\t\t? base\n\t\t\t: `(${base} = typeof ${base} === \"undefined\" ? {} : ${base})`;\n\n\t// i is the current position in accessor that has been printed\n\tlet i = 1;\n\n\t// all properties printed so far (excluding base)\n\t/** @type {string[] | undefined} */\n\tlet propsSoFar;\n\n\t// if there is existingLength, print all properties until this position as property access\n\tif (existingLength > i) {\n\t\tpropsSoFar = accessor.slice(1, existingLength);\n\t\ti = existingLength;\n\t\tcurrent += propertyAccess(propsSoFar);\n\t} else {\n\t\tpropsSoFar = [];\n\t}\n\n\t// all remaining properties (except the last one when initLast is not set)\n\t// should be printed as initializer\n\tconst initUntil = initLast ? accessor.length : accessor.length - 1;\n\tfor (; i < initUntil; i++) {\n\t\tconst prop = accessor[i];\n\t\tpropsSoFar.push(prop);\n\t\tcurrent = `(${current}${propertyAccess([prop])} = ${base}${propertyAccess(\n\t\t\tpropsSoFar\n\t\t)} || {})`;\n\t}\n\n\t// print the last property as property access if not yet printed\n\tif (i < accessor.length)\n\t\tcurrent = `${current}${propertyAccess([accessor[accessor.length - 1]])}`;\n\n\treturn current;\n};\n\n/**\n * @typedef {Object} AssignLibraryPluginOptions\n * @property {LibraryType} type\n * @property {string[] | \"global\"} prefix name prefix\n * @property {string | false} declare declare name as variable\n * @property {\"error\"|\"static\"|\"copy\"|\"assign\"} unnamed behavior for unnamed library name\n * @property {\"copy\"|\"assign\"=} named behavior for named library name\n */\n\n/**\n * @typedef {Object} AssignLibraryPluginParsed\n * @property {string | string[]} name\n * @property {string | string[] | undefined} export\n */\n\n/**\n * @typedef {AssignLibraryPluginParsed} T\n * @extends {AbstractLibraryPlugin<AssignLibraryPluginParsed>}\n */\nclass AssignLibraryPlugin extends AbstractLibraryPlugin {\n\t/**\n\t * @param {AssignLibraryPluginOptions} options the plugin options\n\t */\n\tconstructor(options) {\n\t\tsuper({\n\t\t\tpluginName: \"AssignLibraryPlugin\",\n\t\t\ttype: options.type\n\t\t});\n\t\tthis.prefix = options.prefix;\n\t\tthis.declare = options.declare;\n\t\tthis.unnamed = options.unnamed;\n\t\tthis.named = options.named || \"assign\";\n\t}\n\n\t/**\n\t * @param {LibraryOptions} library normalized library option\n\t * @returns {T | false} preprocess as needed by overriding\n\t */\n\tparseOptions(library) {\n\t\tconst { name } = library;\n\t\tif (this.unnamed === \"error\") {\n\t\t\tif (typeof name !== \"string\" && !Array.isArray(name)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Library name must be a string or string array. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tif (name && typeof name !== \"string\" && !Array.isArray(name)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Library name must be a string, string array or unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tname: /** @type {string | string[]} */ (name),\n\t\t\texport: library.export\n\t\t};\n\t}\n\n\t/**\n\t * @param {Module} module the exporting entry module\n\t * @param {string} entryName the name of the entrypoint\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {void}\n\t */\n\tfinishEntryModule(\n\t\tmodule,\n\t\tentryName,\n\t\t{ options, compilation, compilation: { moduleGraph } }\n\t) {\n\t\tconst runtime = getEntryRuntime(compilation, entryName);\n\t\tif (options.export) {\n\t\t\tconst exportsInfo = moduleGraph.getExportInfo(\n\t\t\t\tmodule,\n\t\t\t\tArray.isArray(options.export) ? options.export[0] : options.export\n\t\t\t);\n\t\t\texportsInfo.setUsed(UsageState.Used, runtime);\n\t\t\texportsInfo.canMangleUse = false;\n\t\t} else {\n\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\texportsInfo.setUsedInUnknownWay(runtime);\n\t\t}\n\t\tmoduleGraph.addExtraReason(module, \"used as library export\");\n\t}\n\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @returns {string[]} the prefix\n\t */\n\t_getPrefix(compilation) {\n\t\treturn this.prefix === \"global\"\n\t\t\t? [compilation.runtimeTemplate.globalObject]\n\t\t\t: this.prefix;\n\t}\n\n\t/**\n\t * @param {AssignLibraryPluginParsed} options the library options\n\t * @param {Chunk} chunk the chunk\n\t * @param {Compilation} compilation the compilation\n\t * @returns {Array<string>} the resolved full name\n\t */\n\t_getResolvedFullName(options, chunk, compilation) {\n\t\tconst prefix = this._getPrefix(compilation);\n\t\tconst fullName = options.name ? prefix.concat(options.name) : prefix;\n\t\treturn fullName.map(n =>\n\t\t\tcompilation.getPath(n, {\n\t\t\t\tchunk\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * @param {Source} source source\n\t * @param {RenderContext} renderContext render context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {Source} source with library export\n\t */\n\trender(source, { chunk }, { options, compilation }) {\n\t\tconst fullNameResolved = this._getResolvedFullName(\n\t\t\toptions,\n\t\t\tchunk,\n\t\t\tcompilation\n\t\t);\n\t\tif (this.declare) {\n\t\t\tconst base = fullNameResolved[0];\n\t\t\tif (!isNameValid(base)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Library name base (${base}) must be a valid identifier when using a var declaring library type. Either use a valid identifier (e. g. ${Template.toIdentifier(\n\t\t\t\t\t\tbase\n\t\t\t\t\t)}) or use a different library type (e. g. 'type: \"global\"', which assign a property on the global scope instead of declaring a variable). ${\n\t\t\t\t\t\tAbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE\n\t\t\t\t\t}`\n\t\t\t\t);\n\t\t\t}\n\t\t\tsource = new ConcatSource(`${this.declare} ${base};\\n`, source);\n\t\t}\n\t\treturn source;\n\t}\n\n\t/**\n\t * @param {Module} module the exporting entry module\n\t * @param {RenderContext} renderContext render context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {string | undefined} bailout reason\n\t */\n\tembedInRuntimeBailout(\n\t\tmodule,\n\t\t{ chunk, codeGenerationResults },\n\t\t{ options, compilation }\n\t) {\n\t\tconst { data } = codeGenerationResults.get(module, chunk.runtime);\n\t\tconst topLevelDeclarations =\n\t\t\t(data && data.get(\"topLevelDeclarations\")) ||\n\t\t\t(module.buildInfo && module.buildInfo.topLevelDeclarations);\n\t\tif (!topLevelDeclarations)\n\t\t\treturn \"it doesn't tell about top level declarations.\";\n\t\tconst fullNameResolved = this._getResolvedFullName(\n\t\t\toptions,\n\t\t\tchunk,\n\t\t\tcompilation\n\t\t);\n\t\tconst base = fullNameResolved[0];\n\t\tif (topLevelDeclarations.has(base))\n\t\t\treturn `it declares '${base}' on top-level, which conflicts with the current library output.`;\n\t}\n\n\t/**\n\t * @param {RenderContext} renderContext render context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {string | undefined} bailout reason\n\t */\n\tstrictRuntimeBailout({ chunk }, { options, compilation }) {\n\t\tif (\n\t\t\tthis.declare ||\n\t\t\tthis.prefix === \"global\" ||\n\t\t\tthis.prefix.length > 0 ||\n\t\t\t!options.name\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\treturn \"a global variable is assign and maybe created\";\n\t}\n\n\t/**\n\t * @param {Source} source source\n\t * @param {Module} module module\n\t * @param {StartupRenderContext} renderContext render context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {Source} source with library export\n\t */\n\trenderStartup(\n\t\tsource,\n\t\tmodule,\n\t\t{ moduleGraph, chunk },\n\t\t{ options, compilation }\n\t) {\n\t\tconst fullNameResolved = this._getResolvedFullName(\n\t\t\toptions,\n\t\t\tchunk,\n\t\t\tcompilation\n\t\t);\n\t\tconst staticExports = this.unnamed === \"static\";\n\t\tconst exportAccess = options.export\n\t\t\t? propertyAccess(\n\t\t\t\t\tArray.isArray(options.export) ? options.export : [options.export]\n\t\t\t\t)\n\t\t\t: \"\";\n\t\tconst result = new ConcatSource(source);\n\t\tif (staticExports) {\n\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\tconst exportTarget = accessWithInit(\n\t\t\t\tfullNameResolved,\n\t\t\t\tthis._getPrefix(compilation).length,\n\t\t\t\ttrue\n\t\t\t);\n\t\t\tfor (const exportInfo of exportsInfo.orderedExports) {\n\t\t\t\tif (!exportInfo.provided) continue;\n\t\t\t\tconst nameAccess = propertyAccess([exportInfo.name]);\n\t\t\t\tresult.add(\n\t\t\t\t\t`${exportTarget}${nameAccess} = ${RuntimeGlobals.exports}${exportAccess}${nameAccess};\\n`\n\t\t\t\t);\n\t\t\t}\n\t\t\tresult.add(\n\t\t\t\t`Object.defineProperty(${exportTarget}, \"__esModule\", { value: true });\\n`\n\t\t\t);\n\t\t} else if (options.name ? this.named === \"copy\" : this.unnamed === \"copy\") {\n\t\t\tresult.add(\n\t\t\t\t`var __webpack_export_target__ = ${accessWithInit(\n\t\t\t\t\tfullNameResolved,\n\t\t\t\t\tthis._getPrefix(compilation).length,\n\t\t\t\t\ttrue\n\t\t\t\t)};\\n`\n\t\t\t);\n\t\t\t/** @type {String} */\n\t\t\tlet exports = RuntimeGlobals.exports;\n\t\t\tif (exportAccess) {\n\t\t\t\tresult.add(\n\t\t\t\t\t`var __webpack_exports_export__ = ${RuntimeGlobals.exports}${exportAccess};\\n`\n\t\t\t\t);\n\t\t\t\texports = \"__webpack_exports_export__\";\n\t\t\t}\n\t\t\tresult.add(\n\t\t\t\t`for(var i in ${exports}) __webpack_export_target__[i] = ${exports}[i];\\n`\n\t\t\t);\n\t\t\tresult.add(\n\t\t\t\t`if(${exports}.__esModule) Object.defineProperty(__webpack_export_target__, \"__esModule\", { value: true });\\n`\n\t\t\t);\n\t\t} else {\n\t\t\tresult.add(\n\t\t\t\t`${accessWithInit(\n\t\t\t\t\tfullNameResolved,\n\t\t\t\t\tthis._getPrefix(compilation).length,\n\t\t\t\t\tfalse\n\t\t\t\t)} = ${RuntimeGlobals.exports}${exportAccess};\\n`\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Set<string>} set runtime requirements\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {void}\n\t */\n\truntimeRequirements(chunk, set, libraryContext) {\n\t\t// we don't need to return exports from runtime\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Hash} hash hash\n\t * @param {ChunkHashContext} chunkHashContext chunk hash context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {void}\n\t */\n\tchunkHash(chunk, hash, chunkHashContext, { options, compilation }) {\n\t\thash.update(\"AssignLibraryPlugin\");\n\t\tconst fullNameResolved = this._getResolvedFullName(\n\t\t\toptions,\n\t\t\tchunk,\n\t\t\tcompilation\n\t\t);\n\t\tif (options.name ? this.named === \"copy\" : this.unnamed === \"copy\") {\n\t\t\thash.update(\"copy\");\n\t\t}\n\t\tif (this.declare) {\n\t\t\thash.update(this.declare);\n\t\t}\n\t\thash.update(fullNameResolved.join(\".\"));\n\t\tif (options.export) {\n\t\t\thash.update(`${options.export}`);\n\t\t}\n\t}\n}\n\nmodule.exports = AssignLibraryPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst glob2regexp = require(\"glob-to-regexp\");\nconst {\n  JAVASCRIPT_MODULE_TYPE_AUTO,\n  JAVASCRIPT_MODULE_TYPE_ESM,\n  JAVASCRIPT_MODULE_TYPE_DYNAMIC\n} = require(\"../ModuleTypeConstants\");\nconst {\n  STAGE_DEFAULT\n} = require(\"../OptimizationStages\");\nconst HarmonyExportImportedSpecifierDependency = require(\"../dependencies/HarmonyExportImportedSpecifierDependency\");\nconst HarmonyImportSpecifierDependency = require(\"../dependencies/HarmonyImportSpecifierDependency\");\nconst formatLocation = require(\"../formatLocation\");\n\n/** @typedef {import(\"estree\").ModuleDeclaration} ModuleDeclaration */\n/** @typedef {import(\"estree\").Statement} Statement */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../Module\").BuildMeta} BuildMeta */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n\n/**\n * @typedef {Object} ExportInModule\n * @property {Module} module the module\n * @property {string} exportName the name of the export\n * @property {boolean} checked if the export is conditional\n */\n\n/**\n * @typedef {Object} ReexportInfo\n * @property {Map<string, ExportInModule[]>} static\n * @property {Map<Module, Set<string>>} dynamic\n */\n\n/** @typedef {Map<string, RegExp>} CacheItem */\n\n/** @type {WeakMap<any, CacheItem>} */\nconst globToRegexpCache = new WeakMap();\n\n/**\n * @param {string} glob the pattern\n * @param {Map<string, RegExp>} cache the glob to RegExp cache\n * @returns {RegExp} a regular expression\n */\nconst globToRegexp = (glob, cache) => {\n  const cacheEntry = cache.get(glob);\n  if (cacheEntry !== undefined) return cacheEntry;\n  if (!glob.includes(\"/\")) {\n    glob = `**/${glob}`;\n  }\n  const baseRegexp = glob2regexp(glob, {\n    globstar: true,\n    extended: true\n  });\n  const regexpSource = baseRegexp.source;\n  const regexp = new RegExp(\"^(\\\\./)?\" + regexpSource.slice(1));\n  cache.set(glob, regexp);\n  return regexp;\n};\nconst PLUGIN_NAME = \"SideEffectsFlagPlugin\";\nclass SideEffectsFlagPlugin {\n  /**\n   * @param {boolean} analyseSource analyse source code for side effects\n   */\n  constructor(analyseSource = true) {\n    this._analyseSource = analyseSource;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    let cache = globToRegexpCache.get(compiler.root);\n    if (cache === undefined) {\n      cache = new Map();\n      globToRegexpCache.set(compiler.root, cache);\n    }\n    compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation, {\n      normalModuleFactory\n    }) => {\n      const moduleGraph = compilation.moduleGraph;\n      normalModuleFactory.hooks.module.tap(PLUGIN_NAME, (module, data) => {\n        const resolveData = data.resourceResolveData;\n        if (resolveData && resolveData.descriptionFileData && resolveData.relativePath) {\n          const sideEffects = resolveData.descriptionFileData.sideEffects;\n          if (sideEffects !== undefined) {\n            if (module.factoryMeta === undefined) {\n              module.factoryMeta = {};\n            }\n            const hasSideEffects = SideEffectsFlagPlugin.moduleHasSideEffects(resolveData.relativePath, sideEffects, /** @type {CacheItem} */cache);\n            module.factoryMeta.sideEffectFree = !hasSideEffects;\n          }\n        }\n        return module;\n      });\n      normalModuleFactory.hooks.module.tap(PLUGIN_NAME, (module, data) => {\n        if (typeof data.settings.sideEffects === \"boolean\") {\n          if (module.factoryMeta === undefined) {\n            module.factoryMeta = {};\n          }\n          module.factoryMeta.sideEffectFree = !data.settings.sideEffects;\n        }\n        return module;\n      });\n      if (this._analyseSource) {\n        /**\n         * @param {JavascriptParser} parser the parser\n         * @returns {void}\n         */\n        const parserHandler = parser => {\n          /** @type {undefined | Statement | ModuleDeclaration} */\n          let sideEffectsStatement;\n          parser.hooks.program.tap(PLUGIN_NAME, () => {\n            sideEffectsStatement = undefined;\n          });\n          parser.hooks.statement.tap({\n            name: PLUGIN_NAME,\n            stage: -100\n          }, statement => {\n            if (sideEffectsStatement) return;\n            if (parser.scope.topLevelScope !== true) return;\n            switch (statement.type) {\n              case \"ExpressionStatement\":\n                if (!parser.isPure(statement.expression, /** @type {Range} */statement.range[0])) {\n                  sideEffectsStatement = statement;\n                }\n                break;\n              case \"IfStatement\":\n              case \"WhileStatement\":\n              case \"DoWhileStatement\":\n                if (!parser.isPure(statement.test, /** @type {Range} */statement.range[0])) {\n                  sideEffectsStatement = statement;\n                }\n                // statement hook will be called for child statements too\n                break;\n              case \"ForStatement\":\n                if (!parser.isPure(statement.init, /** @type {Range} */statement.range[0]) || !parser.isPure(statement.test, statement.init ? /** @type {Range} */statement.init.range[1] : /** @type {Range} */statement.range[0]) || !parser.isPure(statement.update, statement.test ? /** @type {Range} */statement.test.range[1] : statement.init ? /** @type {Range} */statement.init.range[1] : /** @type {Range} */statement.range[0])) {\n                  sideEffectsStatement = statement;\n                }\n                // statement hook will be called for child statements too\n                break;\n              case \"SwitchStatement\":\n                if (!parser.isPure(statement.discriminant, /** @type {Range} */statement.range[0])) {\n                  sideEffectsStatement = statement;\n                }\n                // statement hook will be called for child statements too\n                break;\n              case \"VariableDeclaration\":\n              case \"ClassDeclaration\":\n              case \"FunctionDeclaration\":\n                if (!parser.isPure(statement, /** @type {Range} */statement.range[0])) {\n                  sideEffectsStatement = statement;\n                }\n                break;\n              case \"ExportNamedDeclaration\":\n              case \"ExportDefaultDeclaration\":\n                if (!parser.isPure(statement.declaration, /** @type {Range} */statement.range[0])) {\n                  sideEffectsStatement = statement;\n                }\n                break;\n              case \"LabeledStatement\":\n              case \"BlockStatement\":\n                // statement hook will be called for child statements too\n                break;\n              case \"EmptyStatement\":\n                break;\n              case \"ExportAllDeclaration\":\n              case \"ImportDeclaration\":\n                // imports will be handled by the dependencies\n                break;\n              default:\n                sideEffectsStatement = statement;\n                break;\n            }\n          });\n          parser.hooks.finish.tap(PLUGIN_NAME, () => {\n            if (sideEffectsStatement === undefined) {\n              /** @type {BuildMeta} */\n              parser.state.module.buildMeta.sideEffectFree = true;\n            } else {\n              const {\n                loc,\n                type\n              } = sideEffectsStatement;\n              moduleGraph.getOptimizationBailout(parser.state.module).push(() => `Statement (${type}) with side effects in source code at ${formatLocation( /** @type {DependencyLocation} */loc)}`);\n            }\n          });\n        };\n        for (const key of [JAVASCRIPT_MODULE_TYPE_AUTO, JAVASCRIPT_MODULE_TYPE_ESM, JAVASCRIPT_MODULE_TYPE_DYNAMIC]) {\n          normalModuleFactory.hooks.parser.for(key).tap(PLUGIN_NAME, parserHandler);\n        }\n      }\n      compilation.hooks.optimizeDependencies.tap({\n        name: PLUGIN_NAME,\n        stage: STAGE_DEFAULT\n      }, modules => {\n        const logger = compilation.getLogger(\"webpack.SideEffectsFlagPlugin\");\n        logger.time(\"update dependencies\");\n        const optimizedModules = new Set();\n\n        /**\n         * @param {Module} module module\n         */\n        const optimizeIncomingConnections = module => {\n          if (optimizedModules.has(module)) return;\n          optimizedModules.add(module);\n          if (module.getSideEffectsConnectionState(moduleGraph) === false) {\n            const exportsInfo = moduleGraph.getExportsInfo(module);\n            for (const connection of moduleGraph.getIncomingConnections(module)) {\n              const dep = connection.dependency;\n              let isReexport;\n              if ((isReexport = dep instanceof HarmonyExportImportedSpecifierDependency) || dep instanceof HarmonyImportSpecifierDependency && !dep.namespaceObjectAsContext) {\n                if (connection.originModule !== null) {\n                  optimizeIncomingConnections(connection.originModule);\n                }\n                // TODO improve for export *\n                if (isReexport && dep.name) {\n                  const exportInfo = moduleGraph.getExportInfo( /** @type {Module} */connection.originModule, dep.name);\n                  exportInfo.moveTarget(moduleGraph, ({\n                    module\n                  }) => module.getSideEffectsConnectionState(moduleGraph) === false, ({\n                    module: newModule,\n                    export: exportName\n                  }) => {\n                    moduleGraph.updateModule(dep, newModule);\n                    moduleGraph.addExplanation(dep, \"(skipped side-effect-free modules)\");\n                    const ids = dep.getIds(moduleGraph);\n                    dep.setIds(moduleGraph, exportName ? [...exportName, ...ids.slice(1)] : ids.slice(1));\n                    return moduleGraph.getConnection(dep);\n                  });\n                  continue;\n                }\n                // TODO improve for nested imports\n                const ids = dep.getIds(moduleGraph);\n                if (ids.length > 0) {\n                  const exportInfo = exportsInfo.getExportInfo(ids[0]);\n                  const target = exportInfo.getTarget(moduleGraph, ({\n                    module\n                  }) => module.getSideEffectsConnectionState(moduleGraph) === false);\n                  if (!target) continue;\n                  moduleGraph.updateModule(dep, target.module);\n                  moduleGraph.addExplanation(dep, \"(skipped side-effect-free modules)\");\n                  dep.setIds(moduleGraph, target.export ? [...target.export, ...ids.slice(1)] : ids.slice(1));\n                }\n              }\n            }\n          }\n        };\n        for (const module of modules) {\n          optimizeIncomingConnections(module);\n        }\n        logger.timeEnd(\"update dependencies\");\n      });\n    });\n  }\n\n  /**\n   * @param {string} moduleName the module name\n   * @param {undefined | boolean | string | string[]} flagValue the flag value\n   * @param {Map<string, RegExp>} cache cache for glob to regexp\n   * @returns {boolean | undefined} true, when the module has side effects, undefined or false when not\n   */\n  static moduleHasSideEffects(moduleName, flagValue, cache) {\n    switch (typeof flagValue) {\n      case \"undefined\":\n        return true;\n      case \"boolean\":\n        return flagValue;\n      case \"string\":\n        return globToRegexp(flagValue, cache).test(moduleName);\n      case \"object\":\n        return flagValue.some(glob => SideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob, cache));\n    }\n  }\n}\nmodule.exports = SideEffectsFlagPlugin;","map":{"version":3,"names":["glob2regexp","require","JAVASCRIPT_MODULE_TYPE_AUTO","JAVASCRIPT_MODULE_TYPE_ESM","JAVASCRIPT_MODULE_TYPE_DYNAMIC","STAGE_DEFAULT","HarmonyExportImportedSpecifierDependency","HarmonyImportSpecifierDependency","formatLocation","globToRegexpCache","WeakMap","globToRegexp","glob","cache","cacheEntry","get","undefined","includes","baseRegexp","globstar","extended","regexpSource","source","regexp","RegExp","slice","set","PLUGIN_NAME","SideEffectsFlagPlugin","constructor","analyseSource","_analyseSource","apply","compiler","root","Map","hooks","compilation","tap","normalModuleFactory","moduleGraph","module","data","resolveData","resourceResolveData","descriptionFileData","relativePath","sideEffects","factoryMeta","hasSideEffects","moduleHasSideEffects","sideEffectFree","settings","parserHandler","parser","sideEffectsStatement","program","statement","name","stage","scope","topLevelScope","type","isPure","expression","range","test","init","update","discriminant","declaration","finish","state","buildMeta","loc","getOptimizationBailout","push","key","for","optimizeDependencies","modules","logger","getLogger","time","optimizedModules","Set","optimizeIncomingConnections","has","add","getSideEffectsConnectionState","exportsInfo","getExportsInfo","connection","getIncomingConnections","dep","dependency","isReexport","namespaceObjectAsContext","originModule","exportInfo","getExportInfo","moveTarget","newModule","export","exportName","updateModule","addExplanation","ids","getIds","setIds","getConnection","length","target","getTarget","timeEnd","moduleName","flagValue","some","exports"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/optimize/SideEffectsFlagPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst glob2regexp = require(\"glob-to-regexp\");\nconst {\n\tJAVASCRIPT_MODULE_TYPE_AUTO,\n\tJAVASCRIPT_MODULE_TYPE_ESM,\n\tJAVASCRIPT_MODULE_TYPE_DYNAMIC\n} = require(\"../ModuleTypeConstants\");\nconst { STAGE_DEFAULT } = require(\"../OptimizationStages\");\nconst HarmonyExportImportedSpecifierDependency = require(\"../dependencies/HarmonyExportImportedSpecifierDependency\");\nconst HarmonyImportSpecifierDependency = require(\"../dependencies/HarmonyImportSpecifierDependency\");\nconst formatLocation = require(\"../formatLocation\");\n\n/** @typedef {import(\"estree\").ModuleDeclaration} ModuleDeclaration */\n/** @typedef {import(\"estree\").Statement} Statement */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../Module\").BuildMeta} BuildMeta */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n\n/**\n * @typedef {Object} ExportInModule\n * @property {Module} module the module\n * @property {string} exportName the name of the export\n * @property {boolean} checked if the export is conditional\n */\n\n/**\n * @typedef {Object} ReexportInfo\n * @property {Map<string, ExportInModule[]>} static\n * @property {Map<Module, Set<string>>} dynamic\n */\n\n/** @typedef {Map<string, RegExp>} CacheItem */\n\n/** @type {WeakMap<any, CacheItem>} */\nconst globToRegexpCache = new WeakMap();\n\n/**\n * @param {string} glob the pattern\n * @param {Map<string, RegExp>} cache the glob to RegExp cache\n * @returns {RegExp} a regular expression\n */\nconst globToRegexp = (glob, cache) => {\n\tconst cacheEntry = cache.get(glob);\n\tif (cacheEntry !== undefined) return cacheEntry;\n\tif (!glob.includes(\"/\")) {\n\t\tglob = `**/${glob}`;\n\t}\n\tconst baseRegexp = glob2regexp(glob, { globstar: true, extended: true });\n\tconst regexpSource = baseRegexp.source;\n\tconst regexp = new RegExp(\"^(\\\\./)?\" + regexpSource.slice(1));\n\tcache.set(glob, regexp);\n\treturn regexp;\n};\n\nconst PLUGIN_NAME = \"SideEffectsFlagPlugin\";\n\nclass SideEffectsFlagPlugin {\n\t/**\n\t * @param {boolean} analyseSource analyse source code for side effects\n\t */\n\tconstructor(analyseSource = true) {\n\t\tthis._analyseSource = analyseSource;\n\t}\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tlet cache = globToRegexpCache.get(compiler.root);\n\t\tif (cache === undefined) {\n\t\t\tcache = new Map();\n\t\t\tglobToRegexpCache.set(compiler.root, cache);\n\t\t}\n\t\tcompiler.hooks.compilation.tap(\n\t\t\tPLUGIN_NAME,\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\t\tnormalModuleFactory.hooks.module.tap(PLUGIN_NAME, (module, data) => {\n\t\t\t\t\tconst resolveData = data.resourceResolveData;\n\t\t\t\t\tif (\n\t\t\t\t\t\tresolveData &&\n\t\t\t\t\t\tresolveData.descriptionFileData &&\n\t\t\t\t\t\tresolveData.relativePath\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst sideEffects = resolveData.descriptionFileData.sideEffects;\n\t\t\t\t\t\tif (sideEffects !== undefined) {\n\t\t\t\t\t\t\tif (module.factoryMeta === undefined) {\n\t\t\t\t\t\t\t\tmodule.factoryMeta = {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst hasSideEffects = SideEffectsFlagPlugin.moduleHasSideEffects(\n\t\t\t\t\t\t\t\tresolveData.relativePath,\n\t\t\t\t\t\t\t\tsideEffects,\n\t\t\t\t\t\t\t\t/** @type {CacheItem} */ (cache)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tmodule.factoryMeta.sideEffectFree = !hasSideEffects;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn module;\n\t\t\t\t});\n\t\t\t\tnormalModuleFactory.hooks.module.tap(PLUGIN_NAME, (module, data) => {\n\t\t\t\t\tif (typeof data.settings.sideEffects === \"boolean\") {\n\t\t\t\t\t\tif (module.factoryMeta === undefined) {\n\t\t\t\t\t\t\tmodule.factoryMeta = {};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodule.factoryMeta.sideEffectFree = !data.settings.sideEffects;\n\t\t\t\t\t}\n\t\t\t\t\treturn module;\n\t\t\t\t});\n\t\t\t\tif (this._analyseSource) {\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {JavascriptParser} parser the parser\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst parserHandler = parser => {\n\t\t\t\t\t\t/** @type {undefined | Statement | ModuleDeclaration} */\n\t\t\t\t\t\tlet sideEffectsStatement;\n\t\t\t\t\t\tparser.hooks.program.tap(PLUGIN_NAME, () => {\n\t\t\t\t\t\t\tsideEffectsStatement = undefined;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.statement.tap(\n\t\t\t\t\t\t\t{ name: PLUGIN_NAME, stage: -100 },\n\t\t\t\t\t\t\tstatement => {\n\t\t\t\t\t\t\t\tif (sideEffectsStatement) return;\n\t\t\t\t\t\t\t\tif (parser.scope.topLevelScope !== true) return;\n\t\t\t\t\t\t\t\tswitch (statement.type) {\n\t\t\t\t\t\t\t\t\tcase \"ExpressionStatement\":\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!parser.isPure(\n\t\t\t\t\t\t\t\t\t\t\t\tstatement.expression,\n\t\t\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (statement.range)[0]\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tsideEffectsStatement = statement;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"IfStatement\":\n\t\t\t\t\t\t\t\t\tcase \"WhileStatement\":\n\t\t\t\t\t\t\t\t\tcase \"DoWhileStatement\":\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!parser.isPure(\n\t\t\t\t\t\t\t\t\t\t\t\tstatement.test,\n\t\t\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (statement.range)[0]\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tsideEffectsStatement = statement;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// statement hook will be called for child statements too\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"ForStatement\":\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!parser.isPure(\n\t\t\t\t\t\t\t\t\t\t\t\tstatement.init,\n\t\t\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (statement.range)[0]\n\t\t\t\t\t\t\t\t\t\t\t) ||\n\t\t\t\t\t\t\t\t\t\t\t!parser.isPure(\n\t\t\t\t\t\t\t\t\t\t\t\tstatement.test,\n\t\t\t\t\t\t\t\t\t\t\t\tstatement.init\n\t\t\t\t\t\t\t\t\t\t\t\t\t? /** @type {Range} */ (statement.init.range)[1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t: /** @type {Range} */ (statement.range)[0]\n\t\t\t\t\t\t\t\t\t\t\t) ||\n\t\t\t\t\t\t\t\t\t\t\t!parser.isPure(\n\t\t\t\t\t\t\t\t\t\t\t\tstatement.update,\n\t\t\t\t\t\t\t\t\t\t\t\tstatement.test\n\t\t\t\t\t\t\t\t\t\t\t\t\t? /** @type {Range} */ (statement.test.range)[1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t: statement.init\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? /** @type {Range} */ (statement.init.range)[1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: /** @type {Range} */ (statement.range)[0]\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tsideEffectsStatement = statement;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// statement hook will be called for child statements too\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"SwitchStatement\":\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!parser.isPure(\n\t\t\t\t\t\t\t\t\t\t\t\tstatement.discriminant,\n\t\t\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (statement.range)[0]\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tsideEffectsStatement = statement;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// statement hook will be called for child statements too\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"VariableDeclaration\":\n\t\t\t\t\t\t\t\t\tcase \"ClassDeclaration\":\n\t\t\t\t\t\t\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!parser.isPure(\n\t\t\t\t\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (statement.range)[0]\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tsideEffectsStatement = statement;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\t\t\t\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!parser.isPure(\n\t\t\t\t\t\t\t\t\t\t\t\tstatement.declaration,\n\t\t\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (statement.range)[0]\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tsideEffectsStatement = statement;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"LabeledStatement\":\n\t\t\t\t\t\t\t\t\tcase \"BlockStatement\":\n\t\t\t\t\t\t\t\t\t\t// statement hook will be called for child statements too\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"EmptyStatement\":\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"ExportAllDeclaration\":\n\t\t\t\t\t\t\t\t\tcase \"ImportDeclaration\":\n\t\t\t\t\t\t\t\t\t\t// imports will be handled by the dependencies\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tsideEffectsStatement = statement;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t\tparser.hooks.finish.tap(PLUGIN_NAME, () => {\n\t\t\t\t\t\t\tif (sideEffectsStatement === undefined) {\n\t\t\t\t\t\t\t\t/** @type {BuildMeta} */\n\t\t\t\t\t\t\t\t(parser.state.module.buildMeta).sideEffectFree = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst { loc, type } = sideEffectsStatement;\n\t\t\t\t\t\t\t\tmoduleGraph\n\t\t\t\t\t\t\t\t\t.getOptimizationBailout(parser.state.module)\n\t\t\t\t\t\t\t\t\t.push(\n\t\t\t\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\t\t\t\t`Statement (${type}) with side effects in source code at ${formatLocation(\n\t\t\t\t\t\t\t\t\t\t\t\t/** @type {DependencyLocation} */ (loc)\n\t\t\t\t\t\t\t\t\t\t\t)}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\t\t\t\t\tfor (const key of [\n\t\t\t\t\t\tJAVASCRIPT_MODULE_TYPE_AUTO,\n\t\t\t\t\t\tJAVASCRIPT_MODULE_TYPE_ESM,\n\t\t\t\t\t\tJAVASCRIPT_MODULE_TYPE_DYNAMIC\n\t\t\t\t\t]) {\n\t\t\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(PLUGIN_NAME, parserHandler);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcompilation.hooks.optimizeDependencies.tap(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: PLUGIN_NAME,\n\t\t\t\t\t\tstage: STAGE_DEFAULT\n\t\t\t\t\t},\n\t\t\t\t\tmodules => {\n\t\t\t\t\t\tconst logger = compilation.getLogger(\n\t\t\t\t\t\t\t\"webpack.SideEffectsFlagPlugin\"\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tlogger.time(\"update dependencies\");\n\n\t\t\t\t\t\tconst optimizedModules = new Set();\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {Module} module module\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst optimizeIncomingConnections = module => {\n\t\t\t\t\t\t\tif (optimizedModules.has(module)) return;\n\t\t\t\t\t\t\toptimizedModules.add(module);\n\t\t\t\t\t\t\tif (module.getSideEffectsConnectionState(moduleGraph) === false) {\n\t\t\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\t\t\tfor (const connection of moduleGraph.getIncomingConnections(\n\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\t\tconst dep = connection.dependency;\n\t\t\t\t\t\t\t\t\tlet isReexport;\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t(isReexport =\n\t\t\t\t\t\t\t\t\t\t\tdep instanceof\n\t\t\t\t\t\t\t\t\t\t\tHarmonyExportImportedSpecifierDependency) ||\n\t\t\t\t\t\t\t\t\t\t(dep instanceof HarmonyImportSpecifierDependency &&\n\t\t\t\t\t\t\t\t\t\t\t!dep.namespaceObjectAsContext)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tif (connection.originModule !== null) {\n\t\t\t\t\t\t\t\t\t\t\toptimizeIncomingConnections(connection.originModule);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// TODO improve for export *\n\t\t\t\t\t\t\t\t\t\tif (isReexport && dep.name) {\n\t\t\t\t\t\t\t\t\t\t\tconst exportInfo = moduleGraph.getExportInfo(\n\t\t\t\t\t\t\t\t\t\t\t\t/** @type {Module} */ (connection.originModule),\n\t\t\t\t\t\t\t\t\t\t\t\tdep.name\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\texportInfo.moveTarget(\n\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\t\t\t\t\t\t\t({ module }) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\tmodule.getSideEffectsConnectionState(moduleGraph) ===\n\t\t\t\t\t\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\t\t\t\t({ module: newModule, export: exportName }) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph.updateModule(dep, newModule);\n\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph.addExplanation(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdep,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"(skipped side-effect-free modules)\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst ids = dep.getIds(moduleGraph);\n\t\t\t\t\t\t\t\t\t\t\t\t\tdep.setIds(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\texportName\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? [...exportName, ...ids.slice(1)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: ids.slice(1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn moduleGraph.getConnection(dep);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// TODO improve for nested imports\n\t\t\t\t\t\t\t\t\t\tconst ids = dep.getIds(moduleGraph);\n\t\t\t\t\t\t\t\t\t\tif (ids.length > 0) {\n\t\t\t\t\t\t\t\t\t\t\tconst exportInfo = exportsInfo.getExportInfo(ids[0]);\n\t\t\t\t\t\t\t\t\t\t\tconst target = exportInfo.getTarget(\n\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\t\t\t\t\t\t\t({ module }) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\tmodule.getSideEffectsConnectionState(moduleGraph) ===\n\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tif (!target) continue;\n\n\t\t\t\t\t\t\t\t\t\t\tmoduleGraph.updateModule(dep, target.module);\n\t\t\t\t\t\t\t\t\t\t\tmoduleGraph.addExplanation(\n\t\t\t\t\t\t\t\t\t\t\t\tdep,\n\t\t\t\t\t\t\t\t\t\t\t\t\"(skipped side-effect-free modules)\"\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tdep.setIds(\n\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\t\t\t\t\t\t\ttarget.export\n\t\t\t\t\t\t\t\t\t\t\t\t\t? [...target.export, ...ids.slice(1)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t: ids.slice(1)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\toptimizeIncomingConnections(module);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlogger.timeEnd(\"update dependencies\");\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {string} moduleName the module name\n\t * @param {undefined | boolean | string | string[]} flagValue the flag value\n\t * @param {Map<string, RegExp>} cache cache for glob to regexp\n\t * @returns {boolean | undefined} true, when the module has side effects, undefined or false when not\n\t */\n\tstatic moduleHasSideEffects(moduleName, flagValue, cache) {\n\t\tswitch (typeof flagValue) {\n\t\t\tcase \"undefined\":\n\t\t\t\treturn true;\n\t\t\tcase \"boolean\":\n\t\t\t\treturn flagValue;\n\t\t\tcase \"string\":\n\t\t\t\treturn globToRegexp(flagValue, cache).test(moduleName);\n\t\t\tcase \"object\":\n\t\t\t\treturn flagValue.some(glob =>\n\t\t\t\t\tSideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob, cache)\n\t\t\t\t);\n\t\t}\n\t}\n}\nmodule.exports = SideEffectsFlagPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
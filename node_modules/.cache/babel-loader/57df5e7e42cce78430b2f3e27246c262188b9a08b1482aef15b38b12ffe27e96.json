{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst RequireEnsureDependenciesBlock = require(\"./RequireEnsureDependenciesBlock\");\nconst RequireEnsureDependency = require(\"./RequireEnsureDependency\");\nconst RequireEnsureItemDependency = require(\"./RequireEnsureItemDependency\");\nconst getFunctionExpression = require(\"./getFunctionExpression\");\n\n/** @typedef {import(\"../ChunkGroup\").ChunkGroupOptions} ChunkGroupOptions */\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"../javascript/BasicEvaluatedExpression\")} BasicEvaluatedExpression */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n\nmodule.exports = class RequireEnsureDependenciesBlockParserPlugin {\n  /**\n   * @param {JavascriptParser} parser the parser\n   * @returns {void}\n   */\n  apply(parser) {\n    parser.hooks.call.for(\"require.ensure\").tap(\"RequireEnsureDependenciesBlockParserPlugin\", expr => {\n      let chunkName = null;\n      let errorExpressionArg = null;\n      let errorExpression = null;\n      switch (expr.arguments.length) {\n        case 4:\n          {\n            const chunkNameExpr = parser.evaluateExpression(expr.arguments[3]);\n            if (!chunkNameExpr.isString()) return;\n            chunkName = chunkNameExpr.string;\n          }\n        // falls through\n        case 3:\n          {\n            errorExpressionArg = expr.arguments[2];\n            errorExpression = getFunctionExpression(errorExpressionArg);\n            if (!errorExpression && !chunkName) {\n              const chunkNameExpr = parser.evaluateExpression(expr.arguments[2]);\n              if (!chunkNameExpr.isString()) return;\n              chunkName = chunkNameExpr.string;\n            }\n          }\n        // falls through\n        case 2:\n          {\n            const dependenciesExpr = parser.evaluateExpression(expr.arguments[0]);\n            const dependenciesItems = /** @type {BasicEvaluatedExpression[]} */\n            dependenciesExpr.isArray() ? dependenciesExpr.items : [dependenciesExpr];\n            const successExpressionArg = expr.arguments[1];\n            const successExpression = getFunctionExpression(successExpressionArg);\n            if (successExpression) {\n              parser.walkExpressions(successExpression.expressions);\n            }\n            if (errorExpression) {\n              parser.walkExpressions(errorExpression.expressions);\n            }\n            const depBlock = new RequireEnsureDependenciesBlock( /** @type {ChunkGroupOptions & { entryOptions?: TODO }} */\n            chunkName, /** @type {DependencyLocation} */expr.loc);\n            const errorCallbackExists = expr.arguments.length === 4 || !chunkName && expr.arguments.length === 3;\n            const dep = new RequireEnsureDependency( /** @type {Range} */expr.range, /** @type {Range} */expr.arguments[1].range, errorCallbackExists && ( /** @type {Range} */expr.arguments[2].range));\n            dep.loc = /** @type {DependencyLocation} */expr.loc;\n            depBlock.addDependency(dep);\n            const old = parser.state.current;\n            parser.state.current = /** @type {TODO} */depBlock;\n            try {\n              let failed = false;\n              parser.inScope([], () => {\n                for (const ee of dependenciesItems) {\n                  if (ee.isString()) {\n                    const ensureDependency = new RequireEnsureItemDependency( /** @type {string} */ee.string);\n                    ensureDependency.loc = /** @type {DependencyLocation} */\n                    expr.loc;\n                    depBlock.addDependency(ensureDependency);\n                  } else {\n                    failed = true;\n                  }\n                }\n              });\n              if (failed) {\n                return;\n              }\n              if (successExpression) {\n                if (successExpression.fn.body.type === \"BlockStatement\") {\n                  parser.walkStatement(successExpression.fn.body);\n                } else {\n                  parser.walkExpression(successExpression.fn.body);\n                }\n              }\n              old.addBlock(depBlock);\n            } finally {\n              parser.state.current = old;\n            }\n            if (!successExpression) {\n              parser.walkExpression(successExpressionArg);\n            }\n            if (errorExpression) {\n              if (errorExpression.fn.body.type === \"BlockStatement\") {\n                parser.walkStatement(errorExpression.fn.body);\n              } else {\n                parser.walkExpression(errorExpression.fn.body);\n              }\n            } else if (errorExpressionArg) {\n              parser.walkExpression(errorExpressionArg);\n            }\n            return true;\n          }\n      }\n    });\n  }\n};","map":{"version":3,"names":["RequireEnsureDependenciesBlock","require","RequireEnsureDependency","RequireEnsureItemDependency","getFunctionExpression","module","exports","RequireEnsureDependenciesBlockParserPlugin","apply","parser","hooks","call","for","tap","expr","chunkName","errorExpressionArg","errorExpression","arguments","length","chunkNameExpr","evaluateExpression","isString","string","dependenciesExpr","dependenciesItems","isArray","items","successExpressionArg","successExpression","walkExpressions","expressions","depBlock","loc","errorCallbackExists","dep","range","addDependency","old","state","current","failed","inScope","ee","ensureDependency","fn","body","type","walkStatement","walkExpression","addBlock"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/dependencies/RequireEnsureDependenciesBlockParserPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst RequireEnsureDependenciesBlock = require(\"./RequireEnsureDependenciesBlock\");\nconst RequireEnsureDependency = require(\"./RequireEnsureDependency\");\nconst RequireEnsureItemDependency = require(\"./RequireEnsureItemDependency\");\nconst getFunctionExpression = require(\"./getFunctionExpression\");\n\n/** @typedef {import(\"../ChunkGroup\").ChunkGroupOptions} ChunkGroupOptions */\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"../javascript/BasicEvaluatedExpression\")} BasicEvaluatedExpression */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n\nmodule.exports = class RequireEnsureDependenciesBlockParserPlugin {\n\t/**\n\t * @param {JavascriptParser} parser the parser\n\t * @returns {void}\n\t */\n\tapply(parser) {\n\t\tparser.hooks.call\n\t\t\t.for(\"require.ensure\")\n\t\t\t.tap(\"RequireEnsureDependenciesBlockParserPlugin\", expr => {\n\t\t\t\tlet chunkName = null;\n\t\t\t\tlet errorExpressionArg = null;\n\t\t\t\tlet errorExpression = null;\n\t\t\t\tswitch (expr.arguments.length) {\n\t\t\t\t\tcase 4: {\n\t\t\t\t\t\tconst chunkNameExpr = parser.evaluateExpression(expr.arguments[3]);\n\t\t\t\t\t\tif (!chunkNameExpr.isString()) return;\n\t\t\t\t\t\tchunkName = chunkNameExpr.string;\n\t\t\t\t\t}\n\t\t\t\t\t// falls through\n\t\t\t\t\tcase 3: {\n\t\t\t\t\t\terrorExpressionArg = expr.arguments[2];\n\t\t\t\t\t\terrorExpression = getFunctionExpression(errorExpressionArg);\n\n\t\t\t\t\t\tif (!errorExpression && !chunkName) {\n\t\t\t\t\t\t\tconst chunkNameExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\texpr.arguments[2]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (!chunkNameExpr.isString()) return;\n\t\t\t\t\t\t\tchunkName = chunkNameExpr.string;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// falls through\n\t\t\t\t\tcase 2: {\n\t\t\t\t\t\tconst dependenciesExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\texpr.arguments[0]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst dependenciesItems =\n\t\t\t\t\t\t\t/** @type {BasicEvaluatedExpression[]} */ (\n\t\t\t\t\t\t\t\tdependenciesExpr.isArray()\n\t\t\t\t\t\t\t\t\t? dependenciesExpr.items\n\t\t\t\t\t\t\t\t\t: [dependenciesExpr]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tconst successExpressionArg = expr.arguments[1];\n\t\t\t\t\t\tconst successExpression =\n\t\t\t\t\t\t\tgetFunctionExpression(successExpressionArg);\n\n\t\t\t\t\t\tif (successExpression) {\n\t\t\t\t\t\t\tparser.walkExpressions(successExpression.expressions);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (errorExpression) {\n\t\t\t\t\t\t\tparser.walkExpressions(errorExpression.expressions);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst depBlock = new RequireEnsureDependenciesBlock(\n\t\t\t\t\t\t\t/** @type {ChunkGroupOptions & { entryOptions?: TODO }} */\n\t\t\t\t\t\t\t(chunkName),\n\t\t\t\t\t\t\t/** @type {DependencyLocation} */ (expr.loc)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst errorCallbackExists =\n\t\t\t\t\t\t\texpr.arguments.length === 4 ||\n\t\t\t\t\t\t\t(!chunkName && expr.arguments.length === 3);\n\t\t\t\t\t\tconst dep = new RequireEnsureDependency(\n\t\t\t\t\t\t\t/** @type {Range} */ (expr.range),\n\t\t\t\t\t\t\t/** @type {Range} */ (expr.arguments[1].range),\n\t\t\t\t\t\t\terrorCallbackExists &&\n\t\t\t\t\t\t\t\t/** @type {Range} */ (expr.arguments[2].range)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\t\t\tdepBlock.addDependency(dep);\n\t\t\t\t\t\tconst old = parser.state.current;\n\t\t\t\t\t\tparser.state.current = /** @type {TODO} */ (depBlock);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet failed = false;\n\t\t\t\t\t\t\tparser.inScope([], () => {\n\t\t\t\t\t\t\t\tfor (const ee of dependenciesItems) {\n\t\t\t\t\t\t\t\t\tif (ee.isString()) {\n\t\t\t\t\t\t\t\t\t\tconst ensureDependency = new RequireEnsureItemDependency(\n\t\t\t\t\t\t\t\t\t\t\t/** @type {string} */ (ee.string)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tensureDependency.loc =\n\t\t\t\t\t\t\t\t\t\t\t/** @type {DependencyLocation} */\n\t\t\t\t\t\t\t\t\t\t\t(expr.loc);\n\t\t\t\t\t\t\t\t\t\tdepBlock.addDependency(ensureDependency);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tfailed = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif (failed) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (successExpression) {\n\t\t\t\t\t\t\t\tif (successExpression.fn.body.type === \"BlockStatement\") {\n\t\t\t\t\t\t\t\t\tparser.walkStatement(successExpression.fn.body);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tparser.walkExpression(successExpression.fn.body);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\told.addBlock(depBlock);\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tparser.state.current = old;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!successExpression) {\n\t\t\t\t\t\t\tparser.walkExpression(successExpressionArg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (errorExpression) {\n\t\t\t\t\t\t\tif (errorExpression.fn.body.type === \"BlockStatement\") {\n\t\t\t\t\t\t\t\tparser.walkStatement(errorExpression.fn.body);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tparser.walkExpression(errorExpression.fn.body);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (errorExpressionArg) {\n\t\t\t\t\t\t\tparser.walkExpression(errorExpressionArg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t}\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst {\n  ConcatSource,\n  RawSource\n} = require(\"webpack-sources\");\nconst Compilation = require(\"./Compilation\");\nconst ModuleFilenameHelpers = require(\"./ModuleFilenameHelpers\");\nconst ProgressPlugin = require(\"./ProgressPlugin\");\nconst SourceMapDevToolModuleOptionsPlugin = require(\"./SourceMapDevToolModuleOptionsPlugin\");\nconst createSchemaValidation = require(\"./util/create-schema-validation\");\nconst createHash = require(\"./util/createHash\");\nconst {\n  relative,\n  dirname\n} = require(\"./util/fs\");\nconst {\n  makePathsAbsolute\n} = require(\"./util/identifier\");\n\n/** @typedef {import(\"webpack-sources\").MapOptions} MapOptions */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../declarations/plugins/SourceMapDevToolPlugin\").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */\n/** @typedef {import(\"./Cache\").Etag} Etag */\n/** @typedef {import(\"./CacheFacade\").ItemCacheFacade} ItemCacheFacade */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Compilation\").Asset} Asset */\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"./Compilation\").PathData} PathData */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./NormalModule\").SourceMap} SourceMap */\n/** @typedef {import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n\nconst validate = createSchemaValidation(require(\"../schemas/plugins/SourceMapDevToolPlugin.check.js\"), () => require(\"../schemas/plugins/SourceMapDevToolPlugin.json\"), {\n  name: \"SourceMap DevTool Plugin\",\n  baseDataPath: \"options\"\n});\n/**\n * @typedef {object} SourceMapTask\n * @property {Source} asset\n * @property {AssetInfo} assetInfo\n * @property {(string | Module)[]} modules\n * @property {string} source\n * @property {string} file\n * @property {SourceMap} sourceMap\n * @property {ItemCacheFacade} cacheItem cache item\n */\n\nconst METACHARACTERS_REGEXP = /[-[\\]\\\\/{}()*+?.^$|]/g;\nconst CONTENT_HASH_DETECT_REGEXP = /\\[contenthash(:\\w+)?\\]/;\nconst CSS_AND_JS_MODULE_EXTENSIONS_REGEXP = /\\.((c|m)?js|css)($|\\?)/i;\nconst CSS_EXTENSION_DETECT_REGEXP = /\\.css($|\\?)/i;\nconst MAP_URL_COMMENT_REGEXP = /\\[map\\]/g;\nconst URL_COMMENT_REGEXP = /\\[url\\]/g;\nconst URL_FORMATTING_REGEXP = /^\\n\\/\\/(.*)$/;\n\n/**\n * Reset's .lastIndex of stateful Regular Expressions\n * For when `test` or `exec` is called on them\n * @param {RegExp} regexp Stateful Regular Expression to be reset\n * @returns {void}\n *\n */\nconst resetRegexpState = regexp => {\n  regexp.lastIndex = -1;\n};\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nconst quoteMeta = str => {\n  return str.replace(METACHARACTERS_REGEXP, \"\\\\$&\");\n};\n\n/**\n * Creating {@link SourceMapTask} for given file\n * @param {string} file current compiled file\n * @param {Source} asset the asset\n * @param {AssetInfo} assetInfo the asset info\n * @param {MapOptions} options source map options\n * @param {Compilation} compilation compilation instance\n * @param {ItemCacheFacade} cacheItem cache item\n * @returns {SourceMapTask | undefined} created task instance or `undefined`\n */\nconst getTaskForFile = (file, asset, assetInfo, options, compilation, cacheItem) => {\n  let source;\n  /** @type {SourceMap} */\n  let sourceMap;\n  /**\n   * Check if asset can build source map\n   */\n  if (asset.sourceAndMap) {\n    const sourceAndMap = asset.sourceAndMap(options);\n    sourceMap = /** @type {SourceMap} */sourceAndMap.map;\n    source = sourceAndMap.source;\n  } else {\n    sourceMap = /** @type {SourceMap} */asset.map(options);\n    source = asset.source();\n  }\n  if (!sourceMap || typeof source !== \"string\") return;\n  const context = compilation.options.context;\n  const root = compilation.compiler.root;\n  const cachedAbsolutify = makePathsAbsolute.bindContextCache(context, root);\n  const modules = sourceMap.sources.map(source => {\n    if (!source.startsWith(\"webpack://\")) return source;\n    source = cachedAbsolutify(source.slice(10));\n    const module = compilation.findModule(source);\n    return module || source;\n  });\n  return {\n    file,\n    asset,\n    source,\n    assetInfo,\n    sourceMap,\n    modules,\n    cacheItem\n  };\n};\nclass SourceMapDevToolPlugin {\n  /**\n   * @param {SourceMapDevToolPluginOptions} [options] options object\n   * @throws {Error} throws error, if got more than 1 arguments\n   */\n  constructor(options = {}) {\n    validate(options);\n\n    /** @type {string | false} */\n    this.sourceMapFilename = options.filename;\n    /** @type {string | false | (function(PathData, AssetInfo=): string)}} */\n    this.sourceMappingURLComment = options.append === false ? false : options.append || \"\\n//# source\" + \"MappingURL=[url]\";\n    /** @type {string | Function} */\n    this.moduleFilenameTemplate = options.moduleFilenameTemplate || \"webpack://[namespace]/[resourcePath]\";\n    /** @type {string | Function} */\n    this.fallbackModuleFilenameTemplate = options.fallbackModuleFilenameTemplate || \"webpack://[namespace]/[resourcePath]?[hash]\";\n    /** @type {string} */\n    this.namespace = options.namespace || \"\";\n    /** @type {SourceMapDevToolPluginOptions} */\n    this.options = options;\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const outputFs = /** @type {OutputFileSystem} */\n    compiler.outputFileSystem;\n    const sourceMapFilename = this.sourceMapFilename;\n    const sourceMappingURLComment = this.sourceMappingURLComment;\n    const moduleFilenameTemplate = this.moduleFilenameTemplate;\n    const namespace = this.namespace;\n    const fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;\n    const requestShortener = compiler.requestShortener;\n    const options = this.options;\n    options.test = options.test || CSS_AND_JS_MODULE_EXTENSIONS_REGEXP;\n    const matchObject = ModuleFilenameHelpers.matchObject.bind(undefined, options);\n    compiler.hooks.compilation.tap(\"SourceMapDevToolPlugin\", compilation => {\n      new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);\n      compilation.hooks.processAssets.tapAsync({\n        name: \"SourceMapDevToolPlugin\",\n        stage: Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING,\n        additionalAssets: true\n      }, (assets, callback) => {\n        const chunkGraph = compilation.chunkGraph;\n        const cache = compilation.getCache(\"SourceMapDevToolPlugin\");\n        /** @type {Map<string | Module, string>} */\n        const moduleToSourceNameMapping = new Map();\n        /**\n         * @type {Function}\n         * @returns {void}\n         */\n        const reportProgress = ProgressPlugin.getReporter(compilation.compiler) || (() => {});\n\n        /** @type {Map<string, Chunk>} */\n        const fileToChunk = new Map();\n        for (const chunk of compilation.chunks) {\n          for (const file of chunk.files) {\n            fileToChunk.set(file, chunk);\n          }\n          for (const file of chunk.auxiliaryFiles) {\n            fileToChunk.set(file, chunk);\n          }\n        }\n\n        /** @type {string[]} */\n        const files = [];\n        for (const file of Object.keys(assets)) {\n          if (matchObject(file)) {\n            files.push(file);\n          }\n        }\n        reportProgress(0.0);\n        /** @type {SourceMapTask[]} */\n        const tasks = [];\n        let fileIndex = 0;\n        asyncLib.each(files, (file, callback) => {\n          const asset = /** @type {Readonly<Asset>} */\n          compilation.getAsset(file);\n          if (asset.info.related && asset.info.related.sourceMap) {\n            fileIndex++;\n            return callback();\n          }\n          const cacheItem = cache.getItemCache(file, cache.mergeEtags(cache.getLazyHashedEtag(asset.source), namespace));\n          cacheItem.get((err, cacheEntry) => {\n            if (err) {\n              return callback(err);\n            }\n            /**\n             * If presented in cache, reassigns assets. Cache assets already have source maps.\n             */\n            if (cacheEntry) {\n              const {\n                assets,\n                assetsInfo\n              } = cacheEntry;\n              for (const cachedFile of Object.keys(assets)) {\n                if (cachedFile === file) {\n                  compilation.updateAsset(cachedFile, assets[cachedFile], assetsInfo[cachedFile]);\n                } else {\n                  compilation.emitAsset(cachedFile, assets[cachedFile], assetsInfo[cachedFile]);\n                }\n                /**\n                 * Add file to chunk, if not presented there\n                 */\n                if (cachedFile !== file) {\n                  const chunk = fileToChunk.get(file);\n                  if (chunk !== undefined) chunk.auxiliaryFiles.add(cachedFile);\n                }\n              }\n              reportProgress(0.5 * ++fileIndex / files.length, file, \"restored cached SourceMap\");\n              return callback();\n            }\n            reportProgress(0.5 * fileIndex / files.length, file, \"generate SourceMap\");\n\n            /** @type {SourceMapTask | undefined} */\n            const task = getTaskForFile(file, asset.source, asset.info, {\n              module: options.module,\n              columns: options.columns\n            }, compilation, cacheItem);\n            if (task) {\n              const modules = task.modules;\n              for (let idx = 0; idx < modules.length; idx++) {\n                const module = modules[idx];\n                if (!moduleToSourceNameMapping.get(module)) {\n                  moduleToSourceNameMapping.set(module, ModuleFilenameHelpers.createFilename(module, {\n                    moduleFilenameTemplate: moduleFilenameTemplate,\n                    namespace: namespace\n                  }, {\n                    requestShortener,\n                    chunkGraph,\n                    hashFunction: compilation.outputOptions.hashFunction\n                  }));\n                }\n              }\n              tasks.push(task);\n            }\n            reportProgress(0.5 * ++fileIndex / files.length, file, \"generated SourceMap\");\n            callback();\n          });\n        }, err => {\n          if (err) {\n            return callback(err);\n          }\n          reportProgress(0.5, \"resolve sources\");\n          /** @type {Set<string>} */\n          const usedNamesSet = new Set(moduleToSourceNameMapping.values());\n          /** @type {Set<string>} */\n          const conflictDetectionSet = new Set();\n\n          /**\n           * all modules in defined order (longest identifier first)\n           * @type {Array<string | Module>}\n           */\n          const allModules = Array.from(moduleToSourceNameMapping.keys()).sort((a, b) => {\n            const ai = typeof a === \"string\" ? a : a.identifier();\n            const bi = typeof b === \"string\" ? b : b.identifier();\n            return ai.length - bi.length;\n          });\n\n          // find modules with conflicting source names\n          for (let idx = 0; idx < allModules.length; idx++) {\n            const module = allModules[idx];\n            let sourceName = /** @type {string} */\n            moduleToSourceNameMapping.get(module);\n            let hasName = conflictDetectionSet.has(sourceName);\n            if (!hasName) {\n              conflictDetectionSet.add(sourceName);\n              continue;\n            }\n\n            // try the fallback name first\n            sourceName = ModuleFilenameHelpers.createFilename(module, {\n              moduleFilenameTemplate: fallbackModuleFilenameTemplate,\n              namespace: namespace\n            }, {\n              requestShortener,\n              chunkGraph,\n              hashFunction: compilation.outputOptions.hashFunction\n            });\n            hasName = usedNamesSet.has(sourceName);\n            if (!hasName) {\n              moduleToSourceNameMapping.set(module, sourceName);\n              usedNamesSet.add(sourceName);\n              continue;\n            }\n\n            // otherwise just append stars until we have a valid name\n            while (hasName) {\n              sourceName += \"*\";\n              hasName = usedNamesSet.has(sourceName);\n            }\n            moduleToSourceNameMapping.set(module, sourceName);\n            usedNamesSet.add(sourceName);\n          }\n          let taskIndex = 0;\n          asyncLib.each(tasks, (task, callback) => {\n            const assets = Object.create(null);\n            const assetsInfo = Object.create(null);\n            const file = task.file;\n            const chunk = fileToChunk.get(file);\n            const sourceMap = task.sourceMap;\n            const source = task.source;\n            const modules = task.modules;\n            reportProgress(0.5 + 0.5 * taskIndex / tasks.length, file, \"attach SourceMap\");\n            const moduleFilenames = modules.map(m => moduleToSourceNameMapping.get(m));\n            sourceMap.sources = moduleFilenames;\n            if (options.noSources) {\n              sourceMap.sourcesContent = undefined;\n            }\n            sourceMap.sourceRoot = options.sourceRoot || \"\";\n            sourceMap.file = file;\n            const usesContentHash = sourceMapFilename && CONTENT_HASH_DETECT_REGEXP.test(sourceMapFilename);\n            resetRegexpState(CONTENT_HASH_DETECT_REGEXP);\n\n            // If SourceMap and asset uses contenthash, avoid a circular dependency by hiding hash in `file`\n            if (usesContentHash && task.assetInfo.contenthash) {\n              const contenthash = task.assetInfo.contenthash;\n              let pattern;\n              if (Array.isArray(contenthash)) {\n                pattern = contenthash.map(quoteMeta).join(\"|\");\n              } else {\n                pattern = quoteMeta(contenthash);\n              }\n              sourceMap.file = sourceMap.file.replace(new RegExp(pattern, \"g\"), m => \"x\".repeat(m.length));\n            }\n\n            /** @type {string | false | (function(PathData, AssetInfo=): string)} */\n            let currentSourceMappingURLComment = sourceMappingURLComment;\n            let cssExtensionDetected = CSS_EXTENSION_DETECT_REGEXP.test(file);\n            resetRegexpState(CSS_EXTENSION_DETECT_REGEXP);\n            if (currentSourceMappingURLComment !== false && typeof currentSourceMappingURLComment !== \"function\" && cssExtensionDetected) {\n              currentSourceMappingURLComment = currentSourceMappingURLComment.replace(URL_FORMATTING_REGEXP, \"\\n/*$1*/\");\n            }\n            const sourceMapString = JSON.stringify(sourceMap);\n            if (sourceMapFilename) {\n              let filename = file;\n              const sourceMapContentHash = usesContentHash && ( /** @type {string} */\n              createHash(compilation.outputOptions.hashFunction).update(sourceMapString).digest(\"hex\"));\n              const pathParams = {\n                chunk,\n                filename: options.fileContext ? relative(outputFs, `/${options.fileContext}`, `/${filename}`) : filename,\n                contentHash: sourceMapContentHash\n              };\n              const {\n                path: sourceMapFile,\n                info: sourceMapInfo\n              } = compilation.getPathWithInfo(sourceMapFilename, pathParams);\n              const sourceMapUrl = options.publicPath ? options.publicPath + sourceMapFile : relative(outputFs, dirname(outputFs, `/${file}`), `/${sourceMapFile}`);\n              /** @type {Source} */\n              let asset = new RawSource(source);\n              if (currentSourceMappingURLComment !== false) {\n                // Add source map url to compilation asset, if currentSourceMappingURLComment is set\n                asset = new ConcatSource(asset, compilation.getPath(currentSourceMappingURLComment, Object.assign({\n                  url: sourceMapUrl\n                }, pathParams)));\n              }\n              const assetInfo = {\n                related: {\n                  sourceMap: sourceMapFile\n                }\n              };\n              assets[file] = asset;\n              assetsInfo[file] = assetInfo;\n              compilation.updateAsset(file, asset, assetInfo);\n              // Add source map file to compilation assets and chunk files\n              const sourceMapAsset = new RawSource(sourceMapString);\n              const sourceMapAssetInfo = {\n                ...sourceMapInfo,\n                development: true\n              };\n              assets[sourceMapFile] = sourceMapAsset;\n              assetsInfo[sourceMapFile] = sourceMapAssetInfo;\n              compilation.emitAsset(sourceMapFile, sourceMapAsset, sourceMapAssetInfo);\n              if (chunk !== undefined) chunk.auxiliaryFiles.add(sourceMapFile);\n            } else {\n              if (currentSourceMappingURLComment === false) {\n                throw new Error(\"SourceMapDevToolPlugin: append can't be false when no filename is provided\");\n              }\n              if (typeof currentSourceMappingURLComment === \"function\") {\n                throw new Error(\"SourceMapDevToolPlugin: append can't be a function when no filename is provided\");\n              }\n              /**\n               * Add source map as data url to asset\n               */\n              const asset = new ConcatSource(new RawSource(source), currentSourceMappingURLComment.replace(MAP_URL_COMMENT_REGEXP, () => sourceMapString).replace(URL_COMMENT_REGEXP, () => `data:application/json;charset=utf-8;base64,${Buffer.from(sourceMapString, \"utf-8\").toString(\"base64\")}`));\n              assets[file] = asset;\n              assetsInfo[file] = undefined;\n              compilation.updateAsset(file, asset);\n            }\n            task.cacheItem.store({\n              assets,\n              assetsInfo\n            }, err => {\n              reportProgress(0.5 + 0.5 * ++taskIndex / tasks.length, task.file, \"attached SourceMap\");\n              if (err) {\n                return callback(err);\n              }\n              callback();\n            });\n          }, err => {\n            reportProgress(1.0);\n            callback(err);\n          });\n        });\n      });\n    });\n  }\n}\nmodule.exports = SourceMapDevToolPlugin;","map":{"version":3,"names":["asyncLib","require","ConcatSource","RawSource","Compilation","ModuleFilenameHelpers","ProgressPlugin","SourceMapDevToolModuleOptionsPlugin","createSchemaValidation","createHash","relative","dirname","makePathsAbsolute","validate","name","baseDataPath","METACHARACTERS_REGEXP","CONTENT_HASH_DETECT_REGEXP","CSS_AND_JS_MODULE_EXTENSIONS_REGEXP","CSS_EXTENSION_DETECT_REGEXP","MAP_URL_COMMENT_REGEXP","URL_COMMENT_REGEXP","URL_FORMATTING_REGEXP","resetRegexpState","regexp","lastIndex","quoteMeta","str","replace","getTaskForFile","file","asset","assetInfo","options","compilation","cacheItem","source","sourceMap","sourceAndMap","map","context","root","compiler","cachedAbsolutify","bindContextCache","modules","sources","startsWith","slice","module","findModule","SourceMapDevToolPlugin","constructor","sourceMapFilename","filename","sourceMappingURLComment","append","moduleFilenameTemplate","fallbackModuleFilenameTemplate","namespace","apply","outputFs","outputFileSystem","requestShortener","test","matchObject","bind","undefined","hooks","tap","processAssets","tapAsync","stage","PROCESS_ASSETS_STAGE_DEV_TOOLING","additionalAssets","assets","callback","chunkGraph","cache","getCache","moduleToSourceNameMapping","Map","reportProgress","getReporter","fileToChunk","chunk","chunks","files","set","auxiliaryFiles","Object","keys","push","tasks","fileIndex","each","getAsset","info","related","getItemCache","mergeEtags","getLazyHashedEtag","get","err","cacheEntry","assetsInfo","cachedFile","updateAsset","emitAsset","add","length","task","columns","idx","createFilename","hashFunction","outputOptions","usedNamesSet","Set","values","conflictDetectionSet","allModules","Array","from","sort","a","b","ai","identifier","bi","sourceName","hasName","has","taskIndex","create","moduleFilenames","m","noSources","sourcesContent","sourceRoot","usesContentHash","contenthash","pattern","isArray","join","RegExp","repeat","currentSourceMappingURLComment","cssExtensionDetected","sourceMapString","JSON","stringify","sourceMapContentHash","update","digest","pathParams","fileContext","contentHash","path","sourceMapFile","sourceMapInfo","getPathWithInfo","sourceMapUrl","publicPath","getPath","assign","url","sourceMapAsset","sourceMapAssetInfo","development","Error","Buffer","toString","store","exports"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/SourceMapDevToolPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst { ConcatSource, RawSource } = require(\"webpack-sources\");\nconst Compilation = require(\"./Compilation\");\nconst ModuleFilenameHelpers = require(\"./ModuleFilenameHelpers\");\nconst ProgressPlugin = require(\"./ProgressPlugin\");\nconst SourceMapDevToolModuleOptionsPlugin = require(\"./SourceMapDevToolModuleOptionsPlugin\");\nconst createSchemaValidation = require(\"./util/create-schema-validation\");\nconst createHash = require(\"./util/createHash\");\nconst { relative, dirname } = require(\"./util/fs\");\nconst { makePathsAbsolute } = require(\"./util/identifier\");\n\n/** @typedef {import(\"webpack-sources\").MapOptions} MapOptions */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../declarations/plugins/SourceMapDevToolPlugin\").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */\n/** @typedef {import(\"./Cache\").Etag} Etag */\n/** @typedef {import(\"./CacheFacade\").ItemCacheFacade} ItemCacheFacade */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Compilation\").Asset} Asset */\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"./Compilation\").PathData} PathData */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./NormalModule\").SourceMap} SourceMap */\n/** @typedef {import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n\nconst validate = createSchemaValidation(\n\trequire(\"../schemas/plugins/SourceMapDevToolPlugin.check.js\"),\n\t() => require(\"../schemas/plugins/SourceMapDevToolPlugin.json\"),\n\t{\n\t\tname: \"SourceMap DevTool Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n/**\n * @typedef {object} SourceMapTask\n * @property {Source} asset\n * @property {AssetInfo} assetInfo\n * @property {(string | Module)[]} modules\n * @property {string} source\n * @property {string} file\n * @property {SourceMap} sourceMap\n * @property {ItemCacheFacade} cacheItem cache item\n */\n\nconst METACHARACTERS_REGEXP = /[-[\\]\\\\/{}()*+?.^$|]/g;\nconst CONTENT_HASH_DETECT_REGEXP = /\\[contenthash(:\\w+)?\\]/;\nconst CSS_AND_JS_MODULE_EXTENSIONS_REGEXP = /\\.((c|m)?js|css)($|\\?)/i;\nconst CSS_EXTENSION_DETECT_REGEXP = /\\.css($|\\?)/i;\nconst MAP_URL_COMMENT_REGEXP = /\\[map\\]/g;\nconst URL_COMMENT_REGEXP = /\\[url\\]/g;\nconst URL_FORMATTING_REGEXP = /^\\n\\/\\/(.*)$/;\n\n/**\n * Reset's .lastIndex of stateful Regular Expressions\n * For when `test` or `exec` is called on them\n * @param {RegExp} regexp Stateful Regular Expression to be reset\n * @returns {void}\n *\n */\nconst resetRegexpState = regexp => {\n\tregexp.lastIndex = -1;\n};\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nconst quoteMeta = str => {\n\treturn str.replace(METACHARACTERS_REGEXP, \"\\\\$&\");\n};\n\n/**\n * Creating {@link SourceMapTask} for given file\n * @param {string} file current compiled file\n * @param {Source} asset the asset\n * @param {AssetInfo} assetInfo the asset info\n * @param {MapOptions} options source map options\n * @param {Compilation} compilation compilation instance\n * @param {ItemCacheFacade} cacheItem cache item\n * @returns {SourceMapTask | undefined} created task instance or `undefined`\n */\nconst getTaskForFile = (\n\tfile,\n\tasset,\n\tassetInfo,\n\toptions,\n\tcompilation,\n\tcacheItem\n) => {\n\tlet source;\n\t/** @type {SourceMap} */\n\tlet sourceMap;\n\t/**\n\t * Check if asset can build source map\n\t */\n\tif (asset.sourceAndMap) {\n\t\tconst sourceAndMap = asset.sourceAndMap(options);\n\t\tsourceMap = /** @type {SourceMap} */ (sourceAndMap.map);\n\t\tsource = sourceAndMap.source;\n\t} else {\n\t\tsourceMap = /** @type {SourceMap} */ (asset.map(options));\n\t\tsource = asset.source();\n\t}\n\tif (!sourceMap || typeof source !== \"string\") return;\n\tconst context = compilation.options.context;\n\tconst root = compilation.compiler.root;\n\tconst cachedAbsolutify = makePathsAbsolute.bindContextCache(context, root);\n\tconst modules = sourceMap.sources.map(source => {\n\t\tif (!source.startsWith(\"webpack://\")) return source;\n\t\tsource = cachedAbsolutify(source.slice(10));\n\t\tconst module = compilation.findModule(source);\n\t\treturn module || source;\n\t});\n\n\treturn {\n\t\tfile,\n\t\tasset,\n\t\tsource,\n\t\tassetInfo,\n\t\tsourceMap,\n\t\tmodules,\n\t\tcacheItem\n\t};\n};\n\nclass SourceMapDevToolPlugin {\n\t/**\n\t * @param {SourceMapDevToolPluginOptions} [options] options object\n\t * @throws {Error} throws error, if got more than 1 arguments\n\t */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\n\t\t/** @type {string | false} */\n\t\tthis.sourceMapFilename = options.filename;\n\t\t/** @type {string | false | (function(PathData, AssetInfo=): string)}} */\n\t\tthis.sourceMappingURLComment =\n\t\t\toptions.append === false\n\t\t\t\t? false\n\t\t\t\t: options.append || \"\\n//# source\" + \"MappingURL=[url]\";\n\t\t/** @type {string | Function} */\n\t\tthis.moduleFilenameTemplate =\n\t\t\toptions.moduleFilenameTemplate || \"webpack://[namespace]/[resourcePath]\";\n\t\t/** @type {string | Function} */\n\t\tthis.fallbackModuleFilenameTemplate =\n\t\t\toptions.fallbackModuleFilenameTemplate ||\n\t\t\t\"webpack://[namespace]/[resourcePath]?[hash]\";\n\t\t/** @type {string} */\n\t\tthis.namespace = options.namespace || \"\";\n\t\t/** @type {SourceMapDevToolPluginOptions} */\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst outputFs = /** @type {OutputFileSystem} */ (\n\t\t\tcompiler.outputFileSystem\n\t\t);\n\t\tconst sourceMapFilename = this.sourceMapFilename;\n\t\tconst sourceMappingURLComment = this.sourceMappingURLComment;\n\t\tconst moduleFilenameTemplate = this.moduleFilenameTemplate;\n\t\tconst namespace = this.namespace;\n\t\tconst fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;\n\t\tconst requestShortener = compiler.requestShortener;\n\t\tconst options = this.options;\n\t\toptions.test = options.test || CSS_AND_JS_MODULE_EXTENSIONS_REGEXP;\n\n\t\tconst matchObject = ModuleFilenameHelpers.matchObject.bind(\n\t\t\tundefined,\n\t\t\toptions\n\t\t);\n\n\t\tcompiler.hooks.compilation.tap(\"SourceMapDevToolPlugin\", compilation => {\n\t\t\tnew SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);\n\n\t\t\tcompilation.hooks.processAssets.tapAsync(\n\t\t\t\t{\n\t\t\t\t\tname: \"SourceMapDevToolPlugin\",\n\t\t\t\t\tstage: Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING,\n\t\t\t\t\tadditionalAssets: true\n\t\t\t\t},\n\t\t\t\t(assets, callback) => {\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\tconst cache = compilation.getCache(\"SourceMapDevToolPlugin\");\n\t\t\t\t\t/** @type {Map<string | Module, string>} */\n\t\t\t\t\tconst moduleToSourceNameMapping = new Map();\n\t\t\t\t\t/**\n\t\t\t\t\t * @type {Function}\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst reportProgress =\n\t\t\t\t\t\tProgressPlugin.getReporter(compilation.compiler) || (() => {});\n\n\t\t\t\t\t/** @type {Map<string, Chunk>} */\n\t\t\t\t\tconst fileToChunk = new Map();\n\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\tfor (const file of chunk.files) {\n\t\t\t\t\t\t\tfileToChunk.set(file, chunk);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const file of chunk.auxiliaryFiles) {\n\t\t\t\t\t\t\tfileToChunk.set(file, chunk);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/** @type {string[]} */\n\t\t\t\t\tconst files = [];\n\t\t\t\t\tfor (const file of Object.keys(assets)) {\n\t\t\t\t\t\tif (matchObject(file)) {\n\t\t\t\t\t\t\tfiles.push(file);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treportProgress(0.0);\n\t\t\t\t\t/** @type {SourceMapTask[]} */\n\t\t\t\t\tconst tasks = [];\n\t\t\t\t\tlet fileIndex = 0;\n\n\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\tfiles,\n\t\t\t\t\t\t(file, callback) => {\n\t\t\t\t\t\t\tconst asset =\n\t\t\t\t\t\t\t\t/** @type {Readonly<Asset>} */\n\t\t\t\t\t\t\t\t(compilation.getAsset(file));\n\t\t\t\t\t\t\tif (asset.info.related && asset.info.related.sourceMap) {\n\t\t\t\t\t\t\t\tfileIndex++;\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst cacheItem = cache.getItemCache(\n\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\tcache.mergeEtags(\n\t\t\t\t\t\t\t\t\tcache.getLazyHashedEtag(asset.source),\n\t\t\t\t\t\t\t\t\tnamespace\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tcacheItem.get((err, cacheEntry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * If presented in cache, reassigns assets. Cache assets already have source maps.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tif (cacheEntry) {\n\t\t\t\t\t\t\t\t\tconst { assets, assetsInfo } = cacheEntry;\n\t\t\t\t\t\t\t\t\tfor (const cachedFile of Object.keys(assets)) {\n\t\t\t\t\t\t\t\t\t\tif (cachedFile === file) {\n\t\t\t\t\t\t\t\t\t\t\tcompilation.updateAsset(\n\t\t\t\t\t\t\t\t\t\t\t\tcachedFile,\n\t\t\t\t\t\t\t\t\t\t\t\tassets[cachedFile],\n\t\t\t\t\t\t\t\t\t\t\t\tassetsInfo[cachedFile]\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tcompilation.emitAsset(\n\t\t\t\t\t\t\t\t\t\t\t\tcachedFile,\n\t\t\t\t\t\t\t\t\t\t\t\tassets[cachedFile],\n\t\t\t\t\t\t\t\t\t\t\t\tassetsInfo[cachedFile]\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t\t * Add file to chunk, if not presented there\n\t\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\t\tif (cachedFile !== file) {\n\t\t\t\t\t\t\t\t\t\t\tconst chunk = fileToChunk.get(file);\n\t\t\t\t\t\t\t\t\t\t\tif (chunk !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\tchunk.auxiliaryFiles.add(cachedFile);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t(0.5 * ++fileIndex) / files.length,\n\t\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t\t\"restored cached SourceMap\"\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t(0.5 * fileIndex) / files.length,\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t\"generate SourceMap\"\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t/** @type {SourceMapTask | undefined} */\n\t\t\t\t\t\t\t\tconst task = getTaskForFile(\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\tasset.source,\n\t\t\t\t\t\t\t\t\tasset.info,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmodule: options.module,\n\t\t\t\t\t\t\t\t\t\tcolumns: options.columns\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\t\t\tcacheItem\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif (task) {\n\t\t\t\t\t\t\t\t\tconst modules = task.modules;\n\n\t\t\t\t\t\t\t\t\tfor (let idx = 0; idx < modules.length; idx++) {\n\t\t\t\t\t\t\t\t\t\tconst module = modules[idx];\n\t\t\t\t\t\t\t\t\t\tif (!moduleToSourceNameMapping.get(module)) {\n\t\t\t\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(\n\t\t\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\t\t\tModuleFilenameHelpers.createFilename(\n\t\t\t\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleFilenameTemplate: moduleFilenameTemplate,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnamespace: namespace\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trequestShortener,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thashFunction: compilation.outputOptions.hashFunction\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttasks.push(task);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t(0.5 * ++fileIndex) / files.length,\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t\"generated SourceMap\"\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treportProgress(0.5, \"resolve sources\");\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\tconst usedNamesSet = new Set(moduleToSourceNameMapping.values());\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\tconst conflictDetectionSet = new Set();\n\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * all modules in defined order (longest identifier first)\n\t\t\t\t\t\t\t * @type {Array<string | Module>}\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst allModules = Array.from(\n\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.keys()\n\t\t\t\t\t\t\t).sort((a, b) => {\n\t\t\t\t\t\t\t\tconst ai = typeof a === \"string\" ? a : a.identifier();\n\t\t\t\t\t\t\t\tconst bi = typeof b === \"string\" ? b : b.identifier();\n\t\t\t\t\t\t\t\treturn ai.length - bi.length;\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// find modules with conflicting source names\n\t\t\t\t\t\t\tfor (let idx = 0; idx < allModules.length; idx++) {\n\t\t\t\t\t\t\t\tconst module = allModules[idx];\n\t\t\t\t\t\t\t\tlet sourceName =\n\t\t\t\t\t\t\t\t\t/** @type {string} */\n\t\t\t\t\t\t\t\t\t(moduleToSourceNameMapping.get(module));\n\t\t\t\t\t\t\t\tlet hasName = conflictDetectionSet.has(sourceName);\n\t\t\t\t\t\t\t\tif (!hasName) {\n\t\t\t\t\t\t\t\t\tconflictDetectionSet.add(sourceName);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// try the fallback name first\n\t\t\t\t\t\t\t\tsourceName = ModuleFilenameHelpers.createFilename(\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmoduleFilenameTemplate: fallbackModuleFilenameTemplate,\n\t\t\t\t\t\t\t\t\t\tnamespace: namespace\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\trequestShortener,\n\t\t\t\t\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\t\t\t\t\thashFunction: compilation.outputOptions.hashFunction\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\thasName = usedNamesSet.has(sourceName);\n\t\t\t\t\t\t\t\tif (!hasName) {\n\t\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(module, sourceName);\n\t\t\t\t\t\t\t\t\tusedNamesSet.add(sourceName);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// otherwise just append stars until we have a valid name\n\t\t\t\t\t\t\t\twhile (hasName) {\n\t\t\t\t\t\t\t\t\tsourceName += \"*\";\n\t\t\t\t\t\t\t\t\thasName = usedNamesSet.has(sourceName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(module, sourceName);\n\t\t\t\t\t\t\t\tusedNamesSet.add(sourceName);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet taskIndex = 0;\n\n\t\t\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\t\t\ttasks,\n\t\t\t\t\t\t\t\t(task, callback) => {\n\t\t\t\t\t\t\t\t\tconst assets = Object.create(null);\n\t\t\t\t\t\t\t\t\tconst assetsInfo = Object.create(null);\n\t\t\t\t\t\t\t\t\tconst file = task.file;\n\t\t\t\t\t\t\t\t\tconst chunk = fileToChunk.get(file);\n\t\t\t\t\t\t\t\t\tconst sourceMap = task.sourceMap;\n\t\t\t\t\t\t\t\t\tconst source = task.source;\n\t\t\t\t\t\t\t\t\tconst modules = task.modules;\n\n\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t0.5 + (0.5 * taskIndex) / tasks.length,\n\t\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t\t\"attach SourceMap\"\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tconst moduleFilenames = modules.map(m =>\n\t\t\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.get(m)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tsourceMap.sources = moduleFilenames;\n\t\t\t\t\t\t\t\t\tif (options.noSources) {\n\t\t\t\t\t\t\t\t\t\tsourceMap.sourcesContent = undefined;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tsourceMap.sourceRoot = options.sourceRoot || \"\";\n\t\t\t\t\t\t\t\t\tsourceMap.file = file;\n\t\t\t\t\t\t\t\t\tconst usesContentHash =\n\t\t\t\t\t\t\t\t\t\tsourceMapFilename &&\n\t\t\t\t\t\t\t\t\t\tCONTENT_HASH_DETECT_REGEXP.test(sourceMapFilename);\n\n\t\t\t\t\t\t\t\t\tresetRegexpState(CONTENT_HASH_DETECT_REGEXP);\n\n\t\t\t\t\t\t\t\t\t// If SourceMap and asset uses contenthash, avoid a circular dependency by hiding hash in `file`\n\t\t\t\t\t\t\t\t\tif (usesContentHash && task.assetInfo.contenthash) {\n\t\t\t\t\t\t\t\t\t\tconst contenthash = task.assetInfo.contenthash;\n\t\t\t\t\t\t\t\t\t\tlet pattern;\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(contenthash)) {\n\t\t\t\t\t\t\t\t\t\t\tpattern = contenthash.map(quoteMeta).join(\"|\");\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tpattern = quoteMeta(contenthash);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tsourceMap.file = sourceMap.file.replace(\n\t\t\t\t\t\t\t\t\t\t\tnew RegExp(pattern, \"g\"),\n\t\t\t\t\t\t\t\t\t\t\tm => \"x\".repeat(m.length)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t/** @type {string | false | (function(PathData, AssetInfo=): string)} */\n\t\t\t\t\t\t\t\t\tlet currentSourceMappingURLComment = sourceMappingURLComment;\n\t\t\t\t\t\t\t\t\tlet cssExtensionDetected =\n\t\t\t\t\t\t\t\t\t\tCSS_EXTENSION_DETECT_REGEXP.test(file);\n\t\t\t\t\t\t\t\t\tresetRegexpState(CSS_EXTENSION_DETECT_REGEXP);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment !== false &&\n\t\t\t\t\t\t\t\t\t\ttypeof currentSourceMappingURLComment !== \"function\" &&\n\t\t\t\t\t\t\t\t\t\tcssExtensionDetected\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment =\n\t\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment.replace(\n\t\t\t\t\t\t\t\t\t\t\t\tURL_FORMATTING_REGEXP,\n\t\t\t\t\t\t\t\t\t\t\t\t\"\\n/*$1*/\"\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst sourceMapString = JSON.stringify(sourceMap);\n\t\t\t\t\t\t\t\t\tif (sourceMapFilename) {\n\t\t\t\t\t\t\t\t\t\tlet filename = file;\n\t\t\t\t\t\t\t\t\t\tconst sourceMapContentHash =\n\t\t\t\t\t\t\t\t\t\t\tusesContentHash &&\n\t\t\t\t\t\t\t\t\t\t\t/** @type {string} */ (\n\t\t\t\t\t\t\t\t\t\t\t\tcreateHash(compilation.outputOptions.hashFunction)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.update(sourceMapString)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.digest(\"hex\")\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tconst pathParams = {\n\t\t\t\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\t\t\t\tfilename: options.fileContext\n\t\t\t\t\t\t\t\t\t\t\t\t? relative(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\toutputFs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`/${options.fileContext}`,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`/${filename}`\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t: filename,\n\t\t\t\t\t\t\t\t\t\t\tcontentHash: sourceMapContentHash\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tconst { path: sourceMapFile, info: sourceMapInfo } =\n\t\t\t\t\t\t\t\t\t\t\tcompilation.getPathWithInfo(\n\t\t\t\t\t\t\t\t\t\t\t\tsourceMapFilename,\n\t\t\t\t\t\t\t\t\t\t\t\tpathParams\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tconst sourceMapUrl = options.publicPath\n\t\t\t\t\t\t\t\t\t\t\t? options.publicPath + sourceMapFile\n\t\t\t\t\t\t\t\t\t\t\t: relative(\n\t\t\t\t\t\t\t\t\t\t\t\t\toutputFs,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdirname(outputFs, `/${file}`),\n\t\t\t\t\t\t\t\t\t\t\t\t\t`/${sourceMapFile}`\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t/** @type {Source} */\n\t\t\t\t\t\t\t\t\t\tlet asset = new RawSource(source);\n\t\t\t\t\t\t\t\t\t\tif (currentSourceMappingURLComment !== false) {\n\t\t\t\t\t\t\t\t\t\t\t// Add source map url to compilation asset, if currentSourceMappingURLComment is set\n\t\t\t\t\t\t\t\t\t\t\tasset = new ConcatSource(\n\t\t\t\t\t\t\t\t\t\t\t\tasset,\n\t\t\t\t\t\t\t\t\t\t\t\tcompilation.getPath(\n\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment,\n\t\t\t\t\t\t\t\t\t\t\t\t\tObject.assign({ url: sourceMapUrl }, pathParams)\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst assetInfo = {\n\t\t\t\t\t\t\t\t\t\t\trelated: { sourceMap: sourceMapFile }\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tassets[file] = asset;\n\t\t\t\t\t\t\t\t\t\tassetsInfo[file] = assetInfo;\n\t\t\t\t\t\t\t\t\t\tcompilation.updateAsset(file, asset, assetInfo);\n\t\t\t\t\t\t\t\t\t\t// Add source map file to compilation assets and chunk files\n\t\t\t\t\t\t\t\t\t\tconst sourceMapAsset = new RawSource(sourceMapString);\n\t\t\t\t\t\t\t\t\t\tconst sourceMapAssetInfo = {\n\t\t\t\t\t\t\t\t\t\t\t...sourceMapInfo,\n\t\t\t\t\t\t\t\t\t\t\tdevelopment: true\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tassets[sourceMapFile] = sourceMapAsset;\n\t\t\t\t\t\t\t\t\t\tassetsInfo[sourceMapFile] = sourceMapAssetInfo;\n\t\t\t\t\t\t\t\t\t\tcompilation.emitAsset(\n\t\t\t\t\t\t\t\t\t\t\tsourceMapFile,\n\t\t\t\t\t\t\t\t\t\t\tsourceMapAsset,\n\t\t\t\t\t\t\t\t\t\t\tsourceMapAssetInfo\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tif (chunk !== undefined)\n\t\t\t\t\t\t\t\t\t\t\tchunk.auxiliaryFiles.add(sourceMapFile);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif (currentSourceMappingURLComment === false) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\"SourceMapDevToolPlugin: append can't be false when no filename is provided\"\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (typeof currentSourceMappingURLComment === \"function\") {\n\t\t\t\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\"SourceMapDevToolPlugin: append can't be a function when no filename is provided\"\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t\t * Add source map as data url to asset\n\t\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\t\tconst asset = new ConcatSource(\n\t\t\t\t\t\t\t\t\t\t\tnew RawSource(source),\n\t\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment\n\t\t\t\t\t\t\t\t\t\t\t\t.replace(MAP_URL_COMMENT_REGEXP, () => sourceMapString)\n\t\t\t\t\t\t\t\t\t\t\t\t.replace(\n\t\t\t\t\t\t\t\t\t\t\t\t\tURL_COMMENT_REGEXP,\n\t\t\t\t\t\t\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`data:application/json;charset=utf-8;base64,${Buffer.from(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsourceMapString,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"utf-8\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t).toString(\"base64\")}`\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tassets[file] = asset;\n\t\t\t\t\t\t\t\t\t\tassetsInfo[file] = undefined;\n\t\t\t\t\t\t\t\t\t\tcompilation.updateAsset(file, asset);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttask.cacheItem.store({ assets, assetsInfo }, err => {\n\t\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t\t0.5 + (0.5 * ++taskIndex) / tasks.length,\n\t\t\t\t\t\t\t\t\t\t\ttask.file,\n\t\t\t\t\t\t\t\t\t\t\t\"attached SourceMap\"\n\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\treportProgress(1.0);\n\t\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = SourceMapDevToolPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
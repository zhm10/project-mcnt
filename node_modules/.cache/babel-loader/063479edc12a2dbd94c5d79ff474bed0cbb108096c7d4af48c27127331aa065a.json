{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst EnvironmentNotSupportAsyncWarning = require(\"../EnvironmentNotSupportAsyncWarning\");\nconst {\n  JAVASCRIPT_MODULE_TYPE_ESM\n} = require(\"../ModuleTypeConstants\");\nconst DynamicExports = require(\"./DynamicExports\");\nconst HarmonyCompatibilityDependency = require(\"./HarmonyCompatibilityDependency\");\nconst HarmonyExports = require(\"./HarmonyExports\");\n\n/** @typedef {import(\"../Module\").BuildMeta} BuildMeta */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"./HarmonyModulesPlugin\").HarmonyModulesPluginOptions} HarmonyModulesPluginOptions */\n\nmodule.exports = class HarmonyDetectionParserPlugin {\n  /**\n   * @param {HarmonyModulesPluginOptions} options options\n   */\n  constructor(options) {\n    const {\n      topLevelAwait = false\n    } = options || {};\n    this.topLevelAwait = topLevelAwait;\n  }\n\n  /**\n   * @param {JavascriptParser} parser the parser\n   * @returns {void}\n   */\n  apply(parser) {\n    parser.hooks.program.tap(\"HarmonyDetectionParserPlugin\", ast => {\n      const isStrictHarmony = parser.state.module.type === JAVASCRIPT_MODULE_TYPE_ESM;\n      const isHarmony = isStrictHarmony || ast.body.some(statement => statement.type === \"ImportDeclaration\" || statement.type === \"ExportDefaultDeclaration\" || statement.type === \"ExportNamedDeclaration\" || statement.type === \"ExportAllDeclaration\");\n      if (isHarmony) {\n        const module = parser.state.module;\n        const compatDep = new HarmonyCompatibilityDependency();\n        compatDep.loc = {\n          start: {\n            line: -1,\n            column: 0\n          },\n          end: {\n            line: -1,\n            column: 0\n          },\n          index: -3\n        };\n        module.addPresentationalDependency(compatDep);\n        DynamicExports.bailout(parser.state);\n        HarmonyExports.enable(parser.state, isStrictHarmony);\n        parser.scope.isStrict = true;\n      }\n    });\n    parser.hooks.topLevelAwait.tap(\"HarmonyDetectionParserPlugin\", () => {\n      const module = parser.state.module;\n      if (!this.topLevelAwait) {\n        throw new Error(\"The top-level-await experiment is not enabled (set experiments.topLevelAwait: true to enable it)\");\n      }\n      if (!HarmonyExports.isEnabled(parser.state)) {\n        throw new Error(\"Top-level-await is only supported in EcmaScript Modules\");\n      }\n      /** @type {BuildMeta} */\n      module.buildMeta.async = true;\n      EnvironmentNotSupportAsyncWarning.check(module, parser.state.compilation.runtimeTemplate, \"topLevelAwait\");\n    });\n\n    /**\n     * @returns {boolean | undefined} true if in harmony\n     */\n    const skipInHarmony = () => {\n      if (HarmonyExports.isEnabled(parser.state)) {\n        return true;\n      }\n    };\n\n    /**\n     * @returns {null | undefined} null if in harmony\n     */\n    const nullInHarmony = () => {\n      if (HarmonyExports.isEnabled(parser.state)) {\n        return null;\n      }\n    };\n    const nonHarmonyIdentifiers = [\"define\", \"exports\"];\n    for (const identifier of nonHarmonyIdentifiers) {\n      parser.hooks.evaluateTypeof.for(identifier).tap(\"HarmonyDetectionParserPlugin\", nullInHarmony);\n      parser.hooks.typeof.for(identifier).tap(\"HarmonyDetectionParserPlugin\", skipInHarmony);\n      parser.hooks.evaluate.for(identifier).tap(\"HarmonyDetectionParserPlugin\", nullInHarmony);\n      parser.hooks.expression.for(identifier).tap(\"HarmonyDetectionParserPlugin\", skipInHarmony);\n      parser.hooks.call.for(identifier).tap(\"HarmonyDetectionParserPlugin\", skipInHarmony);\n    }\n  }\n};","map":{"version":3,"names":["EnvironmentNotSupportAsyncWarning","require","JAVASCRIPT_MODULE_TYPE_ESM","DynamicExports","HarmonyCompatibilityDependency","HarmonyExports","module","exports","HarmonyDetectionParserPlugin","constructor","options","topLevelAwait","apply","parser","hooks","program","tap","ast","isStrictHarmony","state","type","isHarmony","body","some","statement","compatDep","loc","start","line","column","end","index","addPresentationalDependency","bailout","enable","scope","isStrict","Error","isEnabled","buildMeta","async","check","compilation","runtimeTemplate","skipInHarmony","nullInHarmony","nonHarmonyIdentifiers","identifier","evaluateTypeof","for","typeof","evaluate","expression","call"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/dependencies/HarmonyDetectionParserPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst EnvironmentNotSupportAsyncWarning = require(\"../EnvironmentNotSupportAsyncWarning\");\nconst { JAVASCRIPT_MODULE_TYPE_ESM } = require(\"../ModuleTypeConstants\");\nconst DynamicExports = require(\"./DynamicExports\");\nconst HarmonyCompatibilityDependency = require(\"./HarmonyCompatibilityDependency\");\nconst HarmonyExports = require(\"./HarmonyExports\");\n\n/** @typedef {import(\"../Module\").BuildMeta} BuildMeta */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"./HarmonyModulesPlugin\").HarmonyModulesPluginOptions} HarmonyModulesPluginOptions */\n\nmodule.exports = class HarmonyDetectionParserPlugin {\n\t/**\n\t * @param {HarmonyModulesPluginOptions} options options\n\t */\n\tconstructor(options) {\n\t\tconst { topLevelAwait = false } = options || {};\n\t\tthis.topLevelAwait = topLevelAwait;\n\t}\n\n\t/**\n\t * @param {JavascriptParser} parser the parser\n\t * @returns {void}\n\t */\n\tapply(parser) {\n\t\tparser.hooks.program.tap(\"HarmonyDetectionParserPlugin\", ast => {\n\t\t\tconst isStrictHarmony =\n\t\t\t\tparser.state.module.type === JAVASCRIPT_MODULE_TYPE_ESM;\n\t\t\tconst isHarmony =\n\t\t\t\tisStrictHarmony ||\n\t\t\t\tast.body.some(\n\t\t\t\t\tstatement =>\n\t\t\t\t\t\tstatement.type === \"ImportDeclaration\" ||\n\t\t\t\t\t\tstatement.type === \"ExportDefaultDeclaration\" ||\n\t\t\t\t\t\tstatement.type === \"ExportNamedDeclaration\" ||\n\t\t\t\t\t\tstatement.type === \"ExportAllDeclaration\"\n\t\t\t\t);\n\t\t\tif (isHarmony) {\n\t\t\t\tconst module = parser.state.module;\n\t\t\t\tconst compatDep = new HarmonyCompatibilityDependency();\n\t\t\t\tcompatDep.loc = {\n\t\t\t\t\tstart: {\n\t\t\t\t\t\tline: -1,\n\t\t\t\t\t\tcolumn: 0\n\t\t\t\t\t},\n\t\t\t\t\tend: {\n\t\t\t\t\t\tline: -1,\n\t\t\t\t\t\tcolumn: 0\n\t\t\t\t\t},\n\t\t\t\t\tindex: -3\n\t\t\t\t};\n\t\t\t\tmodule.addPresentationalDependency(compatDep);\n\t\t\t\tDynamicExports.bailout(parser.state);\n\t\t\t\tHarmonyExports.enable(parser.state, isStrictHarmony);\n\t\t\t\tparser.scope.isStrict = true;\n\t\t\t}\n\t\t});\n\n\t\tparser.hooks.topLevelAwait.tap(\"HarmonyDetectionParserPlugin\", () => {\n\t\t\tconst module = parser.state.module;\n\t\t\tif (!this.topLevelAwait) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"The top-level-await experiment is not enabled (set experiments.topLevelAwait: true to enable it)\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (!HarmonyExports.isEnabled(parser.state)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Top-level-await is only supported in EcmaScript Modules\"\n\t\t\t\t);\n\t\t\t}\n\t\t\t/** @type {BuildMeta} */\n\t\t\t(module.buildMeta).async = true;\n\t\t\tEnvironmentNotSupportAsyncWarning.check(\n\t\t\t\tmodule,\n\t\t\t\tparser.state.compilation.runtimeTemplate,\n\t\t\t\t\"topLevelAwait\"\n\t\t\t);\n\t\t});\n\n\t\t/**\n\t\t * @returns {boolean | undefined} true if in harmony\n\t\t */\n\t\tconst skipInHarmony = () => {\n\t\t\tif (HarmonyExports.isEnabled(parser.state)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * @returns {null | undefined} null if in harmony\n\t\t */\n\t\tconst nullInHarmony = () => {\n\t\t\tif (HarmonyExports.isEnabled(parser.state)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\n\t\tconst nonHarmonyIdentifiers = [\"define\", \"exports\"];\n\t\tfor (const identifier of nonHarmonyIdentifiers) {\n\t\t\tparser.hooks.evaluateTypeof\n\t\t\t\t.for(identifier)\n\t\t\t\t.tap(\"HarmonyDetectionParserPlugin\", nullInHarmony);\n\t\t\tparser.hooks.typeof\n\t\t\t\t.for(identifier)\n\t\t\t\t.tap(\"HarmonyDetectionParserPlugin\", skipInHarmony);\n\t\t\tparser.hooks.evaluate\n\t\t\t\t.for(identifier)\n\t\t\t\t.tap(\"HarmonyDetectionParserPlugin\", nullInHarmony);\n\t\t\tparser.hooks.expression\n\t\t\t\t.for(identifier)\n\t\t\t\t.tap(\"HarmonyDetectionParserPlugin\", skipInHarmony);\n\t\t\tparser.hooks.call\n\t\t\t\t.for(identifier)\n\t\t\t\t.tap(\"HarmonyDetectionParserPlugin\", skipInHarmony);\n\t\t}\n\t}\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,iCAAiC,GAAGC,OAAO,CAAC,sCAAsC,CAAC;AACzF,MAAM;EAAEC;AAA2B,CAAC,GAAGD,OAAO,CAAC,wBAAwB,CAAC;AACxE,MAAME,cAAc,GAAGF,OAAO,CAAC,kBAAkB,CAAC;AAClD,MAAMG,8BAA8B,GAAGH,OAAO,CAAC,kCAAkC,CAAC;AAClF,MAAMI,cAAc,GAAGJ,OAAO,CAAC,kBAAkB,CAAC;;AAElD;AACA;AACA;;AAEAK,MAAM,CAACC,OAAO,GAAG,MAAMC,4BAA4B,CAAC;EACnD;AACD;AACA;EACCC,WAAWA,CAACC,OAAO,EAAE;IACpB,MAAM;MAAEC,aAAa,GAAG;IAAM,CAAC,GAAGD,OAAO,IAAI,CAAC,CAAC;IAC/C,IAAI,CAACC,aAAa,GAAGA,aAAa;EACnC;;EAEA;AACD;AACA;AACA;EACCC,KAAKA,CAACC,MAAM,EAAE;IACbA,MAAM,CAACC,KAAK,CAACC,OAAO,CAACC,GAAG,CAAC,8BAA8B,EAAEC,GAAG,IAAI;MAC/D,MAAMC,eAAe,GACpBL,MAAM,CAACM,KAAK,CAACb,MAAM,CAACc,IAAI,KAAKlB,0BAA0B;MACxD,MAAMmB,SAAS,GACdH,eAAe,IACfD,GAAG,CAACK,IAAI,CAACC,IAAI,CACZC,SAAS,IACRA,SAAS,CAACJ,IAAI,KAAK,mBAAmB,IACtCI,SAAS,CAACJ,IAAI,KAAK,0BAA0B,IAC7CI,SAAS,CAACJ,IAAI,KAAK,wBAAwB,IAC3CI,SAAS,CAACJ,IAAI,KAAK,sBACrB,CAAC;MACF,IAAIC,SAAS,EAAE;QACd,MAAMf,MAAM,GAAGO,MAAM,CAACM,KAAK,CAACb,MAAM;QAClC,MAAMmB,SAAS,GAAG,IAAIrB,8BAA8B,CAAC,CAAC;QACtDqB,SAAS,CAACC,GAAG,GAAG;UACfC,KAAK,EAAE;YACNC,IAAI,EAAE,CAAC,CAAC;YACRC,MAAM,EAAE;UACT,CAAC;UACDC,GAAG,EAAE;YACJF,IAAI,EAAE,CAAC,CAAC;YACRC,MAAM,EAAE;UACT,CAAC;UACDE,KAAK,EAAE,CAAC;QACT,CAAC;QACDzB,MAAM,CAAC0B,2BAA2B,CAACP,SAAS,CAAC;QAC7CtB,cAAc,CAAC8B,OAAO,CAACpB,MAAM,CAACM,KAAK,CAAC;QACpCd,cAAc,CAAC6B,MAAM,CAACrB,MAAM,CAACM,KAAK,EAAED,eAAe,CAAC;QACpDL,MAAM,CAACsB,KAAK,CAACC,QAAQ,GAAG,IAAI;MAC7B;IACD,CAAC,CAAC;IAEFvB,MAAM,CAACC,KAAK,CAACH,aAAa,CAACK,GAAG,CAAC,8BAA8B,EAAE,MAAM;MACpE,MAAMV,MAAM,GAAGO,MAAM,CAACM,KAAK,CAACb,MAAM;MAClC,IAAI,CAAC,IAAI,CAACK,aAAa,EAAE;QACxB,MAAM,IAAI0B,KAAK,CACd,kGACD,CAAC;MACF;MACA,IAAI,CAAChC,cAAc,CAACiC,SAAS,CAACzB,MAAM,CAACM,KAAK,CAAC,EAAE;QAC5C,MAAM,IAAIkB,KAAK,CACd,yDACD,CAAC;MACF;MACA;MACC/B,MAAM,CAACiC,SAAS,CAAEC,KAAK,GAAG,IAAI;MAC/BxC,iCAAiC,CAACyC,KAAK,CACtCnC,MAAM,EACNO,MAAM,CAACM,KAAK,CAACuB,WAAW,CAACC,eAAe,EACxC,eACD,CAAC;IACF,CAAC,CAAC;;IAEF;AACF;AACA;IACE,MAAMC,aAAa,GAAGA,CAAA,KAAM;MAC3B,IAAIvC,cAAc,CAACiC,SAAS,CAACzB,MAAM,CAACM,KAAK,CAAC,EAAE;QAC3C,OAAO,IAAI;MACZ;IACD,CAAC;;IAED;AACF;AACA;IACE,MAAM0B,aAAa,GAAGA,CAAA,KAAM;MAC3B,IAAIxC,cAAc,CAACiC,SAAS,CAACzB,MAAM,CAACM,KAAK,CAAC,EAAE;QAC3C,OAAO,IAAI;MACZ;IACD,CAAC;IAED,MAAM2B,qBAAqB,GAAG,CAAC,QAAQ,EAAE,SAAS,CAAC;IACnD,KAAK,MAAMC,UAAU,IAAID,qBAAqB,EAAE;MAC/CjC,MAAM,CAACC,KAAK,CAACkC,cAAc,CACzBC,GAAG,CAACF,UAAU,CAAC,CACf/B,GAAG,CAAC,8BAA8B,EAAE6B,aAAa,CAAC;MACpDhC,MAAM,CAACC,KAAK,CAACoC,MAAM,CACjBD,GAAG,CAACF,UAAU,CAAC,CACf/B,GAAG,CAAC,8BAA8B,EAAE4B,aAAa,CAAC;MACpD/B,MAAM,CAACC,KAAK,CAACqC,QAAQ,CACnBF,GAAG,CAACF,UAAU,CAAC,CACf/B,GAAG,CAAC,8BAA8B,EAAE6B,aAAa,CAAC;MACpDhC,MAAM,CAACC,KAAK,CAACsC,UAAU,CACrBH,GAAG,CAACF,UAAU,CAAC,CACf/B,GAAG,CAAC,8BAA8B,EAAE4B,aAAa,CAAC;MACpD/B,MAAM,CAACC,KAAK,CAACuC,IAAI,CACfJ,GAAG,CAACF,UAAU,CAAC,CACf/B,GAAG,CAAC,8BAA8B,EAAE4B,aAAa,CAAC;IACrD;EACD;AACD,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
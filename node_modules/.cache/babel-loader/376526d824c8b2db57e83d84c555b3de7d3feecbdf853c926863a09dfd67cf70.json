{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst RuntimeModule = require(\"../RuntimeModule\");\nconst Template = require(\"../Template\");\nconst {\n  compareModulesByIdentifier\n} = require(\"../util/comparators\");\nconst WebAssemblyUtils = require(\"./WebAssemblyUtils\");\n\n/** @typedef {import(\"@webassemblyjs/ast\").Signature} Signature */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../Module\").ReadOnlyRuntimeRequirements} ReadOnlyRuntimeRequirements */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n// TODO webpack 6 remove the whole folder\n\n// Get all wasm modules\n/**\n * @param {ModuleGraph} moduleGraph the module graph\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Chunk} chunk the chunk\n * @returns {Module[]} all wasm modules\n */\nconst getAllWasmModules = (moduleGraph, chunkGraph, chunk) => {\n  const wasmModules = chunk.getAllAsyncChunks();\n  const array = [];\n  for (const chunk of wasmModules) {\n    for (const m of chunkGraph.getOrderedChunkModulesIterable(chunk, compareModulesByIdentifier)) {\n      if (m.type.startsWith(\"webassembly\")) {\n        array.push(m);\n      }\n    }\n  }\n  return array;\n};\n\n/**\n * generates the import object function for a module\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Module} module the module\n * @param {boolean | undefined} mangle mangle imports\n * @param {string[]} declarations array where declarations are pushed to\n * @param {RuntimeSpec} runtime the runtime\n * @returns {string} source code\n */\nconst generateImportObject = (chunkGraph, module, mangle, declarations, runtime) => {\n  const moduleGraph = chunkGraph.moduleGraph;\n  /** @type {Map<string, string | number>} */\n  const waitForInstances = new Map();\n  const properties = [];\n  const usedWasmDependencies = WebAssemblyUtils.getUsedDependencies(moduleGraph, module, mangle);\n  for (const usedDep of usedWasmDependencies) {\n    const dep = usedDep.dependency;\n    const importedModule = moduleGraph.getModule(dep);\n    const exportName = dep.name;\n    const usedName = importedModule && moduleGraph.getExportsInfo(importedModule).getUsedName(exportName, runtime);\n    const description = dep.description;\n    const direct = dep.onlyDirectImport;\n    const module = usedDep.module;\n    const name = usedDep.name;\n    if (direct) {\n      const instanceVar = `m${waitForInstances.size}`;\n      waitForInstances.set(instanceVar, chunkGraph.getModuleId( /** @type {Module} */importedModule));\n      properties.push({\n        module,\n        name,\n        value: `${instanceVar}[${JSON.stringify(usedName)}]`\n      });\n    } else {\n      const params = /** @type {Signature} */\n      description.signature.params.map((param, k) => \"p\" + k + param.valtype);\n      const mod = `${RuntimeGlobals.moduleCache}[${JSON.stringify(chunkGraph.getModuleId( /** @type {Module} */importedModule))}]`;\n      const modExports = `${mod}.exports`;\n      const cache = `wasmImportedFuncCache${declarations.length}`;\n      declarations.push(`var ${cache};`);\n      const modCode = /** @type {Module} */\n      importedModule.type.startsWith(\"webassembly\") ? `${mod} ? ${modExports}[${JSON.stringify(usedName)}] : ` : \"\";\n      properties.push({\n        module,\n        name,\n        value: Template.asString([modCode + `function(${params}) {`, Template.indent([`if(${cache} === undefined) ${cache} = ${modExports};`, `return ${cache}[${JSON.stringify(usedName)}](${params});`]), \"}\"])\n      });\n    }\n  }\n  let importObject;\n  if (mangle) {\n    importObject = [\"return {\", Template.indent([properties.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(\",\\n\")]), \"};\"];\n  } else {\n    /** @type {Map<string, Array<{ name: string, value: string }>>} */\n    const propertiesByModule = new Map();\n    for (const p of properties) {\n      let list = propertiesByModule.get(p.module);\n      if (list === undefined) {\n        propertiesByModule.set(p.module, list = []);\n      }\n      list.push(p);\n    }\n    importObject = [\"return {\", Template.indent([Array.from(propertiesByModule, ([module, list]) => {\n      return Template.asString([`${JSON.stringify(module)}: {`, Template.indent([list.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(\",\\n\")]), \"}\"]);\n    }).join(\",\\n\")]), \"};\"];\n  }\n  const moduleIdStringified = JSON.stringify(chunkGraph.getModuleId(module));\n  if (waitForInstances.size === 1) {\n    const moduleId = Array.from(waitForInstances.values())[0];\n    const promise = `installedWasmModules[${JSON.stringify(moduleId)}]`;\n    const variable = Array.from(waitForInstances.keys())[0];\n    return Template.asString([`${moduleIdStringified}: function() {`, Template.indent([`return promiseResolve().then(function() { return ${promise}; }).then(function(${variable}) {`, Template.indent(importObject), \"});\"]), \"},\"]);\n  } else if (waitForInstances.size > 0) {\n    const promises = Array.from(waitForInstances.values(), id => `installedWasmModules[${JSON.stringify(id)}]`).join(\", \");\n    const variables = Array.from(waitForInstances.keys(), (name, i) => `${name} = array[${i}]`).join(\", \");\n    return Template.asString([`${moduleIdStringified}: function() {`, Template.indent([`return promiseResolve().then(function() { return Promise.all([${promises}]); }).then(function(array) {`, Template.indent([`var ${variables};`, ...importObject]), \"});\"]), \"},\"]);\n  } else {\n    return Template.asString([`${moduleIdStringified}: function() {`, Template.indent(importObject), \"},\"]);\n  }\n};\n\n/**\n * @typedef {Object} WasmChunkLoadingRuntimeModuleOptions\n * @property {(path: string) => string} generateLoadBinaryCode\n * @property {boolean} [supportsStreaming]\n * @property {boolean} [mangleImports]\n * @property {ReadOnlyRuntimeRequirements} runtimeRequirements\n */\n\nclass WasmChunkLoadingRuntimeModule extends RuntimeModule {\n  /**\n   * @param {WasmChunkLoadingRuntimeModuleOptions} options options\n   */\n  constructor({\n    generateLoadBinaryCode,\n    supportsStreaming,\n    mangleImports,\n    runtimeRequirements\n  }) {\n    super(\"wasm chunk loading\", RuntimeModule.STAGE_ATTACH);\n    this.generateLoadBinaryCode = generateLoadBinaryCode;\n    this.supportsStreaming = supportsStreaming;\n    this.mangleImports = mangleImports;\n    this._runtimeRequirements = runtimeRequirements;\n  }\n\n  /**\n   * @returns {string | null} runtime code\n   */\n  generate() {\n    const fn = RuntimeGlobals.ensureChunkHandlers;\n    const withHmr = this._runtimeRequirements.has(RuntimeGlobals.hmrDownloadUpdateHandlers);\n    const compilation = /** @type {Compilation} */this.compilation;\n    const {\n      moduleGraph,\n      outputOptions\n    } = compilation;\n    const chunkGraph = /** @type {ChunkGraph} */this.chunkGraph;\n    const chunk = /** @type {Chunk} */this.chunk;\n    const wasmModules = getAllWasmModules(moduleGraph, chunkGraph, chunk);\n    const {\n      mangleImports\n    } = this;\n    /** @type {string[]} */\n    const declarations = [];\n    const importObjects = wasmModules.map(module => {\n      return generateImportObject(chunkGraph, module, mangleImports, declarations, chunk.runtime);\n    });\n    const chunkModuleIdMap = chunkGraph.getChunkModuleIdMap(chunk, m => m.type.startsWith(\"webassembly\"));\n    /**\n     * @param {string} content content\n     * @returns {string} created import object\n     */\n    const createImportObject = content => mangleImports ? `{ ${JSON.stringify(WebAssemblyUtils.MANGLED_MODULE)}: ${content} }` : content;\n    const wasmModuleSrcPath = compilation.getPath(JSON.stringify(outputOptions.webassemblyModuleFilename), {\n      hash: `\" + ${RuntimeGlobals.getFullHash}() + \"`,\n      hashWithLength: length => `\" + ${RuntimeGlobals.getFullHash}}().slice(0, ${length}) + \"`,\n      module: {\n        id: '\" + wasmModuleId + \"',\n        hash: `\" + ${JSON.stringify(chunkGraph.getChunkModuleRenderedHashMap(chunk, m => m.type.startsWith(\"webassembly\")))}[chunkId][wasmModuleId] + \"`,\n        hashWithLength(length) {\n          return `\" + ${JSON.stringify(chunkGraph.getChunkModuleRenderedHashMap(chunk, m => m.type.startsWith(\"webassembly\"), length))}[chunkId][wasmModuleId] + \"`;\n        }\n      },\n      runtime: chunk.runtime\n    });\n    const stateExpression = withHmr ? `${RuntimeGlobals.hmrRuntimeStatePrefix}_wasm` : undefined;\n    return Template.asString([\"// object to store loaded and loading wasm modules\", `var installedWasmModules = ${stateExpression ? `${stateExpression} = ${stateExpression} || ` : \"\"}{};`, \"\",\n    // This function is used to delay reading the installed wasm module promises\n    // by a microtask. Sorting them doesn't help because there are edge cases where\n    // sorting is not possible (modules splitted into different chunks).\n    // So we not even trying and solve this by a microtask delay.\n    \"function promiseResolve() { return Promise.resolve(); }\", \"\", Template.asString(declarations), \"var wasmImportObjects = {\", Template.indent(importObjects), \"};\", \"\", `var wasmModuleMap = ${JSON.stringify(chunkModuleIdMap, undefined, \"\\t\")};`, \"\", \"// object with all WebAssembly.instance exports\", `${RuntimeGlobals.wasmInstances} = {};`, \"\", \"// Fetch + compile chunk loading for webassembly\", `${fn}.wasm = function(chunkId, promises) {`, Template.indent([\"\", `var wasmModules = wasmModuleMap[chunkId] || [];`, \"\", \"wasmModules.forEach(function(wasmModuleId, idx) {\", Template.indent([\"var installedWasmModuleData = installedWasmModules[wasmModuleId];\", \"\", '// a Promise means \"currently loading\" or \"already loaded\".', \"if(installedWasmModuleData)\", Template.indent([\"promises.push(installedWasmModuleData);\"]), \"else {\", Template.indent([`var importObject = wasmImportObjects[wasmModuleId]();`, `var req = ${this.generateLoadBinaryCode(wasmModuleSrcPath)};`, \"var promise;\", this.supportsStreaming ? Template.asString([\"if(importObject && typeof importObject.then === 'function' && typeof WebAssembly.compileStreaming === 'function') {\", Template.indent([\"promise = Promise.all([WebAssembly.compileStreaming(req), importObject]).then(function(items) {\", Template.indent([`return WebAssembly.instantiate(items[0], ${createImportObject(\"items[1]\")});`]), \"});\"]), \"} else if(typeof WebAssembly.instantiateStreaming === 'function') {\", Template.indent([`promise = WebAssembly.instantiateStreaming(req, ${createImportObject(\"importObject\")});`])]) : Template.asString([\"if(importObject && typeof importObject.then === 'function') {\", Template.indent([\"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\", \"promise = Promise.all([\", Template.indent([\"bytesPromise.then(function(bytes) { return WebAssembly.compile(bytes); }),\", \"importObject\"]), \"]).then(function(items) {\", Template.indent([`return WebAssembly.instantiate(items[0], ${createImportObject(\"items[1]\")});`]), \"});\"])]), \"} else {\", Template.indent([\"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\", \"promise = bytesPromise.then(function(bytes) {\", Template.indent([`return WebAssembly.instantiate(bytes, ${createImportObject(\"importObject\")});`]), \"});\"]), \"}\", \"promises.push(installedWasmModules[wasmModuleId] = promise.then(function(res) {\", Template.indent([`return ${RuntimeGlobals.wasmInstances}[wasmModuleId] = (res.instance || res).exports;`]), \"}));\"]), \"}\"]), \"});\"]), \"};\"]);\n  }\n}\nmodule.exports = WasmChunkLoadingRuntimeModule;","map":{"version":3,"names":["RuntimeGlobals","require","RuntimeModule","Template","compareModulesByIdentifier","WebAssemblyUtils","getAllWasmModules","moduleGraph","chunkGraph","chunk","wasmModules","getAllAsyncChunks","array","m","getOrderedChunkModulesIterable","type","startsWith","push","generateImportObject","module","mangle","declarations","runtime","waitForInstances","Map","properties","usedWasmDependencies","getUsedDependencies","usedDep","dep","dependency","importedModule","getModule","exportName","name","usedName","getExportsInfo","getUsedName","description","direct","onlyDirectImport","instanceVar","size","set","getModuleId","value","JSON","stringify","params","signature","map","param","k","valtype","mod","moduleCache","modExports","cache","length","modCode","asString","indent","importObject","p","join","propertiesByModule","list","get","undefined","Array","from","moduleIdStringified","moduleId","values","promise","variable","keys","promises","id","variables","i","WasmChunkLoadingRuntimeModule","constructor","generateLoadBinaryCode","supportsStreaming","mangleImports","runtimeRequirements","STAGE_ATTACH","_runtimeRequirements","generate","fn","ensureChunkHandlers","withHmr","has","hmrDownloadUpdateHandlers","compilation","outputOptions","importObjects","chunkModuleIdMap","getChunkModuleIdMap","createImportObject","content","MANGLED_MODULE","wasmModuleSrcPath","getPath","webassemblyModuleFilename","hash","getFullHash","hashWithLength","getChunkModuleRenderedHashMap","stateExpression","hmrRuntimeStatePrefix","wasmInstances","exports"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/wasm-sync/WasmChunkLoadingRuntimeModule.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst RuntimeModule = require(\"../RuntimeModule\");\nconst Template = require(\"../Template\");\nconst { compareModulesByIdentifier } = require(\"../util/comparators\");\nconst WebAssemblyUtils = require(\"./WebAssemblyUtils\");\n\n/** @typedef {import(\"@webassemblyjs/ast\").Signature} Signature */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../Module\").ReadOnlyRuntimeRequirements} ReadOnlyRuntimeRequirements */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n// TODO webpack 6 remove the whole folder\n\n// Get all wasm modules\n/**\n * @param {ModuleGraph} moduleGraph the module graph\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Chunk} chunk the chunk\n * @returns {Module[]} all wasm modules\n */\nconst getAllWasmModules = (moduleGraph, chunkGraph, chunk) => {\n\tconst wasmModules = chunk.getAllAsyncChunks();\n\tconst array = [];\n\tfor (const chunk of wasmModules) {\n\t\tfor (const m of chunkGraph.getOrderedChunkModulesIterable(\n\t\t\tchunk,\n\t\t\tcompareModulesByIdentifier\n\t\t)) {\n\t\t\tif (m.type.startsWith(\"webassembly\")) {\n\t\t\t\tarray.push(m);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn array;\n};\n\n/**\n * generates the import object function for a module\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Module} module the module\n * @param {boolean | undefined} mangle mangle imports\n * @param {string[]} declarations array where declarations are pushed to\n * @param {RuntimeSpec} runtime the runtime\n * @returns {string} source code\n */\nconst generateImportObject = (\n\tchunkGraph,\n\tmodule,\n\tmangle,\n\tdeclarations,\n\truntime\n) => {\n\tconst moduleGraph = chunkGraph.moduleGraph;\n\t/** @type {Map<string, string | number>} */\n\tconst waitForInstances = new Map();\n\tconst properties = [];\n\tconst usedWasmDependencies = WebAssemblyUtils.getUsedDependencies(\n\t\tmoduleGraph,\n\t\tmodule,\n\t\tmangle\n\t);\n\tfor (const usedDep of usedWasmDependencies) {\n\t\tconst dep = usedDep.dependency;\n\t\tconst importedModule = moduleGraph.getModule(dep);\n\t\tconst exportName = dep.name;\n\t\tconst usedName =\n\t\t\timportedModule &&\n\t\t\tmoduleGraph\n\t\t\t\t.getExportsInfo(importedModule)\n\t\t\t\t.getUsedName(exportName, runtime);\n\t\tconst description = dep.description;\n\t\tconst direct = dep.onlyDirectImport;\n\n\t\tconst module = usedDep.module;\n\t\tconst name = usedDep.name;\n\n\t\tif (direct) {\n\t\t\tconst instanceVar = `m${waitForInstances.size}`;\n\t\t\twaitForInstances.set(\n\t\t\t\tinstanceVar,\n\t\t\t\tchunkGraph.getModuleId(/** @type {Module} */ (importedModule))\n\t\t\t);\n\t\t\tproperties.push({\n\t\t\t\tmodule,\n\t\t\t\tname,\n\t\t\t\tvalue: `${instanceVar}[${JSON.stringify(usedName)}]`\n\t\t\t});\n\t\t} else {\n\t\t\tconst params =\n\t\t\t\t/** @type {Signature} */\n\t\t\t\t(description.signature).params.map(\n\t\t\t\t\t(param, k) => \"p\" + k + param.valtype\n\t\t\t\t);\n\n\t\t\tconst mod = `${RuntimeGlobals.moduleCache}[${JSON.stringify(\n\t\t\t\tchunkGraph.getModuleId(/** @type {Module} */ (importedModule))\n\t\t\t)}]`;\n\t\t\tconst modExports = `${mod}.exports`;\n\n\t\t\tconst cache = `wasmImportedFuncCache${declarations.length}`;\n\t\t\tdeclarations.push(`var ${cache};`);\n\n\t\t\tconst modCode =\n\t\t\t\t/** @type {Module} */\n\t\t\t\t(importedModule).type.startsWith(\"webassembly\")\n\t\t\t\t\t? `${mod} ? ${modExports}[${JSON.stringify(usedName)}] : `\n\t\t\t\t\t: \"\";\n\n\t\t\tproperties.push({\n\t\t\t\tmodule,\n\t\t\t\tname,\n\t\t\t\tvalue: Template.asString([\n\t\t\t\t\tmodCode + `function(${params}) {`,\n\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t`if(${cache} === undefined) ${cache} = ${modExports};`,\n\t\t\t\t\t\t`return ${cache}[${JSON.stringify(usedName)}](${params});`\n\t\t\t\t\t]),\n\t\t\t\t\t\"}\"\n\t\t\t\t])\n\t\t\t});\n\t\t}\n\t}\n\n\tlet importObject;\n\tif (mangle) {\n\t\timportObject = [\n\t\t\t\"return {\",\n\t\t\tTemplate.indent([\n\t\t\t\tproperties.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(\",\\n\")\n\t\t\t]),\n\t\t\t\"};\"\n\t\t];\n\t} else {\n\t\t/** @type {Map<string, Array<{ name: string, value: string }>>} */\n\t\tconst propertiesByModule = new Map();\n\t\tfor (const p of properties) {\n\t\t\tlet list = propertiesByModule.get(p.module);\n\t\t\tif (list === undefined) {\n\t\t\t\tpropertiesByModule.set(p.module, (list = []));\n\t\t\t}\n\t\t\tlist.push(p);\n\t\t}\n\t\timportObject = [\n\t\t\t\"return {\",\n\t\t\tTemplate.indent([\n\t\t\t\tArray.from(propertiesByModule, ([module, list]) => {\n\t\t\t\t\treturn Template.asString([\n\t\t\t\t\t\t`${JSON.stringify(module)}: {`,\n\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\tlist.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(\",\\n\")\n\t\t\t\t\t\t]),\n\t\t\t\t\t\t\"}\"\n\t\t\t\t\t]);\n\t\t\t\t}).join(\",\\n\")\n\t\t\t]),\n\t\t\t\"};\"\n\t\t];\n\t}\n\n\tconst moduleIdStringified = JSON.stringify(chunkGraph.getModuleId(module));\n\tif (waitForInstances.size === 1) {\n\t\tconst moduleId = Array.from(waitForInstances.values())[0];\n\t\tconst promise = `installedWasmModules[${JSON.stringify(moduleId)}]`;\n\t\tconst variable = Array.from(waitForInstances.keys())[0];\n\t\treturn Template.asString([\n\t\t\t`${moduleIdStringified}: function() {`,\n\t\t\tTemplate.indent([\n\t\t\t\t`return promiseResolve().then(function() { return ${promise}; }).then(function(${variable}) {`,\n\t\t\t\tTemplate.indent(importObject),\n\t\t\t\t\"});\"\n\t\t\t]),\n\t\t\t\"},\"\n\t\t]);\n\t} else if (waitForInstances.size > 0) {\n\t\tconst promises = Array.from(\n\t\t\twaitForInstances.values(),\n\t\t\tid => `installedWasmModules[${JSON.stringify(id)}]`\n\t\t).join(\", \");\n\t\tconst variables = Array.from(\n\t\t\twaitForInstances.keys(),\n\t\t\t(name, i) => `${name} = array[${i}]`\n\t\t).join(\", \");\n\t\treturn Template.asString([\n\t\t\t`${moduleIdStringified}: function() {`,\n\t\t\tTemplate.indent([\n\t\t\t\t`return promiseResolve().then(function() { return Promise.all([${promises}]); }).then(function(array) {`,\n\t\t\t\tTemplate.indent([`var ${variables};`, ...importObject]),\n\t\t\t\t\"});\"\n\t\t\t]),\n\t\t\t\"},\"\n\t\t]);\n\t} else {\n\t\treturn Template.asString([\n\t\t\t`${moduleIdStringified}: function() {`,\n\t\t\tTemplate.indent(importObject),\n\t\t\t\"},\"\n\t\t]);\n\t}\n};\n\n/**\n * @typedef {Object} WasmChunkLoadingRuntimeModuleOptions\n * @property {(path: string) => string} generateLoadBinaryCode\n * @property {boolean} [supportsStreaming]\n * @property {boolean} [mangleImports]\n * @property {ReadOnlyRuntimeRequirements} runtimeRequirements\n */\n\nclass WasmChunkLoadingRuntimeModule extends RuntimeModule {\n\t/**\n\t * @param {WasmChunkLoadingRuntimeModuleOptions} options options\n\t */\n\tconstructor({\n\t\tgenerateLoadBinaryCode,\n\t\tsupportsStreaming,\n\t\tmangleImports,\n\t\truntimeRequirements\n\t}) {\n\t\tsuper(\"wasm chunk loading\", RuntimeModule.STAGE_ATTACH);\n\t\tthis.generateLoadBinaryCode = generateLoadBinaryCode;\n\t\tthis.supportsStreaming = supportsStreaming;\n\t\tthis.mangleImports = mangleImports;\n\t\tthis._runtimeRequirements = runtimeRequirements;\n\t}\n\n\t/**\n\t * @returns {string | null} runtime code\n\t */\n\tgenerate() {\n\t\tconst fn = RuntimeGlobals.ensureChunkHandlers;\n\t\tconst withHmr = this._runtimeRequirements.has(\n\t\t\tRuntimeGlobals.hmrDownloadUpdateHandlers\n\t\t);\n\t\tconst compilation = /** @type {Compilation} */ (this.compilation);\n\t\tconst { moduleGraph, outputOptions } = compilation;\n\t\tconst chunkGraph = /** @type {ChunkGraph} */ (this.chunkGraph);\n\t\tconst chunk = /** @type {Chunk} */ (this.chunk);\n\t\tconst wasmModules = getAllWasmModules(moduleGraph, chunkGraph, chunk);\n\t\tconst { mangleImports } = this;\n\t\t/** @type {string[]} */\n\t\tconst declarations = [];\n\t\tconst importObjects = wasmModules.map(module => {\n\t\t\treturn generateImportObject(\n\t\t\t\tchunkGraph,\n\t\t\t\tmodule,\n\t\t\t\tmangleImports,\n\t\t\t\tdeclarations,\n\t\t\t\tchunk.runtime\n\t\t\t);\n\t\t});\n\t\tconst chunkModuleIdMap = chunkGraph.getChunkModuleIdMap(chunk, m =>\n\t\t\tm.type.startsWith(\"webassembly\")\n\t\t);\n\t\t/**\n\t\t * @param {string} content content\n\t\t * @returns {string} created import object\n\t\t */\n\t\tconst createImportObject = content =>\n\t\t\tmangleImports\n\t\t\t\t? `{ ${JSON.stringify(WebAssemblyUtils.MANGLED_MODULE)}: ${content} }`\n\t\t\t\t: content;\n\t\tconst wasmModuleSrcPath = compilation.getPath(\n\t\t\tJSON.stringify(outputOptions.webassemblyModuleFilename),\n\t\t\t{\n\t\t\t\thash: `\" + ${RuntimeGlobals.getFullHash}() + \"`,\n\t\t\t\thashWithLength: length =>\n\t\t\t\t\t`\" + ${RuntimeGlobals.getFullHash}}().slice(0, ${length}) + \"`,\n\t\t\t\tmodule: {\n\t\t\t\t\tid: '\" + wasmModuleId + \"',\n\t\t\t\t\thash: `\" + ${JSON.stringify(\n\t\t\t\t\t\tchunkGraph.getChunkModuleRenderedHashMap(chunk, m =>\n\t\t\t\t\t\t\tm.type.startsWith(\"webassembly\")\n\t\t\t\t\t\t)\n\t\t\t\t\t)}[chunkId][wasmModuleId] + \"`,\n\t\t\t\t\thashWithLength(length) {\n\t\t\t\t\t\treturn `\" + ${JSON.stringify(\n\t\t\t\t\t\t\tchunkGraph.getChunkModuleRenderedHashMap(\n\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\tm => m.type.startsWith(\"webassembly\"),\n\t\t\t\t\t\t\t\tlength\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)}[chunkId][wasmModuleId] + \"`;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\truntime: chunk.runtime\n\t\t\t}\n\t\t);\n\n\t\tconst stateExpression = withHmr\n\t\t\t? `${RuntimeGlobals.hmrRuntimeStatePrefix}_wasm`\n\t\t\t: undefined;\n\n\t\treturn Template.asString([\n\t\t\t\"// object to store loaded and loading wasm modules\",\n\t\t\t`var installedWasmModules = ${\n\t\t\t\tstateExpression ? `${stateExpression} = ${stateExpression} || ` : \"\"\n\t\t\t}{};`,\n\t\t\t\"\",\n\t\t\t// This function is used to delay reading the installed wasm module promises\n\t\t\t// by a microtask. Sorting them doesn't help because there are edge cases where\n\t\t\t// sorting is not possible (modules splitted into different chunks).\n\t\t\t// So we not even trying and solve this by a microtask delay.\n\t\t\t\"function promiseResolve() { return Promise.resolve(); }\",\n\t\t\t\"\",\n\t\t\tTemplate.asString(declarations),\n\t\t\t\"var wasmImportObjects = {\",\n\t\t\tTemplate.indent(importObjects),\n\t\t\t\"};\",\n\t\t\t\"\",\n\t\t\t`var wasmModuleMap = ${JSON.stringify(\n\t\t\t\tchunkModuleIdMap,\n\t\t\t\tundefined,\n\t\t\t\t\"\\t\"\n\t\t\t)};`,\n\t\t\t\"\",\n\t\t\t\"// object with all WebAssembly.instance exports\",\n\t\t\t`${RuntimeGlobals.wasmInstances} = {};`,\n\t\t\t\"\",\n\t\t\t\"// Fetch + compile chunk loading for webassembly\",\n\t\t\t`${fn}.wasm = function(chunkId, promises) {`,\n\t\t\tTemplate.indent([\n\t\t\t\t\"\",\n\t\t\t\t`var wasmModules = wasmModuleMap[chunkId] || [];`,\n\t\t\t\t\"\",\n\t\t\t\t\"wasmModules.forEach(function(wasmModuleId, idx) {\",\n\t\t\t\tTemplate.indent([\n\t\t\t\t\t\"var installedWasmModuleData = installedWasmModules[wasmModuleId];\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t'// a Promise means \"currently loading\" or \"already loaded\".',\n\t\t\t\t\t\"if(installedWasmModuleData)\",\n\t\t\t\t\tTemplate.indent([\"promises.push(installedWasmModuleData);\"]),\n\t\t\t\t\t\"else {\",\n\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t`var importObject = wasmImportObjects[wasmModuleId]();`,\n\t\t\t\t\t\t`var req = ${this.generateLoadBinaryCode(wasmModuleSrcPath)};`,\n\t\t\t\t\t\t\"var promise;\",\n\t\t\t\t\t\tthis.supportsStreaming\n\t\t\t\t\t\t\t? Template.asString([\n\t\t\t\t\t\t\t\t\t\"if(importObject && typeof importObject.then === 'function' && typeof WebAssembly.compileStreaming === 'function') {\",\n\t\t\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t\t\t\"promise = Promise.all([WebAssembly.compileStreaming(req), importObject]).then(function(items) {\",\n\t\t\t\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t\t\t\t`return WebAssembly.instantiate(items[0], ${createImportObject(\n\t\t\t\t\t\t\t\t\t\t\t\t\"items[1]\"\n\t\t\t\t\t\t\t\t\t\t\t)});`\n\t\t\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t\t\t\t\"});\"\n\t\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t\t\t\"} else if(typeof WebAssembly.instantiateStreaming === 'function') {\",\n\t\t\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t\t\t`promise = WebAssembly.instantiateStreaming(req, ${createImportObject(\n\t\t\t\t\t\t\t\t\t\t\t\"importObject\"\n\t\t\t\t\t\t\t\t\t\t)});`\n\t\t\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\t: Template.asString([\n\t\t\t\t\t\t\t\t\t\"if(importObject && typeof importObject.then === 'function') {\",\n\t\t\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t\t\t\"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\",\n\t\t\t\t\t\t\t\t\t\t\"promise = Promise.all([\",\n\t\t\t\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t\t\t\t\"bytesPromise.then(function(bytes) { return WebAssembly.compile(bytes); }),\",\n\t\t\t\t\t\t\t\t\t\t\t\"importObject\"\n\t\t\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t\t\t\t\"]).then(function(items) {\",\n\t\t\t\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t\t\t\t`return WebAssembly.instantiate(items[0], ${createImportObject(\n\t\t\t\t\t\t\t\t\t\t\t\t\"items[1]\"\n\t\t\t\t\t\t\t\t\t\t\t)});`\n\t\t\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t\t\t\t\"});\"\n\t\t\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\"} else {\",\n\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\",\n\t\t\t\t\t\t\t\"promise = bytesPromise.then(function(bytes) {\",\n\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t`return WebAssembly.instantiate(bytes, ${createImportObject(\n\t\t\t\t\t\t\t\t\t\"importObject\"\n\t\t\t\t\t\t\t\t)});`\n\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t\"});\"\n\t\t\t\t\t\t]),\n\t\t\t\t\t\t\"}\",\n\t\t\t\t\t\t\"promises.push(installedWasmModules[wasmModuleId] = promise.then(function(res) {\",\n\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t`return ${RuntimeGlobals.wasmInstances}[wasmModuleId] = (res.instance || res).exports;`\n\t\t\t\t\t\t]),\n\t\t\t\t\t\t\"}));\"\n\t\t\t\t\t]),\n\t\t\t\t\t\"}\"\n\t\t\t\t]),\n\t\t\t\t\"});\"\n\t\t\t]),\n\t\t\t\"};\"\n\t\t]);\n\t}\n}\n\nmodule.exports = WasmChunkLoadingRuntimeModule;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
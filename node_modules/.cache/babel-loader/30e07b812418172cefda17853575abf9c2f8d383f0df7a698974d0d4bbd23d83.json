{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst FileSystemInfo = require(\"../FileSystemInfo\");\nconst ProgressPlugin = require(\"../ProgressPlugin\");\nconst {\n  formatSize\n} = require(\"../SizeFormatHelpers\");\nconst SerializerMiddleware = require(\"../serialization/SerializerMiddleware\");\nconst LazySet = require(\"../util/LazySet\");\nconst makeSerializable = require(\"../util/makeSerializable\");\nconst memoize = require(\"../util/memoize\");\nconst {\n  createFileSerializer,\n  NOT_SERIALIZABLE\n} = require(\"../util/serialization\");\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").SnapshotOptions} SnapshotOptions */\n/** @typedef {import(\"../Cache\").Etag} Etag */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../FileSystemInfo\").ResolveBuildDependenciesResult} ResolveBuildDependenciesResult */\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n/** @typedef {import(\"../logging/Logger\").Logger} Logger */\n/** @typedef {import(\"../serialization/ObjectMiddleware\").ObjectDeserializerContext} ObjectDeserializerContext */\n/** @typedef {import(\"../serialization/ObjectMiddleware\").ObjectSerializerContext} ObjectSerializerContext */\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\n/** @typedef {Map<string, string | false>} ResolveResults */\n/** @typedef {Set<string>} Items */\n/** @typedef {Set<string>} BuildDependencies */\n/** @typedef {Map<string, PackItemInfo>} ItemInfo */\n\nclass PackContainer {\n  /**\n   * @param {Object} data stored data\n   * @param {string} version version identifier\n   * @param {Snapshot} buildSnapshot snapshot of all build dependencies\n   * @param {BuildDependencies} buildDependencies list of all unresolved build dependencies captured\n   * @param {ResolveResults} resolveResults result of the resolved build dependencies\n   * @param {Snapshot} resolveBuildDependenciesSnapshot snapshot of the dependencies of the build dependencies resolving\n   */\n  constructor(data, version, buildSnapshot, buildDependencies, resolveResults, resolveBuildDependenciesSnapshot) {\n    this.data = data;\n    this.version = version;\n    this.buildSnapshot = buildSnapshot;\n    this.buildDependencies = buildDependencies;\n    this.resolveResults = resolveResults;\n    this.resolveBuildDependenciesSnapshot = resolveBuildDependenciesSnapshot;\n  }\n\n  /**\n   * @param {ObjectSerializerContext} context context\n   */\n  serialize({\n    write,\n    writeLazy\n  }) {\n    write(this.version);\n    write(this.buildSnapshot);\n    write(this.buildDependencies);\n    write(this.resolveResults);\n    write(this.resolveBuildDependenciesSnapshot);\n    /** @type {NonNullable<ObjectSerializerContext[\"writeLazy\"]>} */\n    writeLazy(this.data);\n  }\n\n  /**\n   * @param {ObjectDeserializerContext} context context\n   */\n  deserialize({\n    read\n  }) {\n    this.version = read();\n    this.buildSnapshot = read();\n    this.buildDependencies = read();\n    this.resolveResults = read();\n    this.resolveBuildDependenciesSnapshot = read();\n    this.data = read();\n  }\n}\nmakeSerializable(PackContainer, \"webpack/lib/cache/PackFileCacheStrategy\", \"PackContainer\");\nconst MIN_CONTENT_SIZE = 1024 * 1024; // 1 MB\nconst CONTENT_COUNT_TO_MERGE = 10;\nconst MIN_ITEMS_IN_FRESH_PACK = 100;\nconst MAX_ITEMS_IN_FRESH_PACK = 50000;\nconst MAX_TIME_IN_FRESH_PACK = 1 * 60 * 1000; // 1 min\n\nclass PackItemInfo {\n  /**\n   * @param {string} identifier identifier of item\n   * @param {string | null} etag etag of item\n   * @param {any} value fresh value of item\n   */\n  constructor(identifier, etag, value) {\n    this.identifier = identifier;\n    this.etag = etag;\n    this.location = -1;\n    this.lastAccess = Date.now();\n    this.freshValue = value;\n  }\n}\nclass Pack {\n  /**\n   * @param {Logger} logger a logger\n   * @param {number} maxAge max age of cache items\n   */\n  constructor(logger, maxAge) {\n    /** @type {ItemInfo} */\n    this.itemInfo = new Map();\n    /** @type {(string | undefined)[]} */\n    this.requests = [];\n    this.requestsTimeout = undefined;\n    /** @type {ItemInfo} */\n    this.freshContent = new Map();\n    /** @type {(undefined | PackContent)[]} */\n    this.content = [];\n    this.invalid = false;\n    this.logger = logger;\n    this.maxAge = maxAge;\n  }\n\n  /**\n   * @param {string} identifier identifier\n   */\n  _addRequest(identifier) {\n    this.requests.push(identifier);\n    if (this.requestsTimeout === undefined) {\n      this.requestsTimeout = setTimeout(() => {\n        this.requests.push(undefined);\n        this.requestsTimeout = undefined;\n      }, MAX_TIME_IN_FRESH_PACK);\n      if (this.requestsTimeout.unref) this.requestsTimeout.unref();\n    }\n  }\n  stopCapturingRequests() {\n    if (this.requestsTimeout !== undefined) {\n      clearTimeout(this.requestsTimeout);\n      this.requestsTimeout = undefined;\n    }\n  }\n\n  /**\n   * @param {string} identifier unique name for the resource\n   * @param {string | null} etag etag of the resource\n   * @returns {any} cached content\n   */\n  get(identifier, etag) {\n    const info = this.itemInfo.get(identifier);\n    this._addRequest(identifier);\n    if (info === undefined) {\n      return undefined;\n    }\n    if (info.etag !== etag) return null;\n    info.lastAccess = Date.now();\n    const loc = info.location;\n    if (loc === -1) {\n      return info.freshValue;\n    } else {\n      if (!this.content[loc]) {\n        return undefined;\n      }\n      return /** @type {PackContent} */this.content[loc].get(identifier);\n    }\n  }\n\n  /**\n   * @param {string} identifier unique name for the resource\n   * @param {string | null} etag etag of the resource\n   * @param {any} data cached content\n   * @returns {void}\n   */\n  set(identifier, etag, data) {\n    if (!this.invalid) {\n      this.invalid = true;\n      this.logger.log(`Pack got invalid because of write to: ${identifier}`);\n    }\n    const info = this.itemInfo.get(identifier);\n    if (info === undefined) {\n      const newInfo = new PackItemInfo(identifier, etag, data);\n      this.itemInfo.set(identifier, newInfo);\n      this._addRequest(identifier);\n      this.freshContent.set(identifier, newInfo);\n    } else {\n      const loc = info.location;\n      if (loc >= 0) {\n        this._addRequest(identifier);\n        this.freshContent.set(identifier, info);\n        const content = /** @type {PackContent} */this.content[loc];\n        content.delete(identifier);\n        if (content.items.size === 0) {\n          this.content[loc] = undefined;\n          this.logger.debug(\"Pack %d got empty and is removed\", loc);\n        }\n      }\n      info.freshValue = data;\n      info.lastAccess = Date.now();\n      info.etag = etag;\n      info.location = -1;\n    }\n  }\n  getContentStats() {\n    let count = 0;\n    let size = 0;\n    for (const content of this.content) {\n      if (content !== undefined) {\n        count++;\n        const s = content.getSize();\n        if (s > 0) {\n          size += s;\n        }\n      }\n    }\n    return {\n      count,\n      size\n    };\n  }\n\n  /**\n   * @returns {number} new location of data entries\n   */\n  _findLocation() {\n    let i;\n    for (i = 0; i < this.content.length && this.content[i] !== undefined; i++);\n    return i;\n  }\n\n  /**\n   * @private\n   * @param {Items} items items\n   * @param {Items} usedItems used items\n   * @param {number} newLoc new location\n   */\n  _gcAndUpdateLocation(items, usedItems, newLoc) {\n    let count = 0;\n    let lastGC;\n    const now = Date.now();\n    for (const identifier of items) {\n      const info = /** @type {PackItemInfo} */this.itemInfo.get(identifier);\n      if (now - info.lastAccess > this.maxAge) {\n        this.itemInfo.delete(identifier);\n        items.delete(identifier);\n        usedItems.delete(identifier);\n        count++;\n        lastGC = identifier;\n      } else {\n        info.location = newLoc;\n      }\n    }\n    if (count > 0) {\n      this.logger.log(\"Garbage Collected %d old items at pack %d (%d items remaining) e. g. %s\", count, newLoc, items.size, lastGC);\n    }\n  }\n  _persistFreshContent() {\n    const itemsCount = this.freshContent.size;\n    if (itemsCount > 0) {\n      const packCount = Math.ceil(itemsCount / MAX_ITEMS_IN_FRESH_PACK);\n      const itemsPerPack = Math.ceil(itemsCount / packCount);\n      const packs = [];\n      let i = 0;\n      let ignoreNextTimeTick = false;\n      const createNextPack = () => {\n        const loc = this._findLocation();\n        this.content[loc] = null; // reserve\n        const pack = {\n          /** @type {Items} */\n          items: new Set(),\n          /** @type {Map<string, any>} */\n          map: new Map(),\n          loc\n        };\n        packs.push(pack);\n        return pack;\n      };\n      let pack = createNextPack();\n      if (this.requestsTimeout !== undefined) clearTimeout(this.requestsTimeout);\n      for (const identifier of this.requests) {\n        if (identifier === undefined) {\n          if (ignoreNextTimeTick) {\n            ignoreNextTimeTick = false;\n          } else if (pack.items.size >= MIN_ITEMS_IN_FRESH_PACK) {\n            i = 0;\n            pack = createNextPack();\n          }\n          continue;\n        }\n        const info = this.freshContent.get(identifier);\n        if (info === undefined) continue;\n        pack.items.add(identifier);\n        pack.map.set(identifier, info.freshValue);\n        info.location = pack.loc;\n        info.freshValue = undefined;\n        this.freshContent.delete(identifier);\n        if (++i > itemsPerPack) {\n          i = 0;\n          pack = createNextPack();\n          ignoreNextTimeTick = true;\n        }\n      }\n      this.requests.length = 0;\n      for (const pack of packs) {\n        this.content[pack.loc] = new PackContent(pack.items, new Set(pack.items), new PackContentItems(pack.map));\n      }\n      this.logger.log(`${itemsCount} fresh items in cache put into pack ${packs.length > 1 ? packs.map(pack => `${pack.loc} (${pack.items.size} items)`).join(\", \") : packs[0].loc}`);\n    }\n  }\n\n  /**\n   * Merges small content files to a single content file\n   */\n  _optimizeSmallContent() {\n    // 1. Find all small content files\n    // Treat unused content files separately to avoid\n    // a merge-split cycle\n    /** @type {number[]} */\n    const smallUsedContents = [];\n    /** @type {number} */\n    let smallUsedContentSize = 0;\n    /** @type {number[]} */\n    const smallUnusedContents = [];\n    /** @type {number} */\n    let smallUnusedContentSize = 0;\n    for (let i = 0; i < this.content.length; i++) {\n      const content = this.content[i];\n      if (content === undefined) continue;\n      if (content.outdated) continue;\n      const size = content.getSize();\n      if (size < 0 || size > MIN_CONTENT_SIZE) continue;\n      if (content.used.size > 0) {\n        smallUsedContents.push(i);\n        smallUsedContentSize += size;\n      } else {\n        smallUnusedContents.push(i);\n        smallUnusedContentSize += size;\n      }\n    }\n\n    // 2. Check if minimum number is reached\n    let mergedIndices;\n    if (smallUsedContents.length >= CONTENT_COUNT_TO_MERGE || smallUsedContentSize > MIN_CONTENT_SIZE) {\n      mergedIndices = smallUsedContents;\n    } else if (smallUnusedContents.length >= CONTENT_COUNT_TO_MERGE || smallUnusedContentSize > MIN_CONTENT_SIZE) {\n      mergedIndices = smallUnusedContents;\n    } else return;\n\n    /** @type {PackContent[] } */\n    const mergedContent = [];\n\n    // 3. Remove old content entries\n    for (const i of mergedIndices) {\n      mergedContent.push( /** @type {PackContent} */this.content[i]);\n      this.content[i] = undefined;\n    }\n\n    // 4. Determine merged items\n    /** @type {Items} */\n    const mergedItems = new Set();\n    /** @type {Items} */\n    const mergedUsedItems = new Set();\n    /** @type {(function(Map<string, any>): Promise<void>)[]} */\n    const addToMergedMap = [];\n    for (const content of mergedContent) {\n      for (const identifier of content.items) {\n        mergedItems.add(identifier);\n      }\n      for (const identifier of content.used) {\n        mergedUsedItems.add(identifier);\n      }\n      addToMergedMap.push(async map => {\n        // unpack existing content\n        // after that values are accessible in .content\n        await content.unpack(\"it should be merged with other small pack contents\");\n        for (const [identifier, value] of content.content) {\n          map.set(identifier, value);\n        }\n      });\n    }\n\n    // 5. GC and update location of merged items\n    const newLoc = this._findLocation();\n    this._gcAndUpdateLocation(mergedItems, mergedUsedItems, newLoc);\n\n    // 6. If not empty, store content somewhere\n    if (mergedItems.size > 0) {\n      this.content[newLoc] = new PackContent(mergedItems, mergedUsedItems, memoize(async () => {\n        /** @type {Map<string, any>} */\n        const map = new Map();\n        await Promise.all(addToMergedMap.map(fn => fn(map)));\n        return new PackContentItems(map);\n      }));\n      this.logger.log(\"Merged %d small files with %d cache items into pack %d\", mergedContent.length, mergedItems.size, newLoc);\n    }\n  }\n\n  /**\n   * Split large content files with used and unused items\n   * into two parts to separate used from unused items\n   */\n  _optimizeUnusedContent() {\n    // 1. Find a large content file with used and unused items\n    for (let i = 0; i < this.content.length; i++) {\n      const content = this.content[i];\n      if (content === undefined) continue;\n      const size = content.getSize();\n      if (size < MIN_CONTENT_SIZE) continue;\n      const used = content.used.size;\n      const total = content.items.size;\n      if (used > 0 && used < total) {\n        // 2. Remove this content\n        this.content[i] = undefined;\n\n        // 3. Determine items for the used content file\n        const usedItems = new Set(content.used);\n        const newLoc = this._findLocation();\n        this._gcAndUpdateLocation(usedItems, usedItems, newLoc);\n\n        // 4. Create content file for used items\n        if (usedItems.size > 0) {\n          this.content[newLoc] = new PackContent(usedItems, new Set(usedItems), async () => {\n            await content.unpack(\"it should be splitted into used and unused items\");\n            const map = new Map();\n            for (const identifier of usedItems) {\n              map.set(identifier, content.content.get(identifier));\n            }\n            return new PackContentItems(map);\n          });\n        }\n\n        // 5. Determine items for the unused content file\n        const unusedItems = new Set(content.items);\n        const usedOfUnusedItems = new Set();\n        for (const identifier of usedItems) {\n          unusedItems.delete(identifier);\n        }\n        const newUnusedLoc = this._findLocation();\n        this._gcAndUpdateLocation(unusedItems, usedOfUnusedItems, newUnusedLoc);\n\n        // 6. Create content file for unused items\n        if (unusedItems.size > 0) {\n          this.content[newUnusedLoc] = new PackContent(unusedItems, usedOfUnusedItems, async () => {\n            await content.unpack(\"it should be splitted into used and unused items\");\n            const map = new Map();\n            for (const identifier of unusedItems) {\n              map.set(identifier, content.content.get(identifier));\n            }\n            return new PackContentItems(map);\n          });\n        }\n        this.logger.log(\"Split pack %d into pack %d with %d used items and pack %d with %d unused items\", i, newLoc, usedItems.size, newUnusedLoc, unusedItems.size);\n\n        // optimizing only one of them is good enough and\n        // reduces the amount of serialization needed\n        return;\n      }\n    }\n  }\n\n  /**\n   * Find the content with the oldest item and run GC on that.\n   * Only runs for one content to avoid large invalidation.\n   */\n  _gcOldestContent() {\n    /** @type {PackItemInfo | undefined} */\n    let oldest = undefined;\n    for (const info of this.itemInfo.values()) {\n      if (oldest === undefined || info.lastAccess < oldest.lastAccess) {\n        oldest = info;\n      }\n    }\n    if (Date.now() - /** @type {PackItemInfo} */oldest.lastAccess > this.maxAge) {\n      const loc = /** @type {PackItemInfo} */oldest.location;\n      if (loc < 0) return;\n      const content = /** @type {PackContent} */this.content[loc];\n      const items = new Set(content.items);\n      const usedItems = new Set(content.used);\n      this._gcAndUpdateLocation(items, usedItems, loc);\n      this.content[loc] = items.size > 0 ? new PackContent(items, usedItems, async () => {\n        await content.unpack(\"it contains old items that should be garbage collected\");\n        const map = new Map();\n        for (const identifier of items) {\n          map.set(identifier, content.content.get(identifier));\n        }\n        return new PackContentItems(map);\n      }) : undefined;\n    }\n  }\n\n  /**\n   * @param {ObjectSerializerContext} context context\n   */\n  serialize({\n    write,\n    writeSeparate\n  }) {\n    this._persistFreshContent();\n    this._optimizeSmallContent();\n    this._optimizeUnusedContent();\n    this._gcOldestContent();\n    for (const identifier of this.itemInfo.keys()) {\n      write(identifier);\n    }\n    write(null); // null as marker of the end of keys\n    for (const info of this.itemInfo.values()) {\n      write(info.etag);\n    }\n    for (const info of this.itemInfo.values()) {\n      write(info.lastAccess);\n    }\n    for (let i = 0; i < this.content.length; i++) {\n      const content = this.content[i];\n      if (content !== undefined) {\n        write(content.items);\n        content.writeLazy(lazy => writeSeparate(lazy, {\n          name: `${i}`\n        }));\n      } else {\n        write(undefined); // undefined marks an empty content slot\n      }\n    }\n    write(null); // null as marker of the end of items\n  }\n\n  /**\n   * @param {ObjectDeserializerContext & { logger: Logger }} context context\n   */\n  deserialize({\n    read,\n    logger\n  }) {\n    this.logger = logger;\n    {\n      const items = [];\n      let item = read();\n      while (item !== null) {\n        items.push(item);\n        item = read();\n      }\n      this.itemInfo.clear();\n      const infoItems = items.map(identifier => {\n        const info = new PackItemInfo(identifier, undefined, undefined);\n        this.itemInfo.set(identifier, info);\n        return info;\n      });\n      for (const info of infoItems) {\n        info.etag = read();\n      }\n      for (const info of infoItems) {\n        info.lastAccess = read();\n      }\n    }\n    this.content.length = 0;\n    let items = read();\n    while (items !== null) {\n      if (items === undefined) {\n        this.content.push(items);\n      } else {\n        const idx = this.content.length;\n        const lazy = read();\n        this.content.push(new PackContent(items, new Set(), lazy, logger, `${this.content.length}`));\n        for (const identifier of items) {\n          this.itemInfo.get(identifier).location = idx;\n        }\n      }\n      items = read();\n    }\n  }\n}\nmakeSerializable(Pack, \"webpack/lib/cache/PackFileCacheStrategy\", \"Pack\");\nclass PackContentItems {\n  /**\n   * @param {Map<string, any>} map items\n   */\n  constructor(map) {\n    this.map = map;\n  }\n\n  /**\n   * @param {ObjectSerializerContext & { snapshot: TODO, rollback: TODO, logger: Logger, profile: boolean | undefined  }} context context\n   */\n  serialize({\n    write,\n    snapshot,\n    rollback,\n    logger,\n    profile\n  }) {\n    if (profile) {\n      write(false);\n      for (const [key, value] of this.map) {\n        const s = snapshot();\n        try {\n          write(key);\n          const start = process.hrtime();\n          write(value);\n          const durationHr = process.hrtime(start);\n          const duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n          if (duration > 1) {\n            if (duration > 500) logger.error(`Serialization of '${key}': ${duration} ms`);else if (duration > 50) logger.warn(`Serialization of '${key}': ${duration} ms`);else if (duration > 10) logger.info(`Serialization of '${key}': ${duration} ms`);else if (duration > 5) logger.log(`Serialization of '${key}': ${duration} ms`);else logger.debug(`Serialization of '${key}': ${duration} ms`);\n          }\n        } catch (e) {\n          rollback(s);\n          if (e === NOT_SERIALIZABLE) continue;\n          const msg = \"Skipped not serializable cache item\";\n          if (e.message.includes(\"ModuleBuildError\")) {\n            logger.log(`${msg} (in build error): ${e.message}`);\n            logger.debug(`${msg} '${key}' (in build error): ${e.stack}`);\n          } else {\n            logger.warn(`${msg}: ${e.message}`);\n            logger.debug(`${msg} '${key}': ${e.stack}`);\n          }\n        }\n      }\n      write(null);\n      return;\n    }\n    // Try to serialize all at once\n    const s = snapshot();\n    try {\n      write(true);\n      write(this.map);\n    } catch (e) {\n      rollback(s);\n\n      // Try to serialize each item on it's own\n      write(false);\n      for (const [key, value] of this.map) {\n        const s = snapshot();\n        try {\n          write(key);\n          write(value);\n        } catch (e) {\n          rollback(s);\n          if (e === NOT_SERIALIZABLE) continue;\n          logger.warn(`Skipped not serializable cache item '${key}': ${e.message}`);\n          logger.debug(e.stack);\n        }\n      }\n      write(null);\n    }\n  }\n\n  /**\n   * @param {ObjectDeserializerContext & { logger: Logger, profile: boolean | undefined }} context context\n   */\n  deserialize({\n    read,\n    logger,\n    profile\n  }) {\n    if (read()) {\n      this.map = read();\n    } else if (profile) {\n      const map = new Map();\n      let key = read();\n      while (key !== null) {\n        const start = process.hrtime();\n        const value = read();\n        const durationHr = process.hrtime(start);\n        const duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n        if (duration > 1) {\n          if (duration > 100) logger.error(`Deserialization of '${key}': ${duration} ms`);else if (duration > 20) logger.warn(`Deserialization of '${key}': ${duration} ms`);else if (duration > 5) logger.info(`Deserialization of '${key}': ${duration} ms`);else if (duration > 2) logger.log(`Deserialization of '${key}': ${duration} ms`);else logger.debug(`Deserialization of '${key}': ${duration} ms`);\n        }\n        map.set(key, value);\n        key = read();\n      }\n      this.map = map;\n    } else {\n      const map = new Map();\n      let key = read();\n      while (key !== null) {\n        map.set(key, read());\n        key = read();\n      }\n      this.map = map;\n    }\n  }\n}\nmakeSerializable(PackContentItems, \"webpack/lib/cache/PackFileCacheStrategy\", \"PackContentItems\");\nclass PackContent {\n  /*\n  \tThis class can be in these states:\n  \t   |   this.lazy    | this.content | this.outdated | state\n  \tA1 |   undefined    |     Map      |     false     | fresh content\n  \tA2 |   undefined    |     Map      |     true      | (will not happen)\n  \tB1 | lazy () => {}  |  undefined   |     false     | not deserialized\n  \tB2 | lazy () => {}  |  undefined   |     true      | not deserialized, but some items has been removed\n  \tC1 | lazy* () => {} |     Map      |     false     | deserialized\n  \tC2 | lazy* () => {} |     Map      |     true      | deserialized, and some items has been removed\n  \t\tthis.used is a subset of this.items.\n  \tthis.items is a subset of this.content.keys() resp. this.lazy().map.keys()\n  \tWhen this.outdated === false, this.items === this.content.keys() resp. this.lazy().map.keys()\n  \tWhen this.outdated === true, this.items should be used to recreated this.lazy/this.content.\n  \tWhen this.lazy and this.content is set, they contain the same data.\n  \tthis.get must only be called with a valid item from this.items.\n  \tIn state C this.lazy is unMemoized\n  */\n\n  /**\n   * @param {Items} items keys\n   * @param {Items} usedItems used keys\n   * @param {PackContentItems | function(): Promise<PackContentItems>} dataOrFn sync or async content\n   * @param {Logger=} logger logger for logging\n   * @param {string=} lazyName name of dataOrFn for logging\n   */\n  constructor(items, usedItems, dataOrFn, logger, lazyName) {\n    this.items = items;\n    /** @type {(function(): Promise<PackContentItems> | PackContentItems) | undefined} */\n    this.lazy = typeof dataOrFn === \"function\" ? dataOrFn : undefined;\n    /** @type {Map<string, any> | undefined} */\n    this.content = typeof dataOrFn === \"function\" ? undefined : dataOrFn.map;\n    this.outdated = false;\n    this.used = usedItems;\n    this.logger = logger;\n    this.lazyName = lazyName;\n  }\n\n  /**\n   * @param {string} identifier identifier\n   * @returns {string | Promise<string>} result\n   */\n  get(identifier) {\n    this.used.add(identifier);\n    if (this.content) {\n      return this.content.get(identifier);\n    }\n\n    // We are in state B\n    const {\n      lazyName\n    } = this;\n    /** @type {string | undefined} */\n    let timeMessage;\n    if (lazyName) {\n      // only log once\n      this.lazyName = undefined;\n      timeMessage = `restore cache content ${lazyName} (${formatSize(this.getSize())})`;\n      this.logger.log(`starting to restore cache content ${lazyName} (${formatSize(this.getSize())}) because of request to: ${identifier}`);\n      this.logger.time(timeMessage);\n    }\n    const value = this.lazy();\n    if (\"then\" in value) {\n      return value.then(data => {\n        const map = data.map;\n        if (timeMessage) {\n          this.logger.timeEnd(timeMessage);\n        }\n        // Move to state C\n        this.content = map;\n        this.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n        return map.get(identifier);\n      });\n    } else {\n      const map = value.map;\n      if (timeMessage) {\n        this.logger.timeEnd(timeMessage);\n      }\n      // Move to state C\n      this.content = map;\n      this.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n      return map.get(identifier);\n    }\n  }\n\n  /**\n   * @param {string} reason explanation why unpack is necessary\n   * @returns {void | Promise<void>} maybe a promise if lazy\n   */\n  unpack(reason) {\n    if (this.content) return;\n\n    // Move from state B to C\n    if (this.lazy) {\n      const {\n        lazyName\n      } = this;\n      /** @type {string | undefined} */\n      let timeMessage;\n      if (lazyName) {\n        // only log once\n        this.lazyName = undefined;\n        timeMessage = `unpack cache content ${lazyName} (${formatSize(this.getSize())})`;\n        this.logger.log(`starting to unpack cache content ${lazyName} (${formatSize(this.getSize())}) because ${reason}`);\n        this.logger.time(timeMessage);\n      }\n      const value = this.lazy();\n      if (\"then\" in value) {\n        return value.then(data => {\n          if (timeMessage) {\n            this.logger.timeEnd(timeMessage);\n          }\n          this.content = data.map;\n        });\n      } else {\n        if (timeMessage) {\n          this.logger.timeEnd(timeMessage);\n        }\n        this.content = value.map;\n      }\n    }\n  }\n\n  /**\n   * @returns {number} size of the content or -1 if not known\n   */\n  getSize() {\n    if (!this.lazy) return -1;\n    const options = /** @type {any} */this.lazy.options;\n    if (!options) return -1;\n    const size = options.size;\n    if (typeof size !== \"number\") return -1;\n    return size;\n  }\n\n  /**\n   * @param {string} identifier identifier\n   */\n  delete(identifier) {\n    this.items.delete(identifier);\n    this.used.delete(identifier);\n    this.outdated = true;\n  }\n\n  /**\n   * @template T\n   * @param {function(any): function(): Promise<PackContentItems> | PackContentItems} write write function\n   * @returns {void}\n   */\n  writeLazy(write) {\n    if (!this.outdated && this.lazy) {\n      // State B1 or C1\n      // this.lazy is still the valid deserialized version\n      write(this.lazy);\n      return;\n    }\n    if (!this.outdated && this.content) {\n      // State A1\n      const map = new Map(this.content);\n      // Move to state C1\n      this.lazy = SerializerMiddleware.unMemoizeLazy(write(() => new PackContentItems(map)));\n      return;\n    }\n    if (this.content) {\n      // State A2 or C2\n      /** @type {Map<string, any>} */\n      const map = new Map();\n      for (const item of this.items) {\n        map.set(item, this.content.get(item));\n      }\n      // Move to state C1\n      this.outdated = false;\n      this.content = map;\n      this.lazy = SerializerMiddleware.unMemoizeLazy(write(() => new PackContentItems(map)));\n      return;\n    }\n    // State B2\n    const {\n      lazyName\n    } = this;\n    /** @type {string | undefined} */\n    let timeMessage;\n    if (lazyName) {\n      // only log once\n      this.lazyName = undefined;\n      timeMessage = `unpack cache content ${lazyName} (${formatSize(this.getSize())})`;\n      this.logger.log(`starting to unpack cache content ${lazyName} (${formatSize(this.getSize())}) because it's outdated and need to be serialized`);\n      this.logger.time(timeMessage);\n    }\n    const value = this.lazy();\n    this.outdated = false;\n    if (\"then\" in value) {\n      // Move to state B1\n      this.lazy = write(() => value.then(data => {\n        if (timeMessage) {\n          this.logger.timeEnd(timeMessage);\n        }\n        const oldMap = data.map;\n        /** @type {Map<string, any>} */\n        const map = new Map();\n        for (const item of this.items) {\n          map.set(item, oldMap.get(item));\n        }\n        // Move to state C1 (or maybe C2)\n        this.content = map;\n        this.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n        return new PackContentItems(map);\n      }));\n    } else {\n      // Move to state C1\n      if (timeMessage) {\n        this.logger.timeEnd(timeMessage);\n      }\n      const oldMap = value.map;\n      /** @type {Map<string, any>} */\n      const map = new Map();\n      for (const item of this.items) {\n        map.set(item, oldMap.get(item));\n      }\n      this.content = map;\n      this.lazy = write(() => new PackContentItems(map));\n    }\n  }\n}\n\n/**\n * @param {Buffer} buf buffer\n * @returns {Buffer} buffer that can be collected\n */\nconst allowCollectingMemory = buf => {\n  const wasted = buf.buffer.byteLength - buf.byteLength;\n  if (wasted > 8192 && (wasted > 1048576 || wasted > buf.byteLength)) {\n    return Buffer.from(buf);\n  }\n  return buf;\n};\nclass PackFileCacheStrategy {\n  /**\n   * @param {Object} options options\n   * @param {Compiler} options.compiler the compiler\n   * @param {IntermediateFileSystem} options.fs the filesystem\n   * @param {string} options.context the context directory\n   * @param {string} options.cacheLocation the location of the cache data\n   * @param {string} options.version version identifier\n   * @param {Logger} options.logger a logger\n   * @param {SnapshotOptions} options.snapshot options regarding snapshotting\n   * @param {number} options.maxAge max age of cache items\n   * @param {boolean | undefined} options.profile track and log detailed timing information for individual cache items\n   * @param {boolean | undefined} options.allowCollectingMemory allow to collect unused memory created during deserialization\n   * @param {false | \"gzip\" | \"brotli\" | undefined} options.compression compression used\n   * @param {boolean | undefined} options.readonly disable storing cache into filesystem\n   */\n  constructor({\n    compiler,\n    fs,\n    context,\n    cacheLocation,\n    version,\n    logger,\n    snapshot,\n    maxAge,\n    profile,\n    allowCollectingMemory,\n    compression,\n    readonly\n  }) {\n    this.fileSerializer = createFileSerializer(fs, compiler.options.output.hashFunction);\n    this.fileSystemInfo = new FileSystemInfo(fs, {\n      managedPaths: snapshot.managedPaths,\n      immutablePaths: snapshot.immutablePaths,\n      logger: logger.getChildLogger(\"webpack.FileSystemInfo\"),\n      hashFunction: compiler.options.output.hashFunction\n    });\n    this.compiler = compiler;\n    this.context = context;\n    this.cacheLocation = cacheLocation;\n    this.version = version;\n    this.logger = logger;\n    this.maxAge = maxAge;\n    this.profile = profile;\n    this.readonly = readonly;\n    this.allowCollectingMemory = allowCollectingMemory;\n    this.compression = compression;\n    this._extension = compression === \"brotli\" ? \".pack.br\" : compression === \"gzip\" ? \".pack.gz\" : \".pack\";\n    this.snapshot = snapshot;\n    /** @type {BuildDependencies} */\n    this.buildDependencies = new Set();\n    /** @type {LazySet<string>} */\n    this.newBuildDependencies = new LazySet();\n    /** @type {Snapshot | undefined} */\n    this.resolveBuildDependenciesSnapshot = undefined;\n    /** @type {ResolveResults | undefined} */\n    this.resolveResults = undefined;\n    /** @type {Snapshot | undefined} */\n    this.buildSnapshot = undefined;\n    /** @type {Promise<Pack> | undefined} */\n    this.packPromise = this._openPack();\n    this.storePromise = Promise.resolve();\n  }\n\n  /**\n   * @returns {Promise<Pack>} pack\n   */\n  _getPack() {\n    if (this.packPromise === undefined) {\n      this.packPromise = this.storePromise.then(() => this._openPack());\n    }\n    return this.packPromise;\n  }\n\n  /**\n   * @returns {Promise<Pack>} the pack\n   */\n  _openPack() {\n    const {\n      logger,\n      profile,\n      cacheLocation,\n      version\n    } = this;\n    /** @type {Snapshot} */\n    let buildSnapshot;\n    /** @type {BuildDependencies} */\n    let buildDependencies;\n    /** @type {BuildDependencies} */\n    let newBuildDependencies;\n    /** @type {Snapshot} */\n    let resolveBuildDependenciesSnapshot;\n    /** @type {ResolveResults | undefined} */\n    let resolveResults;\n    logger.time(\"restore cache container\");\n    return this.fileSerializer.deserialize(null, {\n      filename: `${cacheLocation}/index${this._extension}`,\n      extension: `${this._extension}`,\n      logger,\n      profile,\n      retainedBuffer: this.allowCollectingMemory ? allowCollectingMemory : undefined\n    }).catch(err => {\n      if (err.code !== \"ENOENT\") {\n        logger.warn(`Restoring pack failed from ${cacheLocation}${this._extension}: ${err}`);\n        logger.debug(err.stack);\n      } else {\n        logger.debug(`No pack exists at ${cacheLocation}${this._extension}: ${err}`);\n      }\n      return undefined;\n    }).then(packContainer => {\n      logger.timeEnd(\"restore cache container\");\n      if (!packContainer) return undefined;\n      if (!(packContainer instanceof PackContainer)) {\n        logger.warn(`Restored pack from ${cacheLocation}${this._extension}, but contained content is unexpected.`, packContainer);\n        return undefined;\n      }\n      if (packContainer.version !== version) {\n        logger.log(`Restored pack from ${cacheLocation}${this._extension}, but version doesn't match.`);\n        return undefined;\n      }\n      logger.time(\"check build dependencies\");\n      return Promise.all([new Promise((resolve, reject) => {\n        this.fileSystemInfo.checkSnapshotValid(packContainer.buildSnapshot, (err, valid) => {\n          if (err) {\n            logger.log(`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of build dependencies errored: ${err}.`);\n            logger.debug(err.stack);\n            return resolve(false);\n          }\n          if (!valid) {\n            logger.log(`Restored pack from ${cacheLocation}${this._extension}, but build dependencies have changed.`);\n            return resolve(false);\n          }\n          buildSnapshot = packContainer.buildSnapshot;\n          return resolve(true);\n        });\n      }), new Promise((resolve, reject) => {\n        this.fileSystemInfo.checkSnapshotValid(packContainer.resolveBuildDependenciesSnapshot, (err, valid) => {\n          if (err) {\n            logger.log(`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of resolving of build dependencies errored: ${err}.`);\n            logger.debug(err.stack);\n            return resolve(false);\n          }\n          if (valid) {\n            resolveBuildDependenciesSnapshot = packContainer.resolveBuildDependenciesSnapshot;\n            buildDependencies = packContainer.buildDependencies;\n            resolveResults = packContainer.resolveResults;\n            return resolve(true);\n          }\n          logger.log(\"resolving of build dependencies is invalid, will re-resolve build dependencies\");\n          this.fileSystemInfo.checkResolveResultsValid(packContainer.resolveResults, (err, valid) => {\n            if (err) {\n              logger.log(`Restored pack from ${cacheLocation}${this._extension}, but resolving of build dependencies errored: ${err}.`);\n              logger.debug(err.stack);\n              return resolve(false);\n            }\n            if (valid) {\n              newBuildDependencies = packContainer.buildDependencies;\n              resolveResults = packContainer.resolveResults;\n              return resolve(true);\n            }\n            logger.log(`Restored pack from ${cacheLocation}${this._extension}, but build dependencies resolve to different locations.`);\n            return resolve(false);\n          });\n        });\n      })]).catch(err => {\n        logger.timeEnd(\"check build dependencies\");\n        throw err;\n      }).then(([buildSnapshotValid, resolveValid]) => {\n        logger.timeEnd(\"check build dependencies\");\n        if (buildSnapshotValid && resolveValid) {\n          logger.time(\"restore cache content metadata\");\n          const d = packContainer.data();\n          logger.timeEnd(\"restore cache content metadata\");\n          return d;\n        }\n        return undefined;\n      });\n    }).then(pack => {\n      if (pack) {\n        pack.maxAge = this.maxAge;\n        this.buildSnapshot = buildSnapshot;\n        if (buildDependencies) this.buildDependencies = buildDependencies;\n        if (newBuildDependencies) this.newBuildDependencies.addAll(newBuildDependencies);\n        this.resolveResults = resolveResults;\n        this.resolveBuildDependenciesSnapshot = resolveBuildDependenciesSnapshot;\n        return pack;\n      }\n      return new Pack(logger, this.maxAge);\n    }).catch(err => {\n      this.logger.warn(`Restoring pack from ${cacheLocation}${this._extension} failed: ${err}`);\n      this.logger.debug(err.stack);\n      return new Pack(logger, this.maxAge);\n    });\n  }\n\n  /**\n   * @param {string} identifier unique name for the resource\n   * @param {Etag | null} etag etag of the resource\n   * @param {any} data cached content\n   * @returns {Promise<void>} promise\n   */\n  store(identifier, etag, data) {\n    if (this.readonly) return Promise.resolve();\n    return this._getPack().then(pack => {\n      pack.set(identifier, etag === null ? null : etag.toString(), data);\n    });\n  }\n\n  /**\n   * @param {string} identifier unique name for the resource\n   * @param {Etag | null} etag etag of the resource\n   * @returns {Promise<any>} promise to the cached content\n   */\n  restore(identifier, etag) {\n    return this._getPack().then(pack => pack.get(identifier, etag === null ? null : etag.toString())).catch(err => {\n      if (err && err.code !== \"ENOENT\") {\n        this.logger.warn(`Restoring failed for ${identifier} from pack: ${err}`);\n        this.logger.debug(err.stack);\n      }\n    });\n  }\n\n  /**\n   * @param {LazySet<string> | Iterable<string>} dependencies dependencies to store\n   */\n  storeBuildDependencies(dependencies) {\n    if (this.readonly) return;\n    this.newBuildDependencies.addAll(dependencies);\n  }\n  afterAllStored() {\n    const packPromise = this.packPromise;\n    if (packPromise === undefined) return Promise.resolve();\n    const reportProgress = ProgressPlugin.getReporter(this.compiler);\n    return this.storePromise = packPromise.then(pack => {\n      pack.stopCapturingRequests();\n      if (!pack.invalid) return;\n      this.packPromise = undefined;\n      this.logger.log(`Storing pack...`);\n      let promise;\n      const newBuildDependencies = new Set();\n      for (const dep of this.newBuildDependencies) {\n        if (!this.buildDependencies.has(dep)) {\n          newBuildDependencies.add(dep);\n        }\n      }\n      if (newBuildDependencies.size > 0 || !this.buildSnapshot) {\n        if (reportProgress) reportProgress(0.5, \"resolve build dependencies\");\n        this.logger.debug(`Capturing build dependencies... (${Array.from(newBuildDependencies).join(\", \")})`);\n        promise = new Promise((resolve, reject) => {\n          this.logger.time(\"resolve build dependencies\");\n          this.fileSystemInfo.resolveBuildDependencies(this.context, newBuildDependencies, (err, result) => {\n            this.logger.timeEnd(\"resolve build dependencies\");\n            if (err) return reject(err);\n            this.logger.time(\"snapshot build dependencies\");\n            const {\n              files,\n              directories,\n              missing,\n              resolveResults,\n              resolveDependencies\n            } = /** @type {ResolveBuildDependenciesResult} */result;\n            if (this.resolveResults) {\n              for (const [key, value] of resolveResults) {\n                this.resolveResults.set(key, value);\n              }\n            } else {\n              this.resolveResults = resolveResults;\n            }\n            if (reportProgress) {\n              reportProgress(0.6, \"snapshot build dependencies\", \"resolving\");\n            }\n            this.fileSystemInfo.createSnapshot(undefined, resolveDependencies.files, resolveDependencies.directories, resolveDependencies.missing, this.snapshot.resolveBuildDependencies, (err, snapshot) => {\n              if (err) {\n                this.logger.timeEnd(\"snapshot build dependencies\");\n                return reject(err);\n              }\n              if (!snapshot) {\n                this.logger.timeEnd(\"snapshot build dependencies\");\n                return reject(new Error(\"Unable to snapshot resolve dependencies\"));\n              }\n              if (this.resolveBuildDependenciesSnapshot) {\n                this.resolveBuildDependenciesSnapshot = this.fileSystemInfo.mergeSnapshots(this.resolveBuildDependenciesSnapshot, snapshot);\n              } else {\n                this.resolveBuildDependenciesSnapshot = snapshot;\n              }\n              if (reportProgress) {\n                reportProgress(0.7, \"snapshot build dependencies\", \"modules\");\n              }\n              this.fileSystemInfo.createSnapshot(undefined, files, directories, missing, this.snapshot.buildDependencies, (err, snapshot) => {\n                this.logger.timeEnd(\"snapshot build dependencies\");\n                if (err) return reject(err);\n                if (!snapshot) {\n                  return reject(new Error(\"Unable to snapshot build dependencies\"));\n                }\n                this.logger.debug(\"Captured build dependencies\");\n                if (this.buildSnapshot) {\n                  this.buildSnapshot = this.fileSystemInfo.mergeSnapshots(this.buildSnapshot, snapshot);\n                } else {\n                  this.buildSnapshot = snapshot;\n                }\n                resolve();\n              });\n            });\n          });\n        });\n      } else {\n        promise = Promise.resolve();\n      }\n      return promise.then(() => {\n        if (reportProgress) reportProgress(0.8, \"serialize pack\");\n        this.logger.time(`store pack`);\n        const updatedBuildDependencies = new Set(this.buildDependencies);\n        for (const dep of newBuildDependencies) {\n          updatedBuildDependencies.add(dep);\n        }\n        const content = new PackContainer(pack, this.version, /** @type {Snapshot} */this.buildSnapshot, updatedBuildDependencies, this.resolveResults, this.resolveBuildDependenciesSnapshot);\n        return this.fileSerializer.serialize(content, {\n          filename: `${this.cacheLocation}/index${this._extension}`,\n          extension: `${this._extension}`,\n          logger: this.logger,\n          profile: this.profile\n        }).then(() => {\n          for (const dep of newBuildDependencies) {\n            this.buildDependencies.add(dep);\n          }\n          this.newBuildDependencies.clear();\n          this.logger.timeEnd(`store pack`);\n          const stats = pack.getContentStats();\n          this.logger.log(\"Stored pack (%d items, %d files, %d MiB)\", pack.itemInfo.size, stats.count, Math.round(stats.size / 1024 / 1024));\n        }).catch(err => {\n          this.logger.timeEnd(`store pack`);\n          this.logger.warn(`Caching failed for pack: ${err}`);\n          this.logger.debug(err.stack);\n        });\n      });\n    }).catch(err => {\n      this.logger.warn(`Caching failed for pack: ${err}`);\n      this.logger.debug(err.stack);\n    });\n  }\n  clear() {\n    this.fileSystemInfo.clear();\n    this.buildDependencies.clear();\n    this.newBuildDependencies.clear();\n    this.resolveBuildDependenciesSnapshot = undefined;\n    this.resolveResults = undefined;\n    this.buildSnapshot = undefined;\n    this.packPromise = undefined;\n  }\n}\nmodule.exports = PackFileCacheStrategy;","map":{"version":3,"names":["FileSystemInfo","require","ProgressPlugin","formatSize","SerializerMiddleware","LazySet","makeSerializable","memoize","createFileSerializer","NOT_SERIALIZABLE","PackContainer","constructor","data","version","buildSnapshot","buildDependencies","resolveResults","resolveBuildDependenciesSnapshot","serialize","write","writeLazy","deserialize","read","MIN_CONTENT_SIZE","CONTENT_COUNT_TO_MERGE","MIN_ITEMS_IN_FRESH_PACK","MAX_ITEMS_IN_FRESH_PACK","MAX_TIME_IN_FRESH_PACK","PackItemInfo","identifier","etag","value","location","lastAccess","Date","now","freshValue","Pack","logger","maxAge","itemInfo","Map","requests","requestsTimeout","undefined","freshContent","content","invalid","_addRequest","push","setTimeout","unref","stopCapturingRequests","clearTimeout","get","info","loc","set","log","newInfo","delete","items","size","debug","getContentStats","count","s","getSize","_findLocation","i","length","_gcAndUpdateLocation","usedItems","newLoc","lastGC","_persistFreshContent","itemsCount","packCount","Math","ceil","itemsPerPack","packs","ignoreNextTimeTick","createNextPack","pack","Set","map","add","PackContent","PackContentItems","join","_optimizeSmallContent","smallUsedContents","smallUsedContentSize","smallUnusedContents","smallUnusedContentSize","outdated","used","mergedIndices","mergedContent","mergedItems","mergedUsedItems","addToMergedMap","unpack","Promise","all","fn","_optimizeUnusedContent","total","unusedItems","usedOfUnusedItems","newUnusedLoc","_gcOldestContent","oldest","values","writeSeparate","keys","lazy","name","item","clear","infoItems","idx","snapshot","rollback","profile","key","start","process","hrtime","durationHr","duration","error","warn","e","msg","message","includes","stack","dataOrFn","lazyName","timeMessage","time","then","timeEnd","unMemoizeLazy","reason","options","oldMap","allowCollectingMemory","buf","wasted","buffer","byteLength","Buffer","from","PackFileCacheStrategy","compiler","fs","context","cacheLocation","compression","readonly","fileSerializer","output","hashFunction","fileSystemInfo","managedPaths","immutablePaths","getChildLogger","_extension","newBuildDependencies","packPromise","_openPack","storePromise","resolve","_getPack","filename","extension","retainedBuffer","catch","err","code","packContainer","reject","checkSnapshotValid","valid","checkResolveResultsValid","buildSnapshotValid","resolveValid","d","addAll","store","toString","restore","storeBuildDependencies","dependencies","afterAllStored","reportProgress","getReporter","promise","dep","has","Array","resolveBuildDependencies","result","files","directories","missing","resolveDependencies","createSnapshot","Error","mergeSnapshots","updatedBuildDependencies","stats","round","module","exports"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/cache/PackFileCacheStrategy.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst FileSystemInfo = require(\"../FileSystemInfo\");\nconst ProgressPlugin = require(\"../ProgressPlugin\");\nconst { formatSize } = require(\"../SizeFormatHelpers\");\nconst SerializerMiddleware = require(\"../serialization/SerializerMiddleware\");\nconst LazySet = require(\"../util/LazySet\");\nconst makeSerializable = require(\"../util/makeSerializable\");\nconst memoize = require(\"../util/memoize\");\nconst {\n\tcreateFileSerializer,\n\tNOT_SERIALIZABLE\n} = require(\"../util/serialization\");\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").SnapshotOptions} SnapshotOptions */\n/** @typedef {import(\"../Cache\").Etag} Etag */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../FileSystemInfo\").ResolveBuildDependenciesResult} ResolveBuildDependenciesResult */\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n/** @typedef {import(\"../logging/Logger\").Logger} Logger */\n/** @typedef {import(\"../serialization/ObjectMiddleware\").ObjectDeserializerContext} ObjectDeserializerContext */\n/** @typedef {import(\"../serialization/ObjectMiddleware\").ObjectSerializerContext} ObjectSerializerContext */\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\n/** @typedef {Map<string, string | false>} ResolveResults */\n/** @typedef {Set<string>} Items */\n/** @typedef {Set<string>} BuildDependencies */\n/** @typedef {Map<string, PackItemInfo>} ItemInfo */\n\nclass PackContainer {\n\t/**\n\t * @param {Object} data stored data\n\t * @param {string} version version identifier\n\t * @param {Snapshot} buildSnapshot snapshot of all build dependencies\n\t * @param {BuildDependencies} buildDependencies list of all unresolved build dependencies captured\n\t * @param {ResolveResults} resolveResults result of the resolved build dependencies\n\t * @param {Snapshot} resolveBuildDependenciesSnapshot snapshot of the dependencies of the build dependencies resolving\n\t */\n\tconstructor(\n\t\tdata,\n\t\tversion,\n\t\tbuildSnapshot,\n\t\tbuildDependencies,\n\t\tresolveResults,\n\t\tresolveBuildDependenciesSnapshot\n\t) {\n\t\tthis.data = data;\n\t\tthis.version = version;\n\t\tthis.buildSnapshot = buildSnapshot;\n\t\tthis.buildDependencies = buildDependencies;\n\t\tthis.resolveResults = resolveResults;\n\t\tthis.resolveBuildDependenciesSnapshot = resolveBuildDependenciesSnapshot;\n\t}\n\n\t/**\n\t * @param {ObjectSerializerContext} context context\n\t */\n\tserialize({ write, writeLazy }) {\n\t\twrite(this.version);\n\t\twrite(this.buildSnapshot);\n\t\twrite(this.buildDependencies);\n\t\twrite(this.resolveResults);\n\t\twrite(this.resolveBuildDependenciesSnapshot);\n\t\t/** @type {NonNullable<ObjectSerializerContext[\"writeLazy\"]>} */\n\t\t(writeLazy)(this.data);\n\t}\n\n\t/**\n\t * @param {ObjectDeserializerContext} context context\n\t */\n\tdeserialize({ read }) {\n\t\tthis.version = read();\n\t\tthis.buildSnapshot = read();\n\t\tthis.buildDependencies = read();\n\t\tthis.resolveResults = read();\n\t\tthis.resolveBuildDependenciesSnapshot = read();\n\t\tthis.data = read();\n\t}\n}\n\nmakeSerializable(\n\tPackContainer,\n\t\"webpack/lib/cache/PackFileCacheStrategy\",\n\t\"PackContainer\"\n);\n\nconst MIN_CONTENT_SIZE = 1024 * 1024; // 1 MB\nconst CONTENT_COUNT_TO_MERGE = 10;\nconst MIN_ITEMS_IN_FRESH_PACK = 100;\nconst MAX_ITEMS_IN_FRESH_PACK = 50000;\nconst MAX_TIME_IN_FRESH_PACK = 1 * 60 * 1000; // 1 min\n\nclass PackItemInfo {\n\t/**\n\t * @param {string} identifier identifier of item\n\t * @param {string | null} etag etag of item\n\t * @param {any} value fresh value of item\n\t */\n\tconstructor(identifier, etag, value) {\n\t\tthis.identifier = identifier;\n\t\tthis.etag = etag;\n\t\tthis.location = -1;\n\t\tthis.lastAccess = Date.now();\n\t\tthis.freshValue = value;\n\t}\n}\n\nclass Pack {\n\t/**\n\t * @param {Logger} logger a logger\n\t * @param {number} maxAge max age of cache items\n\t */\n\tconstructor(logger, maxAge) {\n\t\t/** @type {ItemInfo} */\n\t\tthis.itemInfo = new Map();\n\t\t/** @type {(string | undefined)[]} */\n\t\tthis.requests = [];\n\t\tthis.requestsTimeout = undefined;\n\t\t/** @type {ItemInfo} */\n\t\tthis.freshContent = new Map();\n\t\t/** @type {(undefined | PackContent)[]} */\n\t\tthis.content = [];\n\t\tthis.invalid = false;\n\t\tthis.logger = logger;\n\t\tthis.maxAge = maxAge;\n\t}\n\n\t/**\n\t * @param {string} identifier identifier\n\t */\n\t_addRequest(identifier) {\n\t\tthis.requests.push(identifier);\n\t\tif (this.requestsTimeout === undefined) {\n\t\t\tthis.requestsTimeout = setTimeout(() => {\n\t\t\t\tthis.requests.push(undefined);\n\t\t\t\tthis.requestsTimeout = undefined;\n\t\t\t}, MAX_TIME_IN_FRESH_PACK);\n\t\t\tif (this.requestsTimeout.unref) this.requestsTimeout.unref();\n\t\t}\n\t}\n\n\tstopCapturingRequests() {\n\t\tif (this.requestsTimeout !== undefined) {\n\t\t\tclearTimeout(this.requestsTimeout);\n\t\t\tthis.requestsTimeout = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} identifier unique name for the resource\n\t * @param {string | null} etag etag of the resource\n\t * @returns {any} cached content\n\t */\n\tget(identifier, etag) {\n\t\tconst info = this.itemInfo.get(identifier);\n\t\tthis._addRequest(identifier);\n\t\tif (info === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (info.etag !== etag) return null;\n\t\tinfo.lastAccess = Date.now();\n\t\tconst loc = info.location;\n\t\tif (loc === -1) {\n\t\t\treturn info.freshValue;\n\t\t} else {\n\t\t\tif (!this.content[loc]) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\treturn /** @type {PackContent} */ (this.content[loc]).get(identifier);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} identifier unique name for the resource\n\t * @param {string | null} etag etag of the resource\n\t * @param {any} data cached content\n\t * @returns {void}\n\t */\n\tset(identifier, etag, data) {\n\t\tif (!this.invalid) {\n\t\t\tthis.invalid = true;\n\t\t\tthis.logger.log(`Pack got invalid because of write to: ${identifier}`);\n\t\t}\n\t\tconst info = this.itemInfo.get(identifier);\n\t\tif (info === undefined) {\n\t\t\tconst newInfo = new PackItemInfo(identifier, etag, data);\n\t\t\tthis.itemInfo.set(identifier, newInfo);\n\t\t\tthis._addRequest(identifier);\n\t\t\tthis.freshContent.set(identifier, newInfo);\n\t\t} else {\n\t\t\tconst loc = info.location;\n\t\t\tif (loc >= 0) {\n\t\t\t\tthis._addRequest(identifier);\n\t\t\t\tthis.freshContent.set(identifier, info);\n\t\t\t\tconst content = /** @type {PackContent} */ (this.content[loc]);\n\t\t\t\tcontent.delete(identifier);\n\t\t\t\tif (content.items.size === 0) {\n\t\t\t\t\tthis.content[loc] = undefined;\n\t\t\t\t\tthis.logger.debug(\"Pack %d got empty and is removed\", loc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tinfo.freshValue = data;\n\t\t\tinfo.lastAccess = Date.now();\n\t\t\tinfo.etag = etag;\n\t\t\tinfo.location = -1;\n\t\t}\n\t}\n\n\tgetContentStats() {\n\t\tlet count = 0;\n\t\tlet size = 0;\n\t\tfor (const content of this.content) {\n\t\t\tif (content !== undefined) {\n\t\t\t\tcount++;\n\t\t\t\tconst s = content.getSize();\n\t\t\t\tif (s > 0) {\n\t\t\t\t\tsize += s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { count, size };\n\t}\n\n\t/**\n\t * @returns {number} new location of data entries\n\t */\n\t_findLocation() {\n\t\tlet i;\n\t\tfor (i = 0; i < this.content.length && this.content[i] !== undefined; i++);\n\t\treturn i;\n\t}\n\n\t/**\n\t * @private\n\t * @param {Items} items items\n\t * @param {Items} usedItems used items\n\t * @param {number} newLoc new location\n\t */\n\t_gcAndUpdateLocation(items, usedItems, newLoc) {\n\t\tlet count = 0;\n\t\tlet lastGC;\n\t\tconst now = Date.now();\n\t\tfor (const identifier of items) {\n\t\t\tconst info = /** @type {PackItemInfo} */ (this.itemInfo.get(identifier));\n\t\t\tif (now - info.lastAccess > this.maxAge) {\n\t\t\t\tthis.itemInfo.delete(identifier);\n\t\t\t\titems.delete(identifier);\n\t\t\t\tusedItems.delete(identifier);\n\t\t\t\tcount++;\n\t\t\t\tlastGC = identifier;\n\t\t\t} else {\n\t\t\t\tinfo.location = newLoc;\n\t\t\t}\n\t\t}\n\t\tif (count > 0) {\n\t\t\tthis.logger.log(\n\t\t\t\t\"Garbage Collected %d old items at pack %d (%d items remaining) e. g. %s\",\n\t\t\t\tcount,\n\t\t\t\tnewLoc,\n\t\t\t\titems.size,\n\t\t\t\tlastGC\n\t\t\t);\n\t\t}\n\t}\n\n\t_persistFreshContent() {\n\t\tconst itemsCount = this.freshContent.size;\n\t\tif (itemsCount > 0) {\n\t\t\tconst packCount = Math.ceil(itemsCount / MAX_ITEMS_IN_FRESH_PACK);\n\t\t\tconst itemsPerPack = Math.ceil(itemsCount / packCount);\n\t\t\tconst packs = [];\n\t\t\tlet i = 0;\n\t\t\tlet ignoreNextTimeTick = false;\n\t\t\tconst createNextPack = () => {\n\t\t\t\tconst loc = this._findLocation();\n\t\t\t\tthis.content[loc] = null; // reserve\n\t\t\t\tconst pack = {\n\t\t\t\t\t/** @type {Items} */\n\t\t\t\t\titems: new Set(),\n\t\t\t\t\t/** @type {Map<string, any>} */\n\t\t\t\t\tmap: new Map(),\n\t\t\t\t\tloc\n\t\t\t\t};\n\t\t\t\tpacks.push(pack);\n\t\t\t\treturn pack;\n\t\t\t};\n\t\t\tlet pack = createNextPack();\n\t\t\tif (this.requestsTimeout !== undefined)\n\t\t\t\tclearTimeout(this.requestsTimeout);\n\t\t\tfor (const identifier of this.requests) {\n\t\t\t\tif (identifier === undefined) {\n\t\t\t\t\tif (ignoreNextTimeTick) {\n\t\t\t\t\t\tignoreNextTimeTick = false;\n\t\t\t\t\t} else if (pack.items.size >= MIN_ITEMS_IN_FRESH_PACK) {\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\tpack = createNextPack();\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst info = this.freshContent.get(identifier);\n\t\t\t\tif (info === undefined) continue;\n\t\t\t\tpack.items.add(identifier);\n\t\t\t\tpack.map.set(identifier, info.freshValue);\n\t\t\t\tinfo.location = pack.loc;\n\t\t\t\tinfo.freshValue = undefined;\n\t\t\t\tthis.freshContent.delete(identifier);\n\t\t\t\tif (++i > itemsPerPack) {\n\t\t\t\t\ti = 0;\n\t\t\t\t\tpack = createNextPack();\n\t\t\t\t\tignoreNextTimeTick = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.requests.length = 0;\n\t\t\tfor (const pack of packs) {\n\t\t\t\tthis.content[pack.loc] = new PackContent(\n\t\t\t\t\tpack.items,\n\t\t\t\t\tnew Set(pack.items),\n\t\t\t\t\tnew PackContentItems(pack.map)\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.logger.log(\n\t\t\t\t`${itemsCount} fresh items in cache put into pack ${\n\t\t\t\t\tpacks.length > 1\n\t\t\t\t\t\t? packs\n\t\t\t\t\t\t\t\t.map(pack => `${pack.loc} (${pack.items.size} items)`)\n\t\t\t\t\t\t\t\t.join(\", \")\n\t\t\t\t\t\t: packs[0].loc\n\t\t\t\t}`\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Merges small content files to a single content file\n\t */\n\t_optimizeSmallContent() {\n\t\t// 1. Find all small content files\n\t\t// Treat unused content files separately to avoid\n\t\t// a merge-split cycle\n\t\t/** @type {number[]} */\n\t\tconst smallUsedContents = [];\n\t\t/** @type {number} */\n\t\tlet smallUsedContentSize = 0;\n\t\t/** @type {number[]} */\n\t\tconst smallUnusedContents = [];\n\t\t/** @type {number} */\n\t\tlet smallUnusedContentSize = 0;\n\t\tfor (let i = 0; i < this.content.length; i++) {\n\t\t\tconst content = this.content[i];\n\t\t\tif (content === undefined) continue;\n\t\t\tif (content.outdated) continue;\n\t\t\tconst size = content.getSize();\n\t\t\tif (size < 0 || size > MIN_CONTENT_SIZE) continue;\n\t\t\tif (content.used.size > 0) {\n\t\t\t\tsmallUsedContents.push(i);\n\t\t\t\tsmallUsedContentSize += size;\n\t\t\t} else {\n\t\t\t\tsmallUnusedContents.push(i);\n\t\t\t\tsmallUnusedContentSize += size;\n\t\t\t}\n\t\t}\n\n\t\t// 2. Check if minimum number is reached\n\t\tlet mergedIndices;\n\t\tif (\n\t\t\tsmallUsedContents.length >= CONTENT_COUNT_TO_MERGE ||\n\t\t\tsmallUsedContentSize > MIN_CONTENT_SIZE\n\t\t) {\n\t\t\tmergedIndices = smallUsedContents;\n\t\t} else if (\n\t\t\tsmallUnusedContents.length >= CONTENT_COUNT_TO_MERGE ||\n\t\t\tsmallUnusedContentSize > MIN_CONTENT_SIZE\n\t\t) {\n\t\t\tmergedIndices = smallUnusedContents;\n\t\t} else return;\n\n\t\t/** @type {PackContent[] } */\n\t\tconst mergedContent = [];\n\n\t\t// 3. Remove old content entries\n\t\tfor (const i of mergedIndices) {\n\t\t\tmergedContent.push(/** @type {PackContent} */ (this.content[i]));\n\t\t\tthis.content[i] = undefined;\n\t\t}\n\n\t\t// 4. Determine merged items\n\t\t/** @type {Items} */\n\t\tconst mergedItems = new Set();\n\t\t/** @type {Items} */\n\t\tconst mergedUsedItems = new Set();\n\t\t/** @type {(function(Map<string, any>): Promise<void>)[]} */\n\t\tconst addToMergedMap = [];\n\t\tfor (const content of mergedContent) {\n\t\t\tfor (const identifier of content.items) {\n\t\t\t\tmergedItems.add(identifier);\n\t\t\t}\n\t\t\tfor (const identifier of content.used) {\n\t\t\t\tmergedUsedItems.add(identifier);\n\t\t\t}\n\t\t\taddToMergedMap.push(async map => {\n\t\t\t\t// unpack existing content\n\t\t\t\t// after that values are accessible in .content\n\t\t\t\tawait content.unpack(\n\t\t\t\t\t\"it should be merged with other small pack contents\"\n\t\t\t\t);\n\t\t\t\tfor (const [identifier, value] of content.content) {\n\t\t\t\t\tmap.set(identifier, value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// 5. GC and update location of merged items\n\t\tconst newLoc = this._findLocation();\n\t\tthis._gcAndUpdateLocation(mergedItems, mergedUsedItems, newLoc);\n\n\t\t// 6. If not empty, store content somewhere\n\t\tif (mergedItems.size > 0) {\n\t\t\tthis.content[newLoc] = new PackContent(\n\t\t\t\tmergedItems,\n\t\t\t\tmergedUsedItems,\n\t\t\t\tmemoize(async () => {\n\t\t\t\t\t/** @type {Map<string, any>} */\n\t\t\t\t\tconst map = new Map();\n\t\t\t\t\tawait Promise.all(addToMergedMap.map(fn => fn(map)));\n\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.logger.log(\n\t\t\t\t\"Merged %d small files with %d cache items into pack %d\",\n\t\t\t\tmergedContent.length,\n\t\t\t\tmergedItems.size,\n\t\t\t\tnewLoc\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Split large content files with used and unused items\n\t * into two parts to separate used from unused items\n\t */\n\t_optimizeUnusedContent() {\n\t\t// 1. Find a large content file with used and unused items\n\t\tfor (let i = 0; i < this.content.length; i++) {\n\t\t\tconst content = this.content[i];\n\t\t\tif (content === undefined) continue;\n\t\t\tconst size = content.getSize();\n\t\t\tif (size < MIN_CONTENT_SIZE) continue;\n\t\t\tconst used = content.used.size;\n\t\t\tconst total = content.items.size;\n\t\t\tif (used > 0 && used < total) {\n\t\t\t\t// 2. Remove this content\n\t\t\t\tthis.content[i] = undefined;\n\n\t\t\t\t// 3. Determine items for the used content file\n\t\t\t\tconst usedItems = new Set(content.used);\n\t\t\t\tconst newLoc = this._findLocation();\n\t\t\t\tthis._gcAndUpdateLocation(usedItems, usedItems, newLoc);\n\n\t\t\t\t// 4. Create content file for used items\n\t\t\t\tif (usedItems.size > 0) {\n\t\t\t\t\tthis.content[newLoc] = new PackContent(\n\t\t\t\t\t\tusedItems,\n\t\t\t\t\t\tnew Set(usedItems),\n\t\t\t\t\t\tasync () => {\n\t\t\t\t\t\t\tawait content.unpack(\n\t\t\t\t\t\t\t\t\"it should be splitted into used and unused items\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst map = new Map();\n\t\t\t\t\t\t\tfor (const identifier of usedItems) {\n\t\t\t\t\t\t\t\tmap.set(identifier, content.content.get(identifier));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// 5. Determine items for the unused content file\n\t\t\t\tconst unusedItems = new Set(content.items);\n\t\t\t\tconst usedOfUnusedItems = new Set();\n\t\t\t\tfor (const identifier of usedItems) {\n\t\t\t\t\tunusedItems.delete(identifier);\n\t\t\t\t}\n\t\t\t\tconst newUnusedLoc = this._findLocation();\n\t\t\t\tthis._gcAndUpdateLocation(unusedItems, usedOfUnusedItems, newUnusedLoc);\n\n\t\t\t\t// 6. Create content file for unused items\n\t\t\t\tif (unusedItems.size > 0) {\n\t\t\t\t\tthis.content[newUnusedLoc] = new PackContent(\n\t\t\t\t\t\tunusedItems,\n\t\t\t\t\t\tusedOfUnusedItems,\n\t\t\t\t\t\tasync () => {\n\t\t\t\t\t\t\tawait content.unpack(\n\t\t\t\t\t\t\t\t\"it should be splitted into used and unused items\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst map = new Map();\n\t\t\t\t\t\t\tfor (const identifier of unusedItems) {\n\t\t\t\t\t\t\t\tmap.set(identifier, content.content.get(identifier));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthis.logger.log(\n\t\t\t\t\t\"Split pack %d into pack %d with %d used items and pack %d with %d unused items\",\n\t\t\t\t\ti,\n\t\t\t\t\tnewLoc,\n\t\t\t\t\tusedItems.size,\n\t\t\t\t\tnewUnusedLoc,\n\t\t\t\t\tunusedItems.size\n\t\t\t\t);\n\n\t\t\t\t// optimizing only one of them is good enough and\n\t\t\t\t// reduces the amount of serialization needed\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Find the content with the oldest item and run GC on that.\n\t * Only runs for one content to avoid large invalidation.\n\t */\n\t_gcOldestContent() {\n\t\t/** @type {PackItemInfo | undefined} */\n\t\tlet oldest = undefined;\n\t\tfor (const info of this.itemInfo.values()) {\n\t\t\tif (oldest === undefined || info.lastAccess < oldest.lastAccess) {\n\t\t\t\toldest = info;\n\t\t\t}\n\t\t}\n\t\tif (\n\t\t\tDate.now() - /** @type {PackItemInfo} */ (oldest).lastAccess >\n\t\t\tthis.maxAge\n\t\t) {\n\t\t\tconst loc = /** @type {PackItemInfo} */ (oldest).location;\n\t\t\tif (loc < 0) return;\n\t\t\tconst content = /** @type {PackContent} */ (this.content[loc]);\n\t\t\tconst items = new Set(content.items);\n\t\t\tconst usedItems = new Set(content.used);\n\t\t\tthis._gcAndUpdateLocation(items, usedItems, loc);\n\n\t\t\tthis.content[loc] =\n\t\t\t\titems.size > 0\n\t\t\t\t\t? new PackContent(items, usedItems, async () => {\n\t\t\t\t\t\t\tawait content.unpack(\n\t\t\t\t\t\t\t\t\"it contains old items that should be garbage collected\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst map = new Map();\n\t\t\t\t\t\t\tfor (const identifier of items) {\n\t\t\t\t\t\t\t\tmap.set(identifier, content.content.get(identifier));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t\t\t})\n\t\t\t\t\t: undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {ObjectSerializerContext} context context\n\t */\n\tserialize({ write, writeSeparate }) {\n\t\tthis._persistFreshContent();\n\t\tthis._optimizeSmallContent();\n\t\tthis._optimizeUnusedContent();\n\t\tthis._gcOldestContent();\n\t\tfor (const identifier of this.itemInfo.keys()) {\n\t\t\twrite(identifier);\n\t\t}\n\t\twrite(null); // null as marker of the end of keys\n\t\tfor (const info of this.itemInfo.values()) {\n\t\t\twrite(info.etag);\n\t\t}\n\t\tfor (const info of this.itemInfo.values()) {\n\t\t\twrite(info.lastAccess);\n\t\t}\n\t\tfor (let i = 0; i < this.content.length; i++) {\n\t\t\tconst content = this.content[i];\n\t\t\tif (content !== undefined) {\n\t\t\t\twrite(content.items);\n\t\t\t\tcontent.writeLazy(lazy => writeSeparate(lazy, { name: `${i}` }));\n\t\t\t} else {\n\t\t\t\twrite(undefined); // undefined marks an empty content slot\n\t\t\t}\n\t\t}\n\t\twrite(null); // null as marker of the end of items\n\t}\n\n\t/**\n\t * @param {ObjectDeserializerContext & { logger: Logger }} context context\n\t */\n\tdeserialize({ read, logger }) {\n\t\tthis.logger = logger;\n\t\t{\n\t\t\tconst items = [];\n\t\t\tlet item = read();\n\t\t\twhile (item !== null) {\n\t\t\t\titems.push(item);\n\t\t\t\titem = read();\n\t\t\t}\n\t\t\tthis.itemInfo.clear();\n\t\t\tconst infoItems = items.map(identifier => {\n\t\t\t\tconst info = new PackItemInfo(identifier, undefined, undefined);\n\t\t\t\tthis.itemInfo.set(identifier, info);\n\t\t\t\treturn info;\n\t\t\t});\n\t\t\tfor (const info of infoItems) {\n\t\t\t\tinfo.etag = read();\n\t\t\t}\n\t\t\tfor (const info of infoItems) {\n\t\t\t\tinfo.lastAccess = read();\n\t\t\t}\n\t\t}\n\t\tthis.content.length = 0;\n\t\tlet items = read();\n\t\twhile (items !== null) {\n\t\t\tif (items === undefined) {\n\t\t\t\tthis.content.push(items);\n\t\t\t} else {\n\t\t\t\tconst idx = this.content.length;\n\t\t\t\tconst lazy = read();\n\t\t\t\tthis.content.push(\n\t\t\t\t\tnew PackContent(\n\t\t\t\t\t\titems,\n\t\t\t\t\t\tnew Set(),\n\t\t\t\t\t\tlazy,\n\t\t\t\t\t\tlogger,\n\t\t\t\t\t\t`${this.content.length}`\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\tfor (const identifier of items) {\n\t\t\t\t\tthis.itemInfo.get(identifier).location = idx;\n\t\t\t\t}\n\t\t\t}\n\t\t\titems = read();\n\t\t}\n\t}\n}\n\nmakeSerializable(Pack, \"webpack/lib/cache/PackFileCacheStrategy\", \"Pack\");\n\nclass PackContentItems {\n\t/**\n\t * @param {Map<string, any>} map items\n\t */\n\tconstructor(map) {\n\t\tthis.map = map;\n\t}\n\n\t/**\n\t * @param {ObjectSerializerContext & { snapshot: TODO, rollback: TODO, logger: Logger, profile: boolean | undefined  }} context context\n\t */\n\tserialize({ write, snapshot, rollback, logger, profile }) {\n\t\tif (profile) {\n\t\t\twrite(false);\n\t\t\tfor (const [key, value] of this.map) {\n\t\t\t\tconst s = snapshot();\n\t\t\t\ttry {\n\t\t\t\t\twrite(key);\n\t\t\t\t\tconst start = process.hrtime();\n\t\t\t\t\twrite(value);\n\t\t\t\t\tconst durationHr = process.hrtime(start);\n\t\t\t\t\tconst duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n\t\t\t\t\tif (duration > 1) {\n\t\t\t\t\t\tif (duration > 500)\n\t\t\t\t\t\t\tlogger.error(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t\telse if (duration > 50)\n\t\t\t\t\t\t\tlogger.warn(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t\telse if (duration > 10)\n\t\t\t\t\t\t\tlogger.info(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t\telse if (duration > 5)\n\t\t\t\t\t\t\tlogger.log(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t\telse logger.debug(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\trollback(s);\n\t\t\t\t\tif (e === NOT_SERIALIZABLE) continue;\n\t\t\t\t\tconst msg = \"Skipped not serializable cache item\";\n\t\t\t\t\tif (e.message.includes(\"ModuleBuildError\")) {\n\t\t\t\t\t\tlogger.log(`${msg} (in build error): ${e.message}`);\n\t\t\t\t\t\tlogger.debug(`${msg} '${key}' (in build error): ${e.stack}`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.warn(`${msg}: ${e.message}`);\n\t\t\t\t\t\tlogger.debug(`${msg} '${key}': ${e.stack}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite(null);\n\t\t\treturn;\n\t\t}\n\t\t// Try to serialize all at once\n\t\tconst s = snapshot();\n\t\ttry {\n\t\t\twrite(true);\n\t\t\twrite(this.map);\n\t\t} catch (e) {\n\t\t\trollback(s);\n\n\t\t\t// Try to serialize each item on it's own\n\t\t\twrite(false);\n\t\t\tfor (const [key, value] of this.map) {\n\t\t\t\tconst s = snapshot();\n\t\t\t\ttry {\n\t\t\t\t\twrite(key);\n\t\t\t\t\twrite(value);\n\t\t\t\t} catch (e) {\n\t\t\t\t\trollback(s);\n\t\t\t\t\tif (e === NOT_SERIALIZABLE) continue;\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Skipped not serializable cache item '${key}': ${e.message}`\n\t\t\t\t\t);\n\t\t\t\t\tlogger.debug(e.stack);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite(null);\n\t\t}\n\t}\n\n\t/**\n\t * @param {ObjectDeserializerContext & { logger: Logger, profile: boolean | undefined }} context context\n\t */\n\tdeserialize({ read, logger, profile }) {\n\t\tif (read()) {\n\t\t\tthis.map = read();\n\t\t} else if (profile) {\n\t\t\tconst map = new Map();\n\t\t\tlet key = read();\n\t\t\twhile (key !== null) {\n\t\t\t\tconst start = process.hrtime();\n\t\t\t\tconst value = read();\n\t\t\t\tconst durationHr = process.hrtime(start);\n\t\t\t\tconst duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n\t\t\t\tif (duration > 1) {\n\t\t\t\t\tif (duration > 100)\n\t\t\t\t\t\tlogger.error(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t\telse if (duration > 20)\n\t\t\t\t\t\tlogger.warn(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t\telse if (duration > 5)\n\t\t\t\t\t\tlogger.info(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t\telse if (duration > 2)\n\t\t\t\t\t\tlogger.log(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t\telse logger.debug(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t}\n\t\t\t\tmap.set(key, value);\n\t\t\t\tkey = read();\n\t\t\t}\n\t\t\tthis.map = map;\n\t\t} else {\n\t\t\tconst map = new Map();\n\t\t\tlet key = read();\n\t\t\twhile (key !== null) {\n\t\t\t\tmap.set(key, read());\n\t\t\t\tkey = read();\n\t\t\t}\n\t\t\tthis.map = map;\n\t\t}\n\t}\n}\n\nmakeSerializable(\n\tPackContentItems,\n\t\"webpack/lib/cache/PackFileCacheStrategy\",\n\t\"PackContentItems\"\n);\n\nclass PackContent {\n\t/*\n\t\tThis class can be in these states:\n\t\t   |   this.lazy    | this.content | this.outdated | state\n\t\tA1 |   undefined    |     Map      |     false     | fresh content\n\t\tA2 |   undefined    |     Map      |     true      | (will not happen)\n\t\tB1 | lazy () => {}  |  undefined   |     false     | not deserialized\n\t\tB2 | lazy () => {}  |  undefined   |     true      | not deserialized, but some items has been removed\n\t\tC1 | lazy* () => {} |     Map      |     false     | deserialized\n\t\tC2 | lazy* () => {} |     Map      |     true      | deserialized, and some items has been removed\n\n\t\tthis.used is a subset of this.items.\n\t\tthis.items is a subset of this.content.keys() resp. this.lazy().map.keys()\n\t\tWhen this.outdated === false, this.items === this.content.keys() resp. this.lazy().map.keys()\n\t\tWhen this.outdated === true, this.items should be used to recreated this.lazy/this.content.\n\t\tWhen this.lazy and this.content is set, they contain the same data.\n\t\tthis.get must only be called with a valid item from this.items.\n\t\tIn state C this.lazy is unMemoized\n\t*/\n\n\t/**\n\t * @param {Items} items keys\n\t * @param {Items} usedItems used keys\n\t * @param {PackContentItems | function(): Promise<PackContentItems>} dataOrFn sync or async content\n\t * @param {Logger=} logger logger for logging\n\t * @param {string=} lazyName name of dataOrFn for logging\n\t */\n\tconstructor(items, usedItems, dataOrFn, logger, lazyName) {\n\t\tthis.items = items;\n\t\t/** @type {(function(): Promise<PackContentItems> | PackContentItems) | undefined} */\n\t\tthis.lazy = typeof dataOrFn === \"function\" ? dataOrFn : undefined;\n\t\t/** @type {Map<string, any> | undefined} */\n\t\tthis.content = typeof dataOrFn === \"function\" ? undefined : dataOrFn.map;\n\t\tthis.outdated = false;\n\t\tthis.used = usedItems;\n\t\tthis.logger = logger;\n\t\tthis.lazyName = lazyName;\n\t}\n\n\t/**\n\t * @param {string} identifier identifier\n\t * @returns {string | Promise<string>} result\n\t */\n\tget(identifier) {\n\t\tthis.used.add(identifier);\n\t\tif (this.content) {\n\t\t\treturn this.content.get(identifier);\n\t\t}\n\n\t\t// We are in state B\n\t\tconst { lazyName } = this;\n\t\t/** @type {string | undefined} */\n\t\tlet timeMessage;\n\t\tif (lazyName) {\n\t\t\t// only log once\n\t\t\tthis.lazyName = undefined;\n\t\t\ttimeMessage = `restore cache content ${lazyName} (${formatSize(\n\t\t\t\tthis.getSize()\n\t\t\t)})`;\n\t\t\tthis.logger.log(\n\t\t\t\t`starting to restore cache content ${lazyName} (${formatSize(\n\t\t\t\t\tthis.getSize()\n\t\t\t\t)}) because of request to: ${identifier}`\n\t\t\t);\n\t\t\tthis.logger.time(timeMessage);\n\t\t}\n\t\tconst value = this.lazy();\n\t\tif (\"then\" in value) {\n\t\t\treturn value.then(data => {\n\t\t\t\tconst map = data.map;\n\t\t\t\tif (timeMessage) {\n\t\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t\t}\n\t\t\t\t// Move to state C\n\t\t\t\tthis.content = map;\n\t\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n\t\t\t\treturn map.get(identifier);\n\t\t\t});\n\t\t} else {\n\t\t\tconst map = value.map;\n\t\t\tif (timeMessage) {\n\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t}\n\t\t\t// Move to state C\n\t\t\tthis.content = map;\n\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n\t\t\treturn map.get(identifier);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} reason explanation why unpack is necessary\n\t * @returns {void | Promise<void>} maybe a promise if lazy\n\t */\n\tunpack(reason) {\n\t\tif (this.content) return;\n\n\t\t// Move from state B to C\n\t\tif (this.lazy) {\n\t\t\tconst { lazyName } = this;\n\t\t\t/** @type {string | undefined} */\n\t\t\tlet timeMessage;\n\t\t\tif (lazyName) {\n\t\t\t\t// only log once\n\t\t\t\tthis.lazyName = undefined;\n\t\t\t\ttimeMessage = `unpack cache content ${lazyName} (${formatSize(\n\t\t\t\t\tthis.getSize()\n\t\t\t\t)})`;\n\t\t\t\tthis.logger.log(\n\t\t\t\t\t`starting to unpack cache content ${lazyName} (${formatSize(\n\t\t\t\t\t\tthis.getSize()\n\t\t\t\t\t)}) because ${reason}`\n\t\t\t\t);\n\t\t\t\tthis.logger.time(timeMessage);\n\t\t\t}\n\t\t\tconst value = this.lazy();\n\t\t\tif (\"then\" in value) {\n\t\t\t\treturn value.then(data => {\n\t\t\t\t\tif (timeMessage) {\n\t\t\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t\t\t}\n\t\t\t\t\tthis.content = data.map;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (timeMessage) {\n\t\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t\t}\n\t\t\t\tthis.content = value.map;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @returns {number} size of the content or -1 if not known\n\t */\n\tgetSize() {\n\t\tif (!this.lazy) return -1;\n\t\tconst options = /** @type {any} */ (this.lazy).options;\n\t\tif (!options) return -1;\n\t\tconst size = options.size;\n\t\tif (typeof size !== \"number\") return -1;\n\t\treturn size;\n\t}\n\n\t/**\n\t * @param {string} identifier identifier\n\t */\n\tdelete(identifier) {\n\t\tthis.items.delete(identifier);\n\t\tthis.used.delete(identifier);\n\t\tthis.outdated = true;\n\t}\n\n\t/**\n\t * @template T\n\t * @param {function(any): function(): Promise<PackContentItems> | PackContentItems} write write function\n\t * @returns {void}\n\t */\n\twriteLazy(write) {\n\t\tif (!this.outdated && this.lazy) {\n\t\t\t// State B1 or C1\n\t\t\t// this.lazy is still the valid deserialized version\n\t\t\twrite(this.lazy);\n\t\t\treturn;\n\t\t}\n\t\tif (!this.outdated && this.content) {\n\t\t\t// State A1\n\t\t\tconst map = new Map(this.content);\n\t\t\t// Move to state C1\n\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(\n\t\t\t\twrite(() => new PackContentItems(map))\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\tif (this.content) {\n\t\t\t// State A2 or C2\n\t\t\t/** @type {Map<string, any>} */\n\t\t\tconst map = new Map();\n\t\t\tfor (const item of this.items) {\n\t\t\t\tmap.set(item, this.content.get(item));\n\t\t\t}\n\t\t\t// Move to state C1\n\t\t\tthis.outdated = false;\n\t\t\tthis.content = map;\n\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(\n\t\t\t\twrite(() => new PackContentItems(map))\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\t// State B2\n\t\tconst { lazyName } = this;\n\t\t/** @type {string | undefined} */\n\t\tlet timeMessage;\n\t\tif (lazyName) {\n\t\t\t// only log once\n\t\t\tthis.lazyName = undefined;\n\t\t\ttimeMessage = `unpack cache content ${lazyName} (${formatSize(\n\t\t\t\tthis.getSize()\n\t\t\t)})`;\n\t\t\tthis.logger.log(\n\t\t\t\t`starting to unpack cache content ${lazyName} (${formatSize(\n\t\t\t\t\tthis.getSize()\n\t\t\t\t)}) because it's outdated and need to be serialized`\n\t\t\t);\n\t\t\tthis.logger.time(timeMessage);\n\t\t}\n\t\tconst value = this.lazy();\n\t\tthis.outdated = false;\n\t\tif (\"then\" in value) {\n\t\t\t// Move to state B1\n\t\t\tthis.lazy = write(() =>\n\t\t\t\tvalue.then(data => {\n\t\t\t\t\tif (timeMessage) {\n\t\t\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t\t\t}\n\t\t\t\t\tconst oldMap = data.map;\n\t\t\t\t\t/** @type {Map<string, any>} */\n\t\t\t\t\tconst map = new Map();\n\t\t\t\t\tfor (const item of this.items) {\n\t\t\t\t\t\tmap.set(item, oldMap.get(item));\n\t\t\t\t\t}\n\t\t\t\t\t// Move to state C1 (or maybe C2)\n\t\t\t\t\tthis.content = map;\n\t\t\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n\n\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t})\n\t\t\t);\n\t\t} else {\n\t\t\t// Move to state C1\n\t\t\tif (timeMessage) {\n\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t}\n\t\t\tconst oldMap = value.map;\n\t\t\t/** @type {Map<string, any>} */\n\t\t\tconst map = new Map();\n\t\t\tfor (const item of this.items) {\n\t\t\t\tmap.set(item, oldMap.get(item));\n\t\t\t}\n\t\t\tthis.content = map;\n\t\t\tthis.lazy = write(() => new PackContentItems(map));\n\t\t}\n\t}\n}\n\n/**\n * @param {Buffer} buf buffer\n * @returns {Buffer} buffer that can be collected\n */\nconst allowCollectingMemory = buf => {\n\tconst wasted = buf.buffer.byteLength - buf.byteLength;\n\tif (wasted > 8192 && (wasted > 1048576 || wasted > buf.byteLength)) {\n\t\treturn Buffer.from(buf);\n\t}\n\treturn buf;\n};\n\nclass PackFileCacheStrategy {\n\t/**\n\t * @param {Object} options options\n\t * @param {Compiler} options.compiler the compiler\n\t * @param {IntermediateFileSystem} options.fs the filesystem\n\t * @param {string} options.context the context directory\n\t * @param {string} options.cacheLocation the location of the cache data\n\t * @param {string} options.version version identifier\n\t * @param {Logger} options.logger a logger\n\t * @param {SnapshotOptions} options.snapshot options regarding snapshotting\n\t * @param {number} options.maxAge max age of cache items\n\t * @param {boolean | undefined} options.profile track and log detailed timing information for individual cache items\n\t * @param {boolean | undefined} options.allowCollectingMemory allow to collect unused memory created during deserialization\n\t * @param {false | \"gzip\" | \"brotli\" | undefined} options.compression compression used\n\t * @param {boolean | undefined} options.readonly disable storing cache into filesystem\n\t */\n\tconstructor({\n\t\tcompiler,\n\t\tfs,\n\t\tcontext,\n\t\tcacheLocation,\n\t\tversion,\n\t\tlogger,\n\t\tsnapshot,\n\t\tmaxAge,\n\t\tprofile,\n\t\tallowCollectingMemory,\n\t\tcompression,\n\t\treadonly\n\t}) {\n\t\tthis.fileSerializer = createFileSerializer(\n\t\t\tfs,\n\t\t\tcompiler.options.output.hashFunction\n\t\t);\n\t\tthis.fileSystemInfo = new FileSystemInfo(fs, {\n\t\t\tmanagedPaths: snapshot.managedPaths,\n\t\t\timmutablePaths: snapshot.immutablePaths,\n\t\t\tlogger: logger.getChildLogger(\"webpack.FileSystemInfo\"),\n\t\t\thashFunction: compiler.options.output.hashFunction\n\t\t});\n\t\tthis.compiler = compiler;\n\t\tthis.context = context;\n\t\tthis.cacheLocation = cacheLocation;\n\t\tthis.version = version;\n\t\tthis.logger = logger;\n\t\tthis.maxAge = maxAge;\n\t\tthis.profile = profile;\n\t\tthis.readonly = readonly;\n\t\tthis.allowCollectingMemory = allowCollectingMemory;\n\t\tthis.compression = compression;\n\t\tthis._extension =\n\t\t\tcompression === \"brotli\"\n\t\t\t\t? \".pack.br\"\n\t\t\t\t: compression === \"gzip\"\n\t\t\t\t\t? \".pack.gz\"\n\t\t\t\t\t: \".pack\";\n\t\tthis.snapshot = snapshot;\n\t\t/** @type {BuildDependencies} */\n\t\tthis.buildDependencies = new Set();\n\t\t/** @type {LazySet<string>} */\n\t\tthis.newBuildDependencies = new LazySet();\n\t\t/** @type {Snapshot | undefined} */\n\t\tthis.resolveBuildDependenciesSnapshot = undefined;\n\t\t/** @type {ResolveResults | undefined} */\n\t\tthis.resolveResults = undefined;\n\t\t/** @type {Snapshot | undefined} */\n\t\tthis.buildSnapshot = undefined;\n\t\t/** @type {Promise<Pack> | undefined} */\n\t\tthis.packPromise = this._openPack();\n\t\tthis.storePromise = Promise.resolve();\n\t}\n\n\t/**\n\t * @returns {Promise<Pack>} pack\n\t */\n\t_getPack() {\n\t\tif (this.packPromise === undefined) {\n\t\t\tthis.packPromise = this.storePromise.then(() => this._openPack());\n\t\t}\n\t\treturn this.packPromise;\n\t}\n\n\t/**\n\t * @returns {Promise<Pack>} the pack\n\t */\n\t_openPack() {\n\t\tconst { logger, profile, cacheLocation, version } = this;\n\t\t/** @type {Snapshot} */\n\t\tlet buildSnapshot;\n\t\t/** @type {BuildDependencies} */\n\t\tlet buildDependencies;\n\t\t/** @type {BuildDependencies} */\n\t\tlet newBuildDependencies;\n\t\t/** @type {Snapshot} */\n\t\tlet resolveBuildDependenciesSnapshot;\n\t\t/** @type {ResolveResults | undefined} */\n\t\tlet resolveResults;\n\t\tlogger.time(\"restore cache container\");\n\t\treturn this.fileSerializer\n\t\t\t.deserialize(null, {\n\t\t\t\tfilename: `${cacheLocation}/index${this._extension}`,\n\t\t\t\textension: `${this._extension}`,\n\t\t\t\tlogger,\n\t\t\t\tprofile,\n\t\t\t\tretainedBuffer: this.allowCollectingMemory\n\t\t\t\t\t? allowCollectingMemory\n\t\t\t\t\t: undefined\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tif (err.code !== \"ENOENT\") {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Restoring pack failed from ${cacheLocation}${this._extension}: ${err}`\n\t\t\t\t\t);\n\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t`No pack exists at ${cacheLocation}${this._extension}: ${err}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t})\n\t\t\t.then(packContainer => {\n\t\t\t\tlogger.timeEnd(\"restore cache container\");\n\t\t\t\tif (!packContainer) return undefined;\n\t\t\t\tif (!(packContainer instanceof PackContainer)) {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but contained content is unexpected.`,\n\t\t\t\t\t\tpackContainer\n\t\t\t\t\t);\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tif (packContainer.version !== version) {\n\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but version doesn't match.`\n\t\t\t\t\t);\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tlogger.time(\"check build dependencies\");\n\t\t\t\treturn Promise.all([\n\t\t\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\t\t\tthis.fileSystemInfo.checkSnapshotValid(\n\t\t\t\t\t\t\tpackContainer.buildSnapshot,\n\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of build dependencies errored: ${err}.`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!valid) {\n\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but build dependencies have changed.`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbuildSnapshot = packContainer.buildSnapshot;\n\t\t\t\t\t\t\t\treturn resolve(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}),\n\t\t\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\t\t\tthis.fileSystemInfo.checkSnapshotValid(\n\t\t\t\t\t\t\tpackContainer.resolveBuildDependenciesSnapshot,\n\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of resolving of build dependencies errored: ${err}.`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\t\tresolveBuildDependenciesSnapshot =\n\t\t\t\t\t\t\t\t\t\tpackContainer.resolveBuildDependenciesSnapshot;\n\t\t\t\t\t\t\t\t\tbuildDependencies = packContainer.buildDependencies;\n\t\t\t\t\t\t\t\t\tresolveResults = packContainer.resolveResults;\n\t\t\t\t\t\t\t\t\treturn resolve(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\"resolving of build dependencies is invalid, will re-resolve build dependencies\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tthis.fileSystemInfo.checkResolveResultsValid(\n\t\t\t\t\t\t\t\t\tpackContainer.resolveResults,\n\t\t\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but resolving of build dependencies errored: ${err}.`\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\t\t\t\tnewBuildDependencies = packContainer.buildDependencies;\n\t\t\t\t\t\t\t\t\t\t\tresolveResults = packContainer.resolveResults;\n\t\t\t\t\t\t\t\t\t\t\treturn resolve(true);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but build dependencies resolve to different locations.`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t})\n\t\t\t\t])\n\t\t\t\t\t.catch(err => {\n\t\t\t\t\t\tlogger.timeEnd(\"check build dependencies\");\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t})\n\t\t\t\t\t.then(([buildSnapshotValid, resolveValid]) => {\n\t\t\t\t\t\tlogger.timeEnd(\"check build dependencies\");\n\t\t\t\t\t\tif (buildSnapshotValid && resolveValid) {\n\t\t\t\t\t\t\tlogger.time(\"restore cache content metadata\");\n\t\t\t\t\t\t\tconst d = packContainer.data();\n\t\t\t\t\t\t\tlogger.timeEnd(\"restore cache content metadata\");\n\t\t\t\t\t\t\treturn d;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t});\n\t\t\t})\n\t\t\t.then(pack => {\n\t\t\t\tif (pack) {\n\t\t\t\t\tpack.maxAge = this.maxAge;\n\t\t\t\t\tthis.buildSnapshot = buildSnapshot;\n\t\t\t\t\tif (buildDependencies) this.buildDependencies = buildDependencies;\n\t\t\t\t\tif (newBuildDependencies)\n\t\t\t\t\t\tthis.newBuildDependencies.addAll(newBuildDependencies);\n\t\t\t\t\tthis.resolveResults = resolveResults;\n\t\t\t\t\tthis.resolveBuildDependenciesSnapshot =\n\t\t\t\t\t\tresolveBuildDependenciesSnapshot;\n\t\t\t\t\treturn pack;\n\t\t\t\t}\n\t\t\t\treturn new Pack(logger, this.maxAge);\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tthis.logger.warn(\n\t\t\t\t\t`Restoring pack from ${cacheLocation}${this._extension} failed: ${err}`\n\t\t\t\t);\n\t\t\t\tthis.logger.debug(err.stack);\n\t\t\t\treturn new Pack(logger, this.maxAge);\n\t\t\t});\n\t}\n\n\t/**\n\t * @param {string} identifier unique name for the resource\n\t * @param {Etag | null} etag etag of the resource\n\t * @param {any} data cached content\n\t * @returns {Promise<void>} promise\n\t */\n\tstore(identifier, etag, data) {\n\t\tif (this.readonly) return Promise.resolve();\n\n\t\treturn this._getPack().then(pack => {\n\t\t\tpack.set(identifier, etag === null ? null : etag.toString(), data);\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} identifier unique name for the resource\n\t * @param {Etag | null} etag etag of the resource\n\t * @returns {Promise<any>} promise to the cached content\n\t */\n\trestore(identifier, etag) {\n\t\treturn this._getPack()\n\t\t\t.then(pack =>\n\t\t\t\tpack.get(identifier, etag === null ? null : etag.toString())\n\t\t\t)\n\t\t\t.catch(err => {\n\t\t\t\tif (err && err.code !== \"ENOENT\") {\n\t\t\t\t\tthis.logger.warn(\n\t\t\t\t\t\t`Restoring failed for ${identifier} from pack: ${err}`\n\t\t\t\t\t);\n\t\t\t\t\tthis.logger.debug(err.stack);\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\t/**\n\t * @param {LazySet<string> | Iterable<string>} dependencies dependencies to store\n\t */\n\tstoreBuildDependencies(dependencies) {\n\t\tif (this.readonly) return;\n\t\tthis.newBuildDependencies.addAll(dependencies);\n\t}\n\n\tafterAllStored() {\n\t\tconst packPromise = this.packPromise;\n\t\tif (packPromise === undefined) return Promise.resolve();\n\t\tconst reportProgress = ProgressPlugin.getReporter(this.compiler);\n\t\treturn (this.storePromise = packPromise\n\t\t\t.then(pack => {\n\t\t\t\tpack.stopCapturingRequests();\n\t\t\t\tif (!pack.invalid) return;\n\t\t\t\tthis.packPromise = undefined;\n\t\t\t\tthis.logger.log(`Storing pack...`);\n\t\t\t\tlet promise;\n\t\t\t\tconst newBuildDependencies = new Set();\n\t\t\t\tfor (const dep of this.newBuildDependencies) {\n\t\t\t\t\tif (!this.buildDependencies.has(dep)) {\n\t\t\t\t\t\tnewBuildDependencies.add(dep);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (newBuildDependencies.size > 0 || !this.buildSnapshot) {\n\t\t\t\t\tif (reportProgress) reportProgress(0.5, \"resolve build dependencies\");\n\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t`Capturing build dependencies... (${Array.from(\n\t\t\t\t\t\t\tnewBuildDependencies\n\t\t\t\t\t\t).join(\", \")})`\n\t\t\t\t\t);\n\t\t\t\t\tpromise = new Promise((resolve, reject) => {\n\t\t\t\t\t\tthis.logger.time(\"resolve build dependencies\");\n\t\t\t\t\t\tthis.fileSystemInfo.resolveBuildDependencies(\n\t\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\t\tnewBuildDependencies,\n\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"resolve build dependencies\");\n\t\t\t\t\t\t\t\tif (err) return reject(err);\n\n\t\t\t\t\t\t\t\tthis.logger.time(\"snapshot build dependencies\");\n\t\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\t\tfiles,\n\t\t\t\t\t\t\t\t\tdirectories,\n\t\t\t\t\t\t\t\t\tmissing,\n\t\t\t\t\t\t\t\t\tresolveResults,\n\t\t\t\t\t\t\t\t\tresolveDependencies\n\t\t\t\t\t\t\t\t} = /** @type {ResolveBuildDependenciesResult} */ (result);\n\t\t\t\t\t\t\t\tif (this.resolveResults) {\n\t\t\t\t\t\t\t\t\tfor (const [key, value] of resolveResults) {\n\t\t\t\t\t\t\t\t\t\tthis.resolveResults.set(key, value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis.resolveResults = resolveResults;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (reportProgress) {\n\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t0.6,\n\t\t\t\t\t\t\t\t\t\t\"snapshot build dependencies\",\n\t\t\t\t\t\t\t\t\t\t\"resolving\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.fileSystemInfo.createSnapshot(\n\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\tresolveDependencies.files,\n\t\t\t\t\t\t\t\t\tresolveDependencies.directories,\n\t\t\t\t\t\t\t\t\tresolveDependencies.missing,\n\t\t\t\t\t\t\t\t\tthis.snapshot.resolveBuildDependencies,\n\t\t\t\t\t\t\t\t\t(err, snapshot) => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"snapshot build dependencies\");\n\t\t\t\t\t\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!snapshot) {\n\t\t\t\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"snapshot build dependencies\");\n\t\t\t\t\t\t\t\t\t\t\treturn reject(\n\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\"Unable to snapshot resolve dependencies\")\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (this.resolveBuildDependenciesSnapshot) {\n\t\t\t\t\t\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot =\n\t\t\t\t\t\t\t\t\t\t\t\tthis.fileSystemInfo.mergeSnapshots(\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot,\n\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot = snapshot;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (reportProgress) {\n\t\t\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t\t\t0.7,\n\t\t\t\t\t\t\t\t\t\t\t\t\"snapshot build dependencies\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"modules\"\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tthis.fileSystemInfo.createSnapshot(\n\t\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\t\tfiles,\n\t\t\t\t\t\t\t\t\t\t\tdirectories,\n\t\t\t\t\t\t\t\t\t\t\tmissing,\n\t\t\t\t\t\t\t\t\t\t\tthis.snapshot.buildDependencies,\n\t\t\t\t\t\t\t\t\t\t\t(err, snapshot) => {\n\t\t\t\t\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"snapshot build dependencies\");\n\t\t\t\t\t\t\t\t\t\t\t\tif (err) return reject(err);\n\t\t\t\t\t\t\t\t\t\t\t\tif (!snapshot) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn reject(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\"Unable to snapshot build dependencies\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\"Captured build dependencies\");\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (this.buildSnapshot) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.buildSnapshot =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.fileSystemInfo.mergeSnapshots(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.buildSnapshot,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.buildSnapshot = snapshot;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tpromise = Promise.resolve();\n\t\t\t\t}\n\t\t\t\treturn promise.then(() => {\n\t\t\t\t\tif (reportProgress) reportProgress(0.8, \"serialize pack\");\n\t\t\t\t\tthis.logger.time(`store pack`);\n\t\t\t\t\tconst updatedBuildDependencies = new Set(this.buildDependencies);\n\t\t\t\t\tfor (const dep of newBuildDependencies) {\n\t\t\t\t\t\tupdatedBuildDependencies.add(dep);\n\t\t\t\t\t}\n\t\t\t\t\tconst content = new PackContainer(\n\t\t\t\t\t\tpack,\n\t\t\t\t\t\tthis.version,\n\t\t\t\t\t\t/** @type {Snapshot} */ (this.buildSnapshot),\n\t\t\t\t\t\tupdatedBuildDependencies,\n\t\t\t\t\t\tthis.resolveResults,\n\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot\n\t\t\t\t\t);\n\t\t\t\t\treturn this.fileSerializer\n\t\t\t\t\t\t.serialize(content, {\n\t\t\t\t\t\t\tfilename: `${this.cacheLocation}/index${this._extension}`,\n\t\t\t\t\t\t\textension: `${this._extension}`,\n\t\t\t\t\t\t\tlogger: this.logger,\n\t\t\t\t\t\t\tprofile: this.profile\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t\tfor (const dep of newBuildDependencies) {\n\t\t\t\t\t\t\t\tthis.buildDependencies.add(dep);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.newBuildDependencies.clear();\n\t\t\t\t\t\t\tthis.logger.timeEnd(`store pack`);\n\t\t\t\t\t\t\tconst stats = pack.getContentStats();\n\t\t\t\t\t\t\tthis.logger.log(\n\t\t\t\t\t\t\t\t\"Stored pack (%d items, %d files, %d MiB)\",\n\t\t\t\t\t\t\t\tpack.itemInfo.size,\n\t\t\t\t\t\t\t\tstats.count,\n\t\t\t\t\t\t\t\tMath.round(stats.size / 1024 / 1024)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(err => {\n\t\t\t\t\t\t\tthis.logger.timeEnd(`store pack`);\n\t\t\t\t\t\t\tthis.logger.warn(`Caching failed for pack: ${err}`);\n\t\t\t\t\t\t\tthis.logger.debug(err.stack);\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tthis.logger.warn(`Caching failed for pack: ${err}`);\n\t\t\t\tthis.logger.debug(err.stack);\n\t\t\t}));\n\t}\n\n\tclear() {\n\t\tthis.fileSystemInfo.clear();\n\t\tthis.buildDependencies.clear();\n\t\tthis.newBuildDependencies.clear();\n\t\tthis.resolveBuildDependenciesSnapshot = undefined;\n\t\tthis.resolveResults = undefined;\n\t\tthis.buildSnapshot = undefined;\n\t\tthis.packPromise = undefined;\n\t}\n}\n\nmodule.exports = PackFileCacheStrategy;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
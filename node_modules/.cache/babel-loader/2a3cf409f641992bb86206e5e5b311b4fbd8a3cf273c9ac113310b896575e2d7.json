{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  pathToFileURL\n} = require(\"url\");\nconst AsyncDependenciesBlock = require(\"../AsyncDependenciesBlock\");\nconst CommentCompilationWarning = require(\"../CommentCompilationWarning\");\nconst {\n  JAVASCRIPT_MODULE_TYPE_AUTO,\n  JAVASCRIPT_MODULE_TYPE_ESM\n} = require(\"../ModuleTypeConstants\");\nconst UnsupportedFeatureWarning = require(\"../UnsupportedFeatureWarning\");\nconst EnableChunkLoadingPlugin = require(\"../javascript/EnableChunkLoadingPlugin\");\nconst {\n  equals\n} = require(\"../util/ArrayHelpers\");\nconst createHash = require(\"../util/createHash\");\nconst {\n  contextify\n} = require(\"../util/identifier\");\nconst EnableWasmLoadingPlugin = require(\"../wasm/EnableWasmLoadingPlugin\");\nconst ConstDependency = require(\"./ConstDependency\");\nconst CreateScriptUrlDependency = require(\"./CreateScriptUrlDependency\");\nconst {\n  harmonySpecifierTag\n} = require(\"./HarmonyImportDependencyParserPlugin\");\nconst WorkerDependency = require(\"./WorkerDependency\");\n\n/** @typedef {import(\"estree\").CallExpression} CallExpression */\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"estree\").ObjectExpression} ObjectExpression */\n/** @typedef {import(\"estree\").Pattern} Pattern */\n/** @typedef {import(\"estree\").Property} Property */\n/** @typedef {import(\"estree\").SpreadElement} SpreadElement */\n/** @typedef {import(\"../../declarations/WebpackOptions\").ChunkLoading} ChunkLoading */\n/** @typedef {import(\"../../declarations/WebpackOptions\").JavascriptParserOptions} JavascriptParserOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OutputModule} OutputModule */\n/** @typedef {import(\"../../declarations/WebpackOptions\").WasmLoading} WasmLoading */\n/** @typedef {import(\"../../declarations/WebpackOptions\").WorkerPublicPath} WorkerPublicPath */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"../Entrypoint\").EntryOptions} EntryOptions */\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n/** @typedef {import(\"../javascript/BasicEvaluatedExpression\")} BasicEvaluatedExpression */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../javascript/JavascriptParser\")} Parser */\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n/** @typedef {import(\"./HarmonyImportDependencyParserPlugin\").HarmonySettings} HarmonySettings */\n\n/**\n * @param {NormalModule} module module\n * @returns {string} url\n */\nconst getUrl = module => {\n  return pathToFileURL(module.resource).toString();\n};\nconst WorkerSpecifierTag = Symbol(\"worker specifier tag\");\nconst DEFAULT_SYNTAX = [\"Worker\", \"SharedWorker\", \"navigator.serviceWorker.register()\", \"Worker from worker_threads\"];\n\n/** @type {WeakMap<ParserState, number>} */\nconst workerIndexMap = new WeakMap();\nconst PLUGIN_NAME = \"WorkerPlugin\";\nclass WorkerPlugin {\n  /**\n   * @param {ChunkLoading=} chunkLoading chunk loading\n   * @param {WasmLoading=} wasmLoading wasm loading\n   * @param {OutputModule=} module output module\n   * @param {WorkerPublicPath=} workerPublicPath worker public path\n   */\n  constructor(chunkLoading, wasmLoading, module, workerPublicPath) {\n    this._chunkLoading = chunkLoading;\n    this._wasmLoading = wasmLoading;\n    this._module = module;\n    this._workerPublicPath = workerPublicPath;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    if (this._chunkLoading) {\n      new EnableChunkLoadingPlugin(this._chunkLoading).apply(compiler);\n    }\n    if (this._wasmLoading) {\n      new EnableWasmLoadingPlugin(this._wasmLoading).apply(compiler);\n    }\n    const cachedContextify = contextify.bindContextCache(compiler.context, compiler.root);\n    compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation, {\n      normalModuleFactory\n    }) => {\n      compilation.dependencyFactories.set(WorkerDependency, normalModuleFactory);\n      compilation.dependencyTemplates.set(WorkerDependency, new WorkerDependency.Template());\n      compilation.dependencyTemplates.set(CreateScriptUrlDependency, new CreateScriptUrlDependency.Template());\n\n      /**\n       * @param {JavascriptParser} parser the parser\n       * @param {Expression} expr expression\n       * @returns {[BasicEvaluatedExpression, [number, number]] | void} parsed\n       */\n      const parseModuleUrl = (parser, expr) => {\n        if (expr.type !== \"NewExpression\" || expr.callee.type === \"Super\" || expr.arguments.length !== 2) return;\n        const [arg1, arg2] = expr.arguments;\n        if (arg1.type === \"SpreadElement\") return;\n        if (arg2.type === \"SpreadElement\") return;\n        const callee = parser.evaluateExpression(expr.callee);\n        if (!callee.isIdentifier() || callee.identifier !== \"URL\") return;\n        const arg2Value = parser.evaluateExpression(arg2);\n        if (!arg2Value.isString() || !( /** @type {string} */arg2Value.string.startsWith(\"file://\")) || arg2Value.string !== getUrl(parser.state.module)) {\n          return;\n        }\n        const arg1Value = parser.evaluateExpression(arg1);\n        return [arg1Value, [/** @type {Range} */arg1.range[0], /** @type {Range} */arg2.range[1]]];\n      };\n\n      /**\n       * @param {JavascriptParser} parser the parser\n       * @param {ObjectExpression} expr expression\n       * @returns {{ expressions: Record<string, Expression | Pattern>, otherElements: (Property | SpreadElement)[], values: Record<string, any>, spread: boolean, insertType: \"comma\" | \"single\", insertLocation: number }} parsed object\n       */\n      const parseObjectExpression = (parser, expr) => {\n        /** @type {Record<string, any>} */\n        const values = {};\n        /** @type {Record<string, Expression | Pattern>} */\n        const expressions = {};\n        /** @type {(Property | SpreadElement)[]} */\n        const otherElements = [];\n        let spread = false;\n        for (const prop of expr.properties) {\n          if (prop.type === \"SpreadElement\") {\n            spread = true;\n          } else if (prop.type === \"Property\" && !prop.method && !prop.computed && prop.key.type === \"Identifier\") {\n            expressions[prop.key.name] = prop.value;\n            if (!prop.shorthand && !prop.value.type.endsWith(\"Pattern\")) {\n              const value = parser.evaluateExpression( /** @type {Expression} */prop.value);\n              if (value.isCompileTimeValue()) values[prop.key.name] = value.asCompileTimeValue();\n            }\n          } else {\n            otherElements.push(prop);\n          }\n        }\n        const insertType = expr.properties.length > 0 ? \"comma\" : \"single\";\n        const insertLocation = /** @type {Range} */expr.properties[expr.properties.length - 1].range[1];\n        return {\n          expressions,\n          otherElements,\n          values,\n          spread,\n          insertType,\n          insertLocation\n        };\n      };\n\n      /**\n       * @param {Parser} parser parser parser\n       * @param {JavascriptParserOptions} parserOptions parserOptions\n       * @returns {void}\n       */\n      const parserPlugin = (parser, parserOptions) => {\n        if (parserOptions.worker === false) return;\n        const options = !Array.isArray(parserOptions.worker) ? [\"...\"] : parserOptions.worker;\n        /**\n         * @param {CallExpression} expr expression\n         * @returns {boolean | void} true when handled\n         */\n        const handleNewWorker = expr => {\n          if (expr.arguments.length === 0 || expr.arguments.length > 2) return;\n          const [arg1, arg2] = expr.arguments;\n          if (arg1.type === \"SpreadElement\") return;\n          if (arg2 && arg2.type === \"SpreadElement\") return;\n          const parsedUrl = parseModuleUrl(parser, arg1);\n          if (!parsedUrl) return;\n          const [url, range] = parsedUrl;\n          if (!url.isString()) return;\n          const {\n            expressions,\n            otherElements,\n            values: options,\n            spread: hasSpreadInOptions,\n            insertType,\n            insertLocation\n          } = arg2 && arg2.type === \"ObjectExpression\" ? parseObjectExpression(parser, arg2) : {\n            /** @type {Record<string, Expression | Pattern>} */\n            expressions: {},\n            otherElements: [],\n            /** @type {Record<string, any>} */\n            values: {},\n            spread: false,\n            insertType: arg2 ? \"spread\" : \"argument\",\n            insertLocation: arg2 ? ( /** @type {Range} */arg2.range) : /** @type {Range} */arg1.range[1]\n          };\n          const {\n            options: importOptions,\n            errors: commentErrors\n          } = parser.parseCommentOptions( /** @type {Range} */expr.range);\n          if (commentErrors) {\n            for (const e of commentErrors) {\n              const {\n                comment\n              } = e;\n              parser.state.module.addWarning(new CommentCompilationWarning(`Compilation error while processing magic comment(-s): /*${comment.value}*/: ${e.message}`, comment.loc));\n            }\n          }\n\n          /** @type {EntryOptions} */\n          let entryOptions = {};\n          if (importOptions) {\n            if (importOptions.webpackIgnore !== undefined) {\n              if (typeof importOptions.webpackIgnore !== \"boolean\") {\n                parser.state.module.addWarning(new UnsupportedFeatureWarning(`\\`webpackIgnore\\` expected a boolean, but received: ${importOptions.webpackIgnore}.`, /** @type {DependencyLocation} */expr.loc));\n              } else {\n                if (importOptions.webpackIgnore) {\n                  return false;\n                }\n              }\n            }\n            if (importOptions.webpackEntryOptions !== undefined) {\n              if (typeof importOptions.webpackEntryOptions !== \"object\" || importOptions.webpackEntryOptions === null) {\n                parser.state.module.addWarning(new UnsupportedFeatureWarning(`\\`webpackEntryOptions\\` expected a object, but received: ${importOptions.webpackEntryOptions}.`, /** @type {DependencyLocation} */expr.loc));\n              } else {\n                Object.assign(entryOptions, importOptions.webpackEntryOptions);\n              }\n            }\n            if (importOptions.webpackChunkName !== undefined) {\n              if (typeof importOptions.webpackChunkName !== \"string\") {\n                parser.state.module.addWarning(new UnsupportedFeatureWarning(`\\`webpackChunkName\\` expected a string, but received: ${importOptions.webpackChunkName}.`, /** @type {DependencyLocation} */expr.loc));\n              } else {\n                entryOptions.name = importOptions.webpackChunkName;\n              }\n            }\n          }\n          if (!Object.prototype.hasOwnProperty.call(entryOptions, \"name\") && options && typeof options.name === \"string\") {\n            entryOptions.name = options.name;\n          }\n          if (entryOptions.runtime === undefined) {\n            let i = workerIndexMap.get(parser.state) || 0;\n            workerIndexMap.set(parser.state, i + 1);\n            let name = `${cachedContextify(parser.state.module.identifier())}|${i}`;\n            const hash = createHash(compilation.outputOptions.hashFunction);\n            hash.update(name);\n            const digest = /** @type {string} */\n            hash.digest(compilation.outputOptions.hashDigest);\n            entryOptions.runtime = digest.slice(0, compilation.outputOptions.hashDigestLength);\n          }\n          const block = new AsyncDependenciesBlock({\n            name: entryOptions.name,\n            entryOptions: {\n              chunkLoading: this._chunkLoading,\n              wasmLoading: this._wasmLoading,\n              ...entryOptions\n            }\n          });\n          block.loc = expr.loc;\n          const dep = new WorkerDependency( /** @type {string} */url.string, range, {\n            publicPath: this._workerPublicPath\n          });\n          dep.loc = /** @type {DependencyLocation} */expr.loc;\n          block.addDependency(dep);\n          parser.state.module.addBlock(block);\n          if (compilation.outputOptions.trustedTypes) {\n            const dep = new CreateScriptUrlDependency( /** @type {Range} */expr.arguments[0].range);\n            dep.loc = /** @type {DependencyLocation} */expr.loc;\n            parser.state.module.addDependency(dep);\n          }\n          if (expressions.type) {\n            const expr = expressions.type;\n            if (options.type !== false) {\n              const dep = new ConstDependency(this._module ? '\"module\"' : \"undefined\", /** @type {Range} */expr.range);\n              dep.loc = /** @type {DependencyLocation} */expr.loc;\n              parser.state.module.addPresentationalDependency(dep);\n              /** @type {TODO} */\n              expressions.type = undefined;\n            }\n          } else if (insertType === \"comma\") {\n            if (this._module || hasSpreadInOptions) {\n              const dep = new ConstDependency(`, type: ${this._module ? '\"module\"' : \"undefined\"}`, insertLocation);\n              dep.loc = /** @type {DependencyLocation} */expr.loc;\n              parser.state.module.addPresentationalDependency(dep);\n            }\n          } else if (insertType === \"spread\") {\n            const dep1 = new ConstDependency(\"Object.assign({}, \", /** @type {Range} */insertLocation[0]);\n            const dep2 = new ConstDependency(`, { type: ${this._module ? '\"module\"' : \"undefined\"} })`, /** @type {Range} */insertLocation[1]);\n            dep1.loc = /** @type {DependencyLocation} */expr.loc;\n            dep2.loc = /** @type {DependencyLocation} */expr.loc;\n            parser.state.module.addPresentationalDependency(dep1);\n            parser.state.module.addPresentationalDependency(dep2);\n          } else if (insertType === \"argument\") {\n            if (this._module) {\n              const dep = new ConstDependency(', { type: \"module\" }', insertLocation);\n              dep.loc = /** @type {DependencyLocation} */expr.loc;\n              parser.state.module.addPresentationalDependency(dep);\n            }\n          }\n          parser.walkExpression(expr.callee);\n          for (const key of Object.keys(expressions)) {\n            if (expressions[key]) parser.walkExpression(expressions[key]);\n          }\n          for (const prop of otherElements) {\n            parser.walkProperty(prop);\n          }\n          if (insertType === \"spread\") {\n            parser.walkExpression(arg2);\n          }\n          return true;\n        };\n        /**\n         * @param {string} item item\n         */\n        const processItem = item => {\n          if (item.startsWith(\"*\") && item.includes(\".\") && item.endsWith(\"()\")) {\n            const firstDot = item.indexOf(\".\");\n            const pattern = item.slice(1, firstDot);\n            const itemMembers = item.slice(firstDot + 1, -2);\n            parser.hooks.preDeclarator.tap(PLUGIN_NAME, (decl, statement) => {\n              if (decl.id.type === \"Identifier\" && decl.id.name === pattern) {\n                parser.tagVariable(decl.id.name, WorkerSpecifierTag);\n                return true;\n              }\n            });\n            parser.hooks.pattern.for(pattern).tap(PLUGIN_NAME, pattern => {\n              parser.tagVariable(pattern.name, WorkerSpecifierTag);\n              return true;\n            });\n            parser.hooks.callMemberChain.for(WorkerSpecifierTag).tap(PLUGIN_NAME, (expression, members) => {\n              if (itemMembers !== members.join(\".\")) {\n                return;\n              }\n              return handleNewWorker(expression);\n            });\n          } else if (item.endsWith(\"()\")) {\n            parser.hooks.call.for(item.slice(0, -2)).tap(PLUGIN_NAME, handleNewWorker);\n          } else {\n            const match = /^(.+?)(\\(\\))?\\s+from\\s+(.+)$/.exec(item);\n            if (match) {\n              const ids = match[1].split(\".\");\n              const call = match[2];\n              const source = match[3];\n              (call ? parser.hooks.call : parser.hooks.new).for(harmonySpecifierTag).tap(PLUGIN_NAME, expr => {\n                const settings = /** @type {HarmonySettings} */\n                parser.currentTagData;\n                if (!settings || settings.source !== source || !equals(settings.ids, ids)) {\n                  return;\n                }\n                return handleNewWorker(expr);\n              });\n            } else {\n              parser.hooks.new.for(item).tap(PLUGIN_NAME, handleNewWorker);\n            }\n          }\n        };\n        for (const item of options) {\n          if (item === \"...\") {\n            DEFAULT_SYNTAX.forEach(processItem);\n          } else processItem(item);\n        }\n      };\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_AUTO).tap(PLUGIN_NAME, parserPlugin);\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_ESM).tap(PLUGIN_NAME, parserPlugin);\n    });\n  }\n}\nmodule.exports = WorkerPlugin;","map":{"version":3,"names":["pathToFileURL","require","AsyncDependenciesBlock","CommentCompilationWarning","JAVASCRIPT_MODULE_TYPE_AUTO","JAVASCRIPT_MODULE_TYPE_ESM","UnsupportedFeatureWarning","EnableChunkLoadingPlugin","equals","createHash","contextify","EnableWasmLoadingPlugin","ConstDependency","CreateScriptUrlDependency","harmonySpecifierTag","WorkerDependency","getUrl","module","resource","toString","WorkerSpecifierTag","Symbol","DEFAULT_SYNTAX","workerIndexMap","WeakMap","PLUGIN_NAME","WorkerPlugin","constructor","chunkLoading","wasmLoading","workerPublicPath","_chunkLoading","_wasmLoading","_module","_workerPublicPath","apply","compiler","cachedContextify","bindContextCache","context","root","hooks","thisCompilation","tap","compilation","normalModuleFactory","dependencyFactories","set","dependencyTemplates","Template","parseModuleUrl","parser","expr","type","callee","arguments","length","arg1","arg2","evaluateExpression","isIdentifier","identifier","arg2Value","isString","string","startsWith","state","arg1Value","range","parseObjectExpression","values","expressions","otherElements","spread","prop","properties","method","computed","key","name","value","shorthand","endsWith","isCompileTimeValue","asCompileTimeValue","push","insertType","insertLocation","parserPlugin","parserOptions","worker","options","Array","isArray","handleNewWorker","parsedUrl","url","hasSpreadInOptions","importOptions","errors","commentErrors","parseCommentOptions","e","comment","addWarning","message","loc","entryOptions","webpackIgnore","undefined","webpackEntryOptions","Object","assign","webpackChunkName","prototype","hasOwnProperty","call","runtime","i","get","hash","outputOptions","hashFunction","update","digest","hashDigest","slice","hashDigestLength","block","dep","publicPath","addDependency","addBlock","trustedTypes","addPresentationalDependency","dep1","dep2","walkExpression","keys","walkProperty","processItem","item","includes","firstDot","indexOf","pattern","itemMembers","preDeclarator","decl","statement","id","tagVariable","for","callMemberChain","expression","members","join","match","exec","ids","split","source","new","settings","currentTagData","forEach","exports"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/dependencies/WorkerPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { pathToFileURL } = require(\"url\");\nconst AsyncDependenciesBlock = require(\"../AsyncDependenciesBlock\");\nconst CommentCompilationWarning = require(\"../CommentCompilationWarning\");\nconst {\n\tJAVASCRIPT_MODULE_TYPE_AUTO,\n\tJAVASCRIPT_MODULE_TYPE_ESM\n} = require(\"../ModuleTypeConstants\");\nconst UnsupportedFeatureWarning = require(\"../UnsupportedFeatureWarning\");\nconst EnableChunkLoadingPlugin = require(\"../javascript/EnableChunkLoadingPlugin\");\nconst { equals } = require(\"../util/ArrayHelpers\");\nconst createHash = require(\"../util/createHash\");\nconst { contextify } = require(\"../util/identifier\");\nconst EnableWasmLoadingPlugin = require(\"../wasm/EnableWasmLoadingPlugin\");\nconst ConstDependency = require(\"./ConstDependency\");\nconst CreateScriptUrlDependency = require(\"./CreateScriptUrlDependency\");\nconst {\n\tharmonySpecifierTag\n} = require(\"./HarmonyImportDependencyParserPlugin\");\nconst WorkerDependency = require(\"./WorkerDependency\");\n\n/** @typedef {import(\"estree\").CallExpression} CallExpression */\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"estree\").ObjectExpression} ObjectExpression */\n/** @typedef {import(\"estree\").Pattern} Pattern */\n/** @typedef {import(\"estree\").Property} Property */\n/** @typedef {import(\"estree\").SpreadElement} SpreadElement */\n/** @typedef {import(\"../../declarations/WebpackOptions\").ChunkLoading} ChunkLoading */\n/** @typedef {import(\"../../declarations/WebpackOptions\").JavascriptParserOptions} JavascriptParserOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OutputModule} OutputModule */\n/** @typedef {import(\"../../declarations/WebpackOptions\").WasmLoading} WasmLoading */\n/** @typedef {import(\"../../declarations/WebpackOptions\").WorkerPublicPath} WorkerPublicPath */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"../Entrypoint\").EntryOptions} EntryOptions */\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n/** @typedef {import(\"../javascript/BasicEvaluatedExpression\")} BasicEvaluatedExpression */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../javascript/JavascriptParser\")} Parser */\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n/** @typedef {import(\"./HarmonyImportDependencyParserPlugin\").HarmonySettings} HarmonySettings */\n\n/**\n * @param {NormalModule} module module\n * @returns {string} url\n */\nconst getUrl = module => {\n\treturn pathToFileURL(module.resource).toString();\n};\n\nconst WorkerSpecifierTag = Symbol(\"worker specifier tag\");\n\nconst DEFAULT_SYNTAX = [\n\t\"Worker\",\n\t\"SharedWorker\",\n\t\"navigator.serviceWorker.register()\",\n\t\"Worker from worker_threads\"\n];\n\n/** @type {WeakMap<ParserState, number>} */\nconst workerIndexMap = new WeakMap();\n\nconst PLUGIN_NAME = \"WorkerPlugin\";\n\nclass WorkerPlugin {\n\t/**\n\t * @param {ChunkLoading=} chunkLoading chunk loading\n\t * @param {WasmLoading=} wasmLoading wasm loading\n\t * @param {OutputModule=} module output module\n\t * @param {WorkerPublicPath=} workerPublicPath worker public path\n\t */\n\tconstructor(chunkLoading, wasmLoading, module, workerPublicPath) {\n\t\tthis._chunkLoading = chunkLoading;\n\t\tthis._wasmLoading = wasmLoading;\n\t\tthis._module = module;\n\t\tthis._workerPublicPath = workerPublicPath;\n\t}\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tif (this._chunkLoading) {\n\t\t\tnew EnableChunkLoadingPlugin(this._chunkLoading).apply(compiler);\n\t\t}\n\t\tif (this._wasmLoading) {\n\t\t\tnew EnableWasmLoadingPlugin(this._wasmLoading).apply(compiler);\n\t\t}\n\t\tconst cachedContextify = contextify.bindContextCache(\n\t\t\tcompiler.context,\n\t\t\tcompiler.root\n\t\t);\n\t\tcompiler.hooks.thisCompilation.tap(\n\t\t\tPLUGIN_NAME,\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tWorkerDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tWorkerDependency,\n\t\t\t\t\tnew WorkerDependency.Template()\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tCreateScriptUrlDependency,\n\t\t\t\t\tnew CreateScriptUrlDependency.Template()\n\t\t\t\t);\n\n\t\t\t\t/**\n\t\t\t\t * @param {JavascriptParser} parser the parser\n\t\t\t\t * @param {Expression} expr expression\n\t\t\t\t * @returns {[BasicEvaluatedExpression, [number, number]] | void} parsed\n\t\t\t\t */\n\t\t\t\tconst parseModuleUrl = (parser, expr) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\texpr.type !== \"NewExpression\" ||\n\t\t\t\t\t\texpr.callee.type === \"Super\" ||\n\t\t\t\t\t\texpr.arguments.length !== 2\n\t\t\t\t\t)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tconst [arg1, arg2] = expr.arguments;\n\t\t\t\t\tif (arg1.type === \"SpreadElement\") return;\n\t\t\t\t\tif (arg2.type === \"SpreadElement\") return;\n\t\t\t\t\tconst callee = parser.evaluateExpression(expr.callee);\n\t\t\t\t\tif (!callee.isIdentifier() || callee.identifier !== \"URL\") return;\n\t\t\t\t\tconst arg2Value = parser.evaluateExpression(arg2);\n\t\t\t\t\tif (\n\t\t\t\t\t\t!arg2Value.isString() ||\n\t\t\t\t\t\t!(/** @type {string} */ (arg2Value.string).startsWith(\"file://\")) ||\n\t\t\t\t\t\targ2Value.string !== getUrl(parser.state.module)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst arg1Value = parser.evaluateExpression(arg1);\n\t\t\t\t\treturn [\n\t\t\t\t\t\targ1Value,\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t/** @type {Range} */ (arg1.range)[0],\n\t\t\t\t\t\t\t/** @type {Range} */ (arg2.range)[1]\n\t\t\t\t\t\t]\n\t\t\t\t\t];\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * @param {JavascriptParser} parser the parser\n\t\t\t\t * @param {ObjectExpression} expr expression\n\t\t\t\t * @returns {{ expressions: Record<string, Expression | Pattern>, otherElements: (Property | SpreadElement)[], values: Record<string, any>, spread: boolean, insertType: \"comma\" | \"single\", insertLocation: number }} parsed object\n\t\t\t\t */\n\t\t\t\tconst parseObjectExpression = (parser, expr) => {\n\t\t\t\t\t/** @type {Record<string, any>} */\n\t\t\t\t\tconst values = {};\n\t\t\t\t\t/** @type {Record<string, Expression | Pattern>} */\n\t\t\t\t\tconst expressions = {};\n\t\t\t\t\t/** @type {(Property | SpreadElement)[]} */\n\t\t\t\t\tconst otherElements = [];\n\t\t\t\t\tlet spread = false;\n\t\t\t\t\tfor (const prop of expr.properties) {\n\t\t\t\t\t\tif (prop.type === \"SpreadElement\") {\n\t\t\t\t\t\t\tspread = true;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tprop.type === \"Property\" &&\n\t\t\t\t\t\t\t!prop.method &&\n\t\t\t\t\t\t\t!prop.computed &&\n\t\t\t\t\t\t\tprop.key.type === \"Identifier\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\texpressions[prop.key.name] = prop.value;\n\t\t\t\t\t\t\tif (!prop.shorthand && !prop.value.type.endsWith(\"Pattern\")) {\n\t\t\t\t\t\t\t\tconst value = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {Expression} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (value.isCompileTimeValue())\n\t\t\t\t\t\t\t\t\tvalues[prop.key.name] = value.asCompileTimeValue();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\totherElements.push(prop);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst insertType = expr.properties.length > 0 ? \"comma\" : \"single\";\n\t\t\t\t\tconst insertLocation = /** @type {Range} */ (\n\t\t\t\t\t\texpr.properties[expr.properties.length - 1].range\n\t\t\t\t\t)[1];\n\t\t\t\t\treturn {\n\t\t\t\t\t\texpressions,\n\t\t\t\t\t\totherElements,\n\t\t\t\t\t\tvalues,\n\t\t\t\t\t\tspread,\n\t\t\t\t\t\tinsertType,\n\t\t\t\t\t\tinsertLocation\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * @param {Parser} parser parser parser\n\t\t\t\t * @param {JavascriptParserOptions} parserOptions parserOptions\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst parserPlugin = (parser, parserOptions) => {\n\t\t\t\t\tif (parserOptions.worker === false) return;\n\t\t\t\t\tconst options = !Array.isArray(parserOptions.worker)\n\t\t\t\t\t\t? [\"...\"]\n\t\t\t\t\t\t: parserOptions.worker;\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {CallExpression} expr expression\n\t\t\t\t\t * @returns {boolean | void} true when handled\n\t\t\t\t\t */\n\t\t\t\t\tconst handleNewWorker = expr => {\n\t\t\t\t\t\tif (expr.arguments.length === 0 || expr.arguments.length > 2)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tconst [arg1, arg2] = expr.arguments;\n\t\t\t\t\t\tif (arg1.type === \"SpreadElement\") return;\n\t\t\t\t\t\tif (arg2 && arg2.type === \"SpreadElement\") return;\n\t\t\t\t\t\tconst parsedUrl = parseModuleUrl(parser, arg1);\n\t\t\t\t\t\tif (!parsedUrl) return;\n\t\t\t\t\t\tconst [url, range] = parsedUrl;\n\t\t\t\t\t\tif (!url.isString()) return;\n\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\texpressions,\n\t\t\t\t\t\t\totherElements,\n\t\t\t\t\t\t\tvalues: options,\n\t\t\t\t\t\t\tspread: hasSpreadInOptions,\n\t\t\t\t\t\t\tinsertType,\n\t\t\t\t\t\t\tinsertLocation\n\t\t\t\t\t\t} = arg2 && arg2.type === \"ObjectExpression\"\n\t\t\t\t\t\t\t? parseObjectExpression(parser, arg2)\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t/** @type {Record<string, Expression | Pattern>} */\n\t\t\t\t\t\t\t\t\texpressions: {},\n\t\t\t\t\t\t\t\t\totherElements: [],\n\t\t\t\t\t\t\t\t\t/** @type {Record<string, any>} */\n\t\t\t\t\t\t\t\t\tvalues: {},\n\t\t\t\t\t\t\t\t\tspread: false,\n\t\t\t\t\t\t\t\t\tinsertType: arg2 ? \"spread\" : \"argument\",\n\t\t\t\t\t\t\t\t\tinsertLocation: arg2\n\t\t\t\t\t\t\t\t\t\t? /** @type {Range} */ (arg2.range)\n\t\t\t\t\t\t\t\t\t\t: /** @type {Range} */ (arg1.range)[1]\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\tconst { options: importOptions, errors: commentErrors } =\n\t\t\t\t\t\t\tparser.parseCommentOptions(/** @type {Range} */ (expr.range));\n\n\t\t\t\t\t\tif (commentErrors) {\n\t\t\t\t\t\t\tfor (const e of commentErrors) {\n\t\t\t\t\t\t\t\tconst { comment } = e;\n\t\t\t\t\t\t\t\tparser.state.module.addWarning(\n\t\t\t\t\t\t\t\t\tnew CommentCompilationWarning(\n\t\t\t\t\t\t\t\t\t\t`Compilation error while processing magic comment(-s): /*${comment.value}*/: ${e.message}`,\n\t\t\t\t\t\t\t\t\t\tcomment.loc\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/** @type {EntryOptions} */\n\t\t\t\t\t\tlet entryOptions = {};\n\n\t\t\t\t\t\tif (importOptions) {\n\t\t\t\t\t\t\tif (importOptions.webpackIgnore !== undefined) {\n\t\t\t\t\t\t\t\tif (typeof importOptions.webpackIgnore !== \"boolean\") {\n\t\t\t\t\t\t\t\t\tparser.state.module.addWarning(\n\t\t\t\t\t\t\t\t\t\tnew UnsupportedFeatureWarning(\n\t\t\t\t\t\t\t\t\t\t\t`\\`webpackIgnore\\` expected a boolean, but received: ${importOptions.webpackIgnore}.`,\n\t\t\t\t\t\t\t\t\t\t\t/** @type {DependencyLocation} */ (expr.loc)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (importOptions.webpackIgnore) {\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (importOptions.webpackEntryOptions !== undefined) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\ttypeof importOptions.webpackEntryOptions !== \"object\" ||\n\t\t\t\t\t\t\t\t\timportOptions.webpackEntryOptions === null\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tparser.state.module.addWarning(\n\t\t\t\t\t\t\t\t\t\tnew UnsupportedFeatureWarning(\n\t\t\t\t\t\t\t\t\t\t\t`\\`webpackEntryOptions\\` expected a object, but received: ${importOptions.webpackEntryOptions}.`,\n\t\t\t\t\t\t\t\t\t\t\t/** @type {DependencyLocation} */ (expr.loc)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tObject.assign(\n\t\t\t\t\t\t\t\t\t\tentryOptions,\n\t\t\t\t\t\t\t\t\t\timportOptions.webpackEntryOptions\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (importOptions.webpackChunkName !== undefined) {\n\t\t\t\t\t\t\t\tif (typeof importOptions.webpackChunkName !== \"string\") {\n\t\t\t\t\t\t\t\t\tparser.state.module.addWarning(\n\t\t\t\t\t\t\t\t\t\tnew UnsupportedFeatureWarning(\n\t\t\t\t\t\t\t\t\t\t\t`\\`webpackChunkName\\` expected a string, but received: ${importOptions.webpackChunkName}.`,\n\t\t\t\t\t\t\t\t\t\t\t/** @type {DependencyLocation} */ (expr.loc)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tentryOptions.name = importOptions.webpackChunkName;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!Object.prototype.hasOwnProperty.call(entryOptions, \"name\") &&\n\t\t\t\t\t\t\toptions &&\n\t\t\t\t\t\t\ttypeof options.name === \"string\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tentryOptions.name = options.name;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (entryOptions.runtime === undefined) {\n\t\t\t\t\t\t\tlet i = workerIndexMap.get(parser.state) || 0;\n\t\t\t\t\t\t\tworkerIndexMap.set(parser.state, i + 1);\n\t\t\t\t\t\t\tlet name = `${cachedContextify(\n\t\t\t\t\t\t\t\tparser.state.module.identifier()\n\t\t\t\t\t\t\t)}|${i}`;\n\t\t\t\t\t\t\tconst hash = createHash(compilation.outputOptions.hashFunction);\n\t\t\t\t\t\t\thash.update(name);\n\t\t\t\t\t\t\tconst digest = /** @type {string} */ (\n\t\t\t\t\t\t\t\thash.digest(compilation.outputOptions.hashDigest)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tentryOptions.runtime = digest.slice(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tcompilation.outputOptions.hashDigestLength\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst block = new AsyncDependenciesBlock({\n\t\t\t\t\t\t\tname: entryOptions.name,\n\t\t\t\t\t\t\tentryOptions: {\n\t\t\t\t\t\t\t\tchunkLoading: this._chunkLoading,\n\t\t\t\t\t\t\t\twasmLoading: this._wasmLoading,\n\t\t\t\t\t\t\t\t...entryOptions\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tblock.loc = expr.loc;\n\t\t\t\t\t\tconst dep = new WorkerDependency(\n\t\t\t\t\t\t\t/** @type {string} */ (url.string),\n\t\t\t\t\t\t\trange,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpublicPath: this._workerPublicPath\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\t\t\tblock.addDependency(dep);\n\t\t\t\t\t\tparser.state.module.addBlock(block);\n\n\t\t\t\t\t\tif (compilation.outputOptions.trustedTypes) {\n\t\t\t\t\t\t\tconst dep = new CreateScriptUrlDependency(\n\t\t\t\t\t\t\t\t/** @type {Range} */ (expr.arguments[0].range)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (expressions.type) {\n\t\t\t\t\t\t\tconst expr = expressions.type;\n\t\t\t\t\t\t\tif (options.type !== false) {\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\tthis._module ? '\"module\"' : \"undefined\",\n\t\t\t\t\t\t\t\t\t/** @type {Range} */ (expr.range)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\t/** @type {TODO} */\n\t\t\t\t\t\t\t\t(expressions).type = undefined;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (insertType === \"comma\") {\n\t\t\t\t\t\t\tif (this._module || hasSpreadInOptions) {\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\t`, type: ${this._module ? '\"module\"' : \"undefined\"}`,\n\t\t\t\t\t\t\t\t\tinsertLocation\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (insertType === \"spread\") {\n\t\t\t\t\t\t\tconst dep1 = new ConstDependency(\n\t\t\t\t\t\t\t\t\"Object.assign({}, \",\n\t\t\t\t\t\t\t\t/** @type {Range} */ (insertLocation)[0]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst dep2 = new ConstDependency(\n\t\t\t\t\t\t\t\t`, { type: ${this._module ? '\"module\"' : \"undefined\"} })`,\n\t\t\t\t\t\t\t\t/** @type {Range} */ (insertLocation)[1]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdep1.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\t\t\t\tdep2.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep1);\n\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep2);\n\t\t\t\t\t\t} else if (insertType === \"argument\") {\n\t\t\t\t\t\t\tif (this._module) {\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\t', { type: \"module\" }',\n\t\t\t\t\t\t\t\t\tinsertLocation\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparser.walkExpression(expr.callee);\n\t\t\t\t\t\tfor (const key of Object.keys(expressions)) {\n\t\t\t\t\t\t\tif (expressions[key]) parser.walkExpression(expressions[key]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const prop of otherElements) {\n\t\t\t\t\t\t\tparser.walkProperty(prop);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (insertType === \"spread\") {\n\t\t\t\t\t\t\tparser.walkExpression(arg2);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t};\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} item item\n\t\t\t\t\t */\n\t\t\t\t\tconst processItem = item => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\titem.startsWith(\"*\") &&\n\t\t\t\t\t\t\titem.includes(\".\") &&\n\t\t\t\t\t\t\titem.endsWith(\"()\")\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst firstDot = item.indexOf(\".\");\n\t\t\t\t\t\t\tconst pattern = item.slice(1, firstDot);\n\t\t\t\t\t\t\tconst itemMembers = item.slice(firstDot + 1, -2);\n\n\t\t\t\t\t\t\tparser.hooks.preDeclarator.tap(PLUGIN_NAME, (decl, statement) => {\n\t\t\t\t\t\t\t\tif (decl.id.type === \"Identifier\" && decl.id.name === pattern) {\n\t\t\t\t\t\t\t\t\tparser.tagVariable(decl.id.name, WorkerSpecifierTag);\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tparser.hooks.pattern.for(pattern).tap(PLUGIN_NAME, pattern => {\n\t\t\t\t\t\t\t\tparser.tagVariable(pattern.name, WorkerSpecifierTag);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tparser.hooks.callMemberChain\n\t\t\t\t\t\t\t\t.for(WorkerSpecifierTag)\n\t\t\t\t\t\t\t\t.tap(PLUGIN_NAME, (expression, members) => {\n\t\t\t\t\t\t\t\t\tif (itemMembers !== members.join(\".\")) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn handleNewWorker(expression);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else if (item.endsWith(\"()\")) {\n\t\t\t\t\t\t\tparser.hooks.call\n\t\t\t\t\t\t\t\t.for(item.slice(0, -2))\n\t\t\t\t\t\t\t\t.tap(PLUGIN_NAME, handleNewWorker);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst match = /^(.+?)(\\(\\))?\\s+from\\s+(.+)$/.exec(item);\n\t\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\t\tconst ids = match[1].split(\".\");\n\t\t\t\t\t\t\t\tconst call = match[2];\n\t\t\t\t\t\t\t\tconst source = match[3];\n\t\t\t\t\t\t\t\t(call ? parser.hooks.call : parser.hooks.new)\n\t\t\t\t\t\t\t\t\t.for(harmonySpecifierTag)\n\t\t\t\t\t\t\t\t\t.tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\t\t\t\tconst settings = /** @type {HarmonySettings} */ (\n\t\t\t\t\t\t\t\t\t\t\tparser.currentTagData\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!settings ||\n\t\t\t\t\t\t\t\t\t\t\tsettings.source !== source ||\n\t\t\t\t\t\t\t\t\t\t\t!equals(settings.ids, ids)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn handleNewWorker(expr);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tparser.hooks.new.for(item).tap(PLUGIN_NAME, handleNewWorker);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tfor (const item of options) {\n\t\t\t\t\t\tif (item === \"...\") {\n\t\t\t\t\t\t\tDEFAULT_SYNTAX.forEach(processItem);\n\t\t\t\t\t\t} else processItem(item);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_AUTO)\n\t\t\t\t\t.tap(PLUGIN_NAME, parserPlugin);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_ESM)\n\t\t\t\t\t.tap(PLUGIN_NAME, parserPlugin);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = WorkerPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
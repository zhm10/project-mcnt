{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\nconst webpackSchema = require(\"../schemas/WebpackOptions.json\");\n\n// TODO add originPath to PathItem for better errors\n/**\n * @typedef {Object} PathItem\n * @property {any} schema the part of the schema\n * @property {string} path the path in the config\n */\n\n/** @typedef {\"unknown-argument\" | \"unexpected-non-array-in-path\" | \"unexpected-non-object-in-path\" | \"multiple-values-unexpected\" | \"invalid-value\"} ProblemType */\n\n/**\n * @typedef {Object} Problem\n * @property {ProblemType} type\n * @property {string} path\n * @property {string} argument\n * @property {any=} value\n * @property {number=} index\n * @property {string=} expected\n */\n\n/**\n * @typedef {Object} LocalProblem\n * @property {ProblemType} type\n * @property {string} path\n * @property {string=} expected\n */\n\n/**\n * @typedef {Object} ArgumentConfig\n * @property {string} description\n * @property {string} [negatedDescription]\n * @property {string} path\n * @property {boolean} multiple\n * @property {\"enum\"|\"string\"|\"path\"|\"number\"|\"boolean\"|\"RegExp\"|\"reset\"} type\n * @property {any[]=} values\n */\n\n/**\n * @typedef {Object} Argument\n * @property {string} description\n * @property {\"string\"|\"number\"|\"boolean\"} simpleType\n * @property {boolean} multiple\n * @property {ArgumentConfig[]} configs\n */\n\n/**\n * @param {any=} schema a json schema to create arguments for (by default webpack schema is used)\n * @returns {Record<string, Argument>} object of arguments\n */\nconst getArguments = (schema = webpackSchema) => {\n  /** @type {Record<string, Argument>} */\n  const flags = {};\n  const pathToArgumentName = input => {\n    return input.replace(/\\./g, \"-\").replace(/\\[\\]/g, \"\").replace(/(\\p{Uppercase_Letter}+|\\p{Lowercase_Letter}|\\d)(\\p{Uppercase_Letter}+)/gu, \"$1-$2\").replace(/-?[^\\p{Uppercase_Letter}\\p{Lowercase_Letter}\\d]+/gu, \"-\").toLowerCase();\n  };\n  const getSchemaPart = path => {\n    const newPath = path.split(\"/\");\n    let schemaPart = schema;\n    for (let i = 1; i < newPath.length; i++) {\n      const inner = schemaPart[newPath[i]];\n      if (!inner) {\n        break;\n      }\n      schemaPart = inner;\n    }\n    return schemaPart;\n  };\n\n  /**\n   *\n   * @param {PathItem[]} path path in the schema\n   * @returns {string | undefined} description\n   */\n  const getDescription = path => {\n    for (const {\n      schema\n    } of path) {\n      if (schema.cli) {\n        if (schema.cli.helper) continue;\n        if (schema.cli.description) return schema.cli.description;\n      }\n      if (schema.description) return schema.description;\n    }\n  };\n\n  /**\n   *\n   * @param {PathItem[]} path path in the schema\n   * @returns {string | undefined} negative description\n   */\n  const getNegatedDescription = path => {\n    for (const {\n      schema\n    } of path) {\n      if (schema.cli) {\n        if (schema.cli.helper) continue;\n        if (schema.cli.negatedDescription) return schema.cli.negatedDescription;\n      }\n    }\n  };\n\n  /**\n   *\n   * @param {PathItem[]} path path in the schema\n   * @returns {string | undefined} reset description\n   */\n  const getResetDescription = path => {\n    for (const {\n      schema\n    } of path) {\n      if (schema.cli) {\n        if (schema.cli.helper) continue;\n        if (schema.cli.resetDescription) return schema.cli.resetDescription;\n      }\n    }\n  };\n\n  /**\n   *\n   * @param {any} schemaPart schema\n   * @returns {Pick<ArgumentConfig, \"type\"|\"values\">} partial argument config\n   */\n  const schemaToArgumentConfig = schemaPart => {\n    if (schemaPart.enum) {\n      return {\n        type: \"enum\",\n        values: schemaPart.enum\n      };\n    }\n    switch (schemaPart.type) {\n      case \"number\":\n        return {\n          type: \"number\"\n        };\n      case \"string\":\n        return {\n          type: schemaPart.absolutePath ? \"path\" : \"string\"\n        };\n      case \"boolean\":\n        return {\n          type: \"boolean\"\n        };\n    }\n    if (schemaPart.instanceof === \"RegExp\") {\n      return {\n        type: \"RegExp\"\n      };\n    }\n    return undefined;\n  };\n\n  /**\n   * @param {PathItem[]} path path in the schema\n   * @returns {void}\n   */\n  const addResetFlag = path => {\n    const schemaPath = path[0].path;\n    const name = pathToArgumentName(`${schemaPath}.reset`);\n    const description = getResetDescription(path) || `Clear all items provided in '${schemaPath}' configuration. ${getDescription(path)}`;\n    flags[name] = {\n      configs: [{\n        type: \"reset\",\n        multiple: false,\n        description,\n        path: schemaPath\n      }],\n      description: undefined,\n      simpleType: undefined,\n      multiple: undefined\n    };\n  };\n\n  /**\n   * @param {PathItem[]} path full path in schema\n   * @param {boolean} multiple inside of an array\n   * @returns {number} number of arguments added\n   */\n  const addFlag = (path, multiple) => {\n    const argConfigBase = schemaToArgumentConfig(path[0].schema);\n    if (!argConfigBase) return 0;\n    const negatedDescription = getNegatedDescription(path);\n    const name = pathToArgumentName(path[0].path);\n    /** @type {ArgumentConfig} */\n    const argConfig = {\n      ...argConfigBase,\n      multiple,\n      description: getDescription(path),\n      path: path[0].path\n    };\n    if (negatedDescription) {\n      argConfig.negatedDescription = negatedDescription;\n    }\n    if (!flags[name]) {\n      flags[name] = {\n        configs: [],\n        description: undefined,\n        simpleType: undefined,\n        multiple: undefined\n      };\n    }\n    if (flags[name].configs.some(item => JSON.stringify(item) === JSON.stringify(argConfig))) {\n      return 0;\n    }\n    if (flags[name].configs.some(item => item.type === argConfig.type && item.multiple !== multiple)) {\n      if (multiple) {\n        throw new Error(`Conflicting schema for ${path[0].path} with ${argConfig.type} type (array type must be before single item type)`);\n      }\n      return 0;\n    }\n    flags[name].configs.push(argConfig);\n    return 1;\n  };\n\n  // TODO support `not` and `if/then/else`\n  // TODO support `const`, but we don't use it on our schema\n  /**\n   *\n   * @param {object} schemaPart the current schema\n   * @param {string} schemaPath the current path in the schema\n   * @param {{schema: object, path: string}[]} path all previous visited schemaParts\n   * @param {string | null} inArray if inside of an array, the path to the array\n   * @returns {number} added arguments\n   */\n  const traverse = (schemaPart, schemaPath = \"\", path = [], inArray = null) => {\n    while (schemaPart.$ref) {\n      schemaPart = getSchemaPart(schemaPart.$ref);\n    }\n    const repetitions = path.filter(({\n      schema\n    }) => schema === schemaPart);\n    if (repetitions.length >= 2 || repetitions.some(({\n      path\n    }) => path === schemaPath)) {\n      return 0;\n    }\n    if (schemaPart.cli && schemaPart.cli.exclude) return 0;\n    const fullPath = [{\n      schema: schemaPart,\n      path: schemaPath\n    }, ...path];\n    let addedArguments = 0;\n    addedArguments += addFlag(fullPath, !!inArray);\n    if (schemaPart.type === \"object\") {\n      if (schemaPart.properties) {\n        for (const property of Object.keys(schemaPart.properties)) {\n          addedArguments += traverse(schemaPart.properties[property], schemaPath ? `${schemaPath}.${property}` : property, fullPath, inArray);\n        }\n      }\n      return addedArguments;\n    }\n    if (schemaPart.type === \"array\") {\n      if (inArray) {\n        return 0;\n      }\n      if (Array.isArray(schemaPart.items)) {\n        let i = 0;\n        for (const item of schemaPart.items) {\n          addedArguments += traverse(item, `${schemaPath}.${i}`, fullPath, schemaPath);\n        }\n        return addedArguments;\n      }\n      addedArguments += traverse(schemaPart.items, `${schemaPath}[]`, fullPath, schemaPath);\n      if (addedArguments > 0) {\n        addResetFlag(fullPath);\n        addedArguments++;\n      }\n      return addedArguments;\n    }\n    const maybeOf = schemaPart.oneOf || schemaPart.anyOf || schemaPart.allOf;\n    if (maybeOf) {\n      const items = maybeOf;\n      for (let i = 0; i < items.length; i++) {\n        addedArguments += traverse(items[i], schemaPath, fullPath, inArray);\n      }\n      return addedArguments;\n    }\n    return addedArguments;\n  };\n  traverse(schema);\n\n  // Summarize flags\n  for (const name of Object.keys(flags)) {\n    const argument = flags[name];\n    argument.description = argument.configs.reduce((desc, {\n      description\n    }) => {\n      if (!desc) return description;\n      if (!description) return desc;\n      if (desc.includes(description)) return desc;\n      return `${desc} ${description}`;\n    }, /** @type {string | undefined} */undefined);\n    argument.simpleType = argument.configs.reduce((t, argConfig) => {\n      /** @type {\"string\" | \"number\" | \"boolean\"} */\n      let type = \"string\";\n      switch (argConfig.type) {\n        case \"number\":\n          type = \"number\";\n          break;\n        case \"reset\":\n        case \"boolean\":\n          type = \"boolean\";\n          break;\n        case \"enum\":\n          if (argConfig.values.every(v => typeof v === \"boolean\")) type = \"boolean\";\n          if (argConfig.values.every(v => typeof v === \"number\")) type = \"number\";\n          break;\n      }\n      if (t === undefined) return type;\n      return t === type ? t : \"string\";\n    }, /** @type {\"string\" | \"number\" | \"boolean\" | undefined} */undefined);\n    argument.multiple = argument.configs.some(c => c.multiple);\n  }\n  return flags;\n};\nconst cliAddedItems = new WeakMap();\n\n/**\n * @param {any} config configuration\n * @param {string} schemaPath path in the config\n * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined\n * @returns {{ problem?: LocalProblem, object?: any, property?: string | number, value?: any }} problem or object with property and value\n */\nconst getObjectAndProperty = (config, schemaPath, index = 0) => {\n  if (!schemaPath) return {\n    value: config\n  };\n  const parts = schemaPath.split(\".\");\n  let property = parts.pop();\n  let current = config;\n  let i = 0;\n  for (const part of parts) {\n    const isArray = part.endsWith(\"[]\");\n    const name = isArray ? part.slice(0, -2) : part;\n    let value = current[name];\n    if (isArray) {\n      if (value === undefined) {\n        value = {};\n        current[name] = [...Array.from({\n          length: index\n        }), value];\n        cliAddedItems.set(current[name], index + 1);\n      } else if (!Array.isArray(value)) {\n        return {\n          problem: {\n            type: \"unexpected-non-array-in-path\",\n            path: parts.slice(0, i).join(\".\")\n          }\n        };\n      } else {\n        let addedItems = cliAddedItems.get(value) || 0;\n        while (addedItems <= index) {\n          value.push(undefined);\n          addedItems++;\n        }\n        cliAddedItems.set(value, addedItems);\n        const x = value.length - addedItems + index;\n        if (value[x] === undefined) {\n          value[x] = {};\n        } else if (value[x] === null || typeof value[x] !== \"object\") {\n          return {\n            problem: {\n              type: \"unexpected-non-object-in-path\",\n              path: parts.slice(0, i).join(\".\")\n            }\n          };\n        }\n        value = value[x];\n      }\n    } else {\n      if (value === undefined) {\n        value = current[name] = {};\n      } else if (value === null || typeof value !== \"object\") {\n        return {\n          problem: {\n            type: \"unexpected-non-object-in-path\",\n            path: parts.slice(0, i).join(\".\")\n          }\n        };\n      }\n    }\n    current = value;\n    i++;\n  }\n  let value = current[property];\n  if (property.endsWith(\"[]\")) {\n    const name = property.slice(0, -2);\n    const value = current[name];\n    if (value === undefined) {\n      current[name] = [...Array.from({\n        length: index\n      }), undefined];\n      cliAddedItems.set(current[name], index + 1);\n      return {\n        object: current[name],\n        property: index,\n        value: undefined\n      };\n    } else if (!Array.isArray(value)) {\n      current[name] = [value, ...Array.from({\n        length: index\n      }), undefined];\n      cliAddedItems.set(current[name], index + 1);\n      return {\n        object: current[name],\n        property: index + 1,\n        value: undefined\n      };\n    } else {\n      let addedItems = cliAddedItems.get(value) || 0;\n      while (addedItems <= index) {\n        value.push(undefined);\n        addedItems++;\n      }\n      cliAddedItems.set(value, addedItems);\n      const x = value.length - addedItems + index;\n      if (value[x] === undefined) {\n        value[x] = {};\n      } else if (value[x] === null || typeof value[x] !== \"object\") {\n        return {\n          problem: {\n            type: \"unexpected-non-object-in-path\",\n            path: schemaPath\n          }\n        };\n      }\n      return {\n        object: value,\n        property: x,\n        value: value[x]\n      };\n    }\n  }\n  return {\n    object: current,\n    property,\n    value\n  };\n};\n\n/**\n * @param {any} config configuration\n * @param {string} schemaPath path in the config\n * @param {any} value parsed value\n * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined\n * @returns {LocalProblem | null} problem or null for success\n */\nconst setValue = (config, schemaPath, value, index) => {\n  const {\n    problem,\n    object,\n    property\n  } = getObjectAndProperty(config, schemaPath, index);\n  if (problem) return problem;\n  object[property] = value;\n  return null;\n};\n\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @param {any} config configuration\n * @param {any} value the value\n * @param {number | undefined} index the index if multiple values provided\n * @returns {LocalProblem | null} a problem if any\n */\nconst processArgumentConfig = (argConfig, config, value, index) => {\n  if (index !== undefined && !argConfig.multiple) {\n    return {\n      type: \"multiple-values-unexpected\",\n      path: argConfig.path\n    };\n  }\n  const parsed = parseValueForArgumentConfig(argConfig, value);\n  if (parsed === undefined) {\n    return {\n      type: \"invalid-value\",\n      path: argConfig.path,\n      expected: getExpectedValue(argConfig)\n    };\n  }\n  const problem = setValue(config, argConfig.path, parsed, index);\n  if (problem) return problem;\n  return null;\n};\n\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @returns {string | undefined} expected message\n */\nconst getExpectedValue = argConfig => {\n  switch (argConfig.type) {\n    default:\n      return argConfig.type;\n    case \"boolean\":\n      return \"true | false\";\n    case \"RegExp\":\n      return \"regular expression (example: /ab?c*/)\";\n    case \"enum\":\n      return argConfig.values.map(v => `${v}`).join(\" | \");\n    case \"reset\":\n      return \"true (will reset the previous value to an empty array)\";\n  }\n};\n\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @param {any} value the value\n * @returns {any | undefined} parsed value\n */\nconst parseValueForArgumentConfig = (argConfig, value) => {\n  switch (argConfig.type) {\n    case \"string\":\n      if (typeof value === \"string\") {\n        return value;\n      }\n      break;\n    case \"path\":\n      if (typeof value === \"string\") {\n        return path.resolve(value);\n      }\n      break;\n    case \"number\":\n      if (typeof value === \"number\") return value;\n      if (typeof value === \"string\" && /^[+-]?\\d*(\\.\\d*)[eE]\\d+$/) {\n        const n = +value;\n        if (!isNaN(n)) return n;\n      }\n      break;\n    case \"boolean\":\n      if (typeof value === \"boolean\") return value;\n      if (value === \"true\") return true;\n      if (value === \"false\") return false;\n      break;\n    case \"RegExp\":\n      if (value instanceof RegExp) return value;\n      if (typeof value === \"string\") {\n        // cspell:word yugi\n        const match = /^\\/(.*)\\/([yugi]*)$/.exec(value);\n        if (match && !/[^\\\\]\\//.test(match[1])) return new RegExp(match[1], match[2]);\n      }\n      break;\n    case \"enum\":\n      if (argConfig.values.includes(value)) return value;\n      for (const item of argConfig.values) {\n        if (`${item}` === value) return item;\n      }\n      break;\n    case \"reset\":\n      if (value === true) return [];\n      break;\n  }\n};\n\n/**\n * @param {Record<string, Argument>} args object of arguments\n * @param {any} config configuration\n * @param {Record<string, string | number | boolean | RegExp | (string | number | boolean | RegExp)[]>} values object with values\n * @returns {Problem[] | null} problems or null for success\n */\nconst processArguments = (args, config, values) => {\n  /** @type {Problem[]} */\n  const problems = [];\n  for (const key of Object.keys(values)) {\n    const arg = args[key];\n    if (!arg) {\n      problems.push({\n        type: \"unknown-argument\",\n        path: \"\",\n        argument: key\n      });\n      continue;\n    }\n    const processValue = (value, i) => {\n      const currentProblems = [];\n      for (const argConfig of arg.configs) {\n        const problem = processArgumentConfig(argConfig, config, value, i);\n        if (!problem) {\n          return;\n        }\n        currentProblems.push({\n          ...problem,\n          argument: key,\n          value: value,\n          index: i\n        });\n      }\n      problems.push(...currentProblems);\n    };\n    let value = values[key];\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        processValue(value[i], i);\n      }\n    } else {\n      processValue(value, undefined);\n    }\n  }\n  if (problems.length === 0) return null;\n  return problems;\n};\nexports.getArguments = getArguments;\nexports.processArguments = processArguments;","map":{"version":3,"names":["path","require","webpackSchema","getArguments","schema","flags","pathToArgumentName","input","replace","toLowerCase","getSchemaPart","newPath","split","schemaPart","i","length","inner","getDescription","cli","helper","description","getNegatedDescription","negatedDescription","getResetDescription","resetDescription","schemaToArgumentConfig","enum","type","values","absolutePath","instanceof","undefined","addResetFlag","schemaPath","name","configs","multiple","simpleType","addFlag","argConfigBase","argConfig","some","item","JSON","stringify","Error","push","traverse","inArray","$ref","repetitions","filter","exclude","fullPath","addedArguments","properties","property","Object","keys","Array","isArray","items","maybeOf","oneOf","anyOf","allOf","argument","reduce","desc","includes","t","every","v","c","cliAddedItems","WeakMap","getObjectAndProperty","config","index","value","parts","pop","current","part","endsWith","slice","from","set","problem","join","addedItems","get","x","object","setValue","processArgumentConfig","parsed","parseValueForArgumentConfig","expected","getExpectedValue","map","resolve","n","isNaN","RegExp","match","exec","test","processArguments","args","problems","key","arg","processValue","currentProblems","exports"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/cli.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\nconst webpackSchema = require(\"../schemas/WebpackOptions.json\");\n\n// TODO add originPath to PathItem for better errors\n/**\n * @typedef {Object} PathItem\n * @property {any} schema the part of the schema\n * @property {string} path the path in the config\n */\n\n/** @typedef {\"unknown-argument\" | \"unexpected-non-array-in-path\" | \"unexpected-non-object-in-path\" | \"multiple-values-unexpected\" | \"invalid-value\"} ProblemType */\n\n/**\n * @typedef {Object} Problem\n * @property {ProblemType} type\n * @property {string} path\n * @property {string} argument\n * @property {any=} value\n * @property {number=} index\n * @property {string=} expected\n */\n\n/**\n * @typedef {Object} LocalProblem\n * @property {ProblemType} type\n * @property {string} path\n * @property {string=} expected\n */\n\n/**\n * @typedef {Object} ArgumentConfig\n * @property {string} description\n * @property {string} [negatedDescription]\n * @property {string} path\n * @property {boolean} multiple\n * @property {\"enum\"|\"string\"|\"path\"|\"number\"|\"boolean\"|\"RegExp\"|\"reset\"} type\n * @property {any[]=} values\n */\n\n/**\n * @typedef {Object} Argument\n * @property {string} description\n * @property {\"string\"|\"number\"|\"boolean\"} simpleType\n * @property {boolean} multiple\n * @property {ArgumentConfig[]} configs\n */\n\n/**\n * @param {any=} schema a json schema to create arguments for (by default webpack schema is used)\n * @returns {Record<string, Argument>} object of arguments\n */\nconst getArguments = (schema = webpackSchema) => {\n\t/** @type {Record<string, Argument>} */\n\tconst flags = {};\n\n\tconst pathToArgumentName = input => {\n\t\treturn input\n\t\t\t.replace(/\\./g, \"-\")\n\t\t\t.replace(/\\[\\]/g, \"\")\n\t\t\t.replace(\n\t\t\t\t/(\\p{Uppercase_Letter}+|\\p{Lowercase_Letter}|\\d)(\\p{Uppercase_Letter}+)/gu,\n\t\t\t\t\"$1-$2\"\n\t\t\t)\n\t\t\t.replace(/-?[^\\p{Uppercase_Letter}\\p{Lowercase_Letter}\\d]+/gu, \"-\")\n\t\t\t.toLowerCase();\n\t};\n\n\tconst getSchemaPart = path => {\n\t\tconst newPath = path.split(\"/\");\n\n\t\tlet schemaPart = schema;\n\n\t\tfor (let i = 1; i < newPath.length; i++) {\n\t\t\tconst inner = schemaPart[newPath[i]];\n\n\t\t\tif (!inner) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tschemaPart = inner;\n\t\t}\n\n\t\treturn schemaPart;\n\t};\n\n\t/**\n\t *\n\t * @param {PathItem[]} path path in the schema\n\t * @returns {string | undefined} description\n\t */\n\tconst getDescription = path => {\n\t\tfor (const { schema } of path) {\n\t\t\tif (schema.cli) {\n\t\t\t\tif (schema.cli.helper) continue;\n\t\t\t\tif (schema.cli.description) return schema.cli.description;\n\t\t\t}\n\t\t\tif (schema.description) return schema.description;\n\t\t}\n\t};\n\n\t/**\n\t *\n\t * @param {PathItem[]} path path in the schema\n\t * @returns {string | undefined} negative description\n\t */\n\tconst getNegatedDescription = path => {\n\t\tfor (const { schema } of path) {\n\t\t\tif (schema.cli) {\n\t\t\t\tif (schema.cli.helper) continue;\n\t\t\t\tif (schema.cli.negatedDescription) return schema.cli.negatedDescription;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t *\n\t * @param {PathItem[]} path path in the schema\n\t * @returns {string | undefined} reset description\n\t */\n\tconst getResetDescription = path => {\n\t\tfor (const { schema } of path) {\n\t\t\tif (schema.cli) {\n\t\t\t\tif (schema.cli.helper) continue;\n\t\t\t\tif (schema.cli.resetDescription) return schema.cli.resetDescription;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t *\n\t * @param {any} schemaPart schema\n\t * @returns {Pick<ArgumentConfig, \"type\"|\"values\">} partial argument config\n\t */\n\tconst schemaToArgumentConfig = schemaPart => {\n\t\tif (schemaPart.enum) {\n\t\t\treturn {\n\t\t\t\ttype: \"enum\",\n\t\t\t\tvalues: schemaPart.enum\n\t\t\t};\n\t\t}\n\t\tswitch (schemaPart.type) {\n\t\t\tcase \"number\":\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"number\"\n\t\t\t\t};\n\t\t\tcase \"string\":\n\t\t\t\treturn {\n\t\t\t\t\ttype: schemaPart.absolutePath ? \"path\" : \"string\"\n\t\t\t\t};\n\t\t\tcase \"boolean\":\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"boolean\"\n\t\t\t\t};\n\t\t}\n\t\tif (schemaPart.instanceof === \"RegExp\") {\n\t\t\treturn {\n\t\t\t\ttype: \"RegExp\"\n\t\t\t};\n\t\t}\n\t\treturn undefined;\n\t};\n\n\t/**\n\t * @param {PathItem[]} path path in the schema\n\t * @returns {void}\n\t */\n\tconst addResetFlag = path => {\n\t\tconst schemaPath = path[0].path;\n\t\tconst name = pathToArgumentName(`${schemaPath}.reset`);\n\t\tconst description =\n\t\t\tgetResetDescription(path) ||\n\t\t\t`Clear all items provided in '${schemaPath}' configuration. ${getDescription(\n\t\t\t\tpath\n\t\t\t)}`;\n\t\tflags[name] = {\n\t\t\tconfigs: [\n\t\t\t\t{\n\t\t\t\t\ttype: \"reset\",\n\t\t\t\t\tmultiple: false,\n\t\t\t\t\tdescription,\n\t\t\t\t\tpath: schemaPath\n\t\t\t\t}\n\t\t\t],\n\t\t\tdescription: undefined,\n\t\t\tsimpleType: undefined,\n\t\t\tmultiple: undefined\n\t\t};\n\t};\n\n\t/**\n\t * @param {PathItem[]} path full path in schema\n\t * @param {boolean} multiple inside of an array\n\t * @returns {number} number of arguments added\n\t */\n\tconst addFlag = (path, multiple) => {\n\t\tconst argConfigBase = schemaToArgumentConfig(path[0].schema);\n\t\tif (!argConfigBase) return 0;\n\n\t\tconst negatedDescription = getNegatedDescription(path);\n\t\tconst name = pathToArgumentName(path[0].path);\n\t\t/** @type {ArgumentConfig} */\n\t\tconst argConfig = {\n\t\t\t...argConfigBase,\n\t\t\tmultiple,\n\t\t\tdescription: getDescription(path),\n\t\t\tpath: path[0].path\n\t\t};\n\n\t\tif (negatedDescription) {\n\t\t\targConfig.negatedDescription = negatedDescription;\n\t\t}\n\n\t\tif (!flags[name]) {\n\t\t\tflags[name] = {\n\t\t\t\tconfigs: [],\n\t\t\t\tdescription: undefined,\n\t\t\t\tsimpleType: undefined,\n\t\t\t\tmultiple: undefined\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tflags[name].configs.some(\n\t\t\t\titem => JSON.stringify(item) === JSON.stringify(argConfig)\n\t\t\t)\n\t\t) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (\n\t\t\tflags[name].configs.some(\n\t\t\t\titem => item.type === argConfig.type && item.multiple !== multiple\n\t\t\t)\n\t\t) {\n\t\t\tif (multiple) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Conflicting schema for ${path[0].path} with ${argConfig.type} type (array type must be before single item type)`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tflags[name].configs.push(argConfig);\n\n\t\treturn 1;\n\t};\n\n\t// TODO support `not` and `if/then/else`\n\t// TODO support `const`, but we don't use it on our schema\n\t/**\n\t *\n\t * @param {object} schemaPart the current schema\n\t * @param {string} schemaPath the current path in the schema\n\t * @param {{schema: object, path: string}[]} path all previous visited schemaParts\n\t * @param {string | null} inArray if inside of an array, the path to the array\n\t * @returns {number} added arguments\n\t */\n\tconst traverse = (schemaPart, schemaPath = \"\", path = [], inArray = null) => {\n\t\twhile (schemaPart.$ref) {\n\t\t\tschemaPart = getSchemaPart(schemaPart.$ref);\n\t\t}\n\n\t\tconst repetitions = path.filter(({ schema }) => schema === schemaPart);\n\t\tif (\n\t\t\trepetitions.length >= 2 ||\n\t\t\trepetitions.some(({ path }) => path === schemaPath)\n\t\t) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (schemaPart.cli && schemaPart.cli.exclude) return 0;\n\n\t\tconst fullPath = [{ schema: schemaPart, path: schemaPath }, ...path];\n\n\t\tlet addedArguments = 0;\n\n\t\taddedArguments += addFlag(fullPath, !!inArray);\n\n\t\tif (schemaPart.type === \"object\") {\n\t\t\tif (schemaPart.properties) {\n\t\t\t\tfor (const property of Object.keys(schemaPart.properties)) {\n\t\t\t\t\taddedArguments += traverse(\n\t\t\t\t\t\tschemaPart.properties[property],\n\t\t\t\t\t\tschemaPath ? `${schemaPath}.${property}` : property,\n\t\t\t\t\t\tfullPath,\n\t\t\t\t\t\tinArray\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn addedArguments;\n\t\t}\n\n\t\tif (schemaPart.type === \"array\") {\n\t\t\tif (inArray) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (Array.isArray(schemaPart.items)) {\n\t\t\t\tlet i = 0;\n\t\t\t\tfor (const item of schemaPart.items) {\n\t\t\t\t\taddedArguments += traverse(\n\t\t\t\t\t\titem,\n\t\t\t\t\t\t`${schemaPath}.${i}`,\n\t\t\t\t\t\tfullPath,\n\t\t\t\t\t\tschemaPath\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn addedArguments;\n\t\t\t}\n\n\t\t\taddedArguments += traverse(\n\t\t\t\tschemaPart.items,\n\t\t\t\t`${schemaPath}[]`,\n\t\t\t\tfullPath,\n\t\t\t\tschemaPath\n\t\t\t);\n\n\t\t\tif (addedArguments > 0) {\n\t\t\t\taddResetFlag(fullPath);\n\t\t\t\taddedArguments++;\n\t\t\t}\n\n\t\t\treturn addedArguments;\n\t\t}\n\n\t\tconst maybeOf = schemaPart.oneOf || schemaPart.anyOf || schemaPart.allOf;\n\n\t\tif (maybeOf) {\n\t\t\tconst items = maybeOf;\n\n\t\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\t\taddedArguments += traverse(items[i], schemaPath, fullPath, inArray);\n\t\t\t}\n\n\t\t\treturn addedArguments;\n\t\t}\n\n\t\treturn addedArguments;\n\t};\n\n\ttraverse(schema);\n\n\t// Summarize flags\n\tfor (const name of Object.keys(flags)) {\n\t\tconst argument = flags[name];\n\t\targument.description = argument.configs.reduce((desc, { description }) => {\n\t\t\tif (!desc) return description;\n\t\t\tif (!description) return desc;\n\t\t\tif (desc.includes(description)) return desc;\n\t\t\treturn `${desc} ${description}`;\n\t\t}, /** @type {string | undefined} */ (undefined));\n\t\targument.simpleType = argument.configs.reduce((t, argConfig) => {\n\t\t\t/** @type {\"string\" | \"number\" | \"boolean\"} */\n\t\t\tlet type = \"string\";\n\t\t\tswitch (argConfig.type) {\n\t\t\t\tcase \"number\":\n\t\t\t\t\ttype = \"number\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"reset\":\n\t\t\t\tcase \"boolean\":\n\t\t\t\t\ttype = \"boolean\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"enum\":\n\t\t\t\t\tif (argConfig.values.every(v => typeof v === \"boolean\"))\n\t\t\t\t\t\ttype = \"boolean\";\n\t\t\t\t\tif (argConfig.values.every(v => typeof v === \"number\"))\n\t\t\t\t\t\ttype = \"number\";\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t === undefined) return type;\n\t\t\treturn t === type ? t : \"string\";\n\t\t}, /** @type {\"string\" | \"number\" | \"boolean\" | undefined} */ (undefined));\n\t\targument.multiple = argument.configs.some(c => c.multiple);\n\t}\n\n\treturn flags;\n};\n\nconst cliAddedItems = new WeakMap();\n\n/**\n * @param {any} config configuration\n * @param {string} schemaPath path in the config\n * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined\n * @returns {{ problem?: LocalProblem, object?: any, property?: string | number, value?: any }} problem or object with property and value\n */\nconst getObjectAndProperty = (config, schemaPath, index = 0) => {\n\tif (!schemaPath) return { value: config };\n\tconst parts = schemaPath.split(\".\");\n\tlet property = parts.pop();\n\tlet current = config;\n\tlet i = 0;\n\tfor (const part of parts) {\n\t\tconst isArray = part.endsWith(\"[]\");\n\t\tconst name = isArray ? part.slice(0, -2) : part;\n\t\tlet value = current[name];\n\t\tif (isArray) {\n\t\t\tif (value === undefined) {\n\t\t\t\tvalue = {};\n\t\t\t\tcurrent[name] = [...Array.from({ length: index }), value];\n\t\t\t\tcliAddedItems.set(current[name], index + 1);\n\t\t\t} else if (!Array.isArray(value)) {\n\t\t\t\treturn {\n\t\t\t\t\tproblem: {\n\t\t\t\t\t\ttype: \"unexpected-non-array-in-path\",\n\t\t\t\t\t\tpath: parts.slice(0, i).join(\".\")\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tlet addedItems = cliAddedItems.get(value) || 0;\n\t\t\t\twhile (addedItems <= index) {\n\t\t\t\t\tvalue.push(undefined);\n\t\t\t\t\taddedItems++;\n\t\t\t\t}\n\t\t\t\tcliAddedItems.set(value, addedItems);\n\t\t\t\tconst x = value.length - addedItems + index;\n\t\t\t\tif (value[x] === undefined) {\n\t\t\t\t\tvalue[x] = {};\n\t\t\t\t} else if (value[x] === null || typeof value[x] !== \"object\") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tproblem: {\n\t\t\t\t\t\t\ttype: \"unexpected-non-object-in-path\",\n\t\t\t\t\t\t\tpath: parts.slice(0, i).join(\".\")\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tvalue = value[x];\n\t\t\t}\n\t\t} else {\n\t\t\tif (value === undefined) {\n\t\t\t\tvalue = current[name] = {};\n\t\t\t} else if (value === null || typeof value !== \"object\") {\n\t\t\t\treturn {\n\t\t\t\t\tproblem: {\n\t\t\t\t\t\ttype: \"unexpected-non-object-in-path\",\n\t\t\t\t\t\tpath: parts.slice(0, i).join(\".\")\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tcurrent = value;\n\t\ti++;\n\t}\n\tlet value = current[property];\n\tif (property.endsWith(\"[]\")) {\n\t\tconst name = property.slice(0, -2);\n\t\tconst value = current[name];\n\t\tif (value === undefined) {\n\t\t\tcurrent[name] = [...Array.from({ length: index }), undefined];\n\t\t\tcliAddedItems.set(current[name], index + 1);\n\t\t\treturn { object: current[name], property: index, value: undefined };\n\t\t} else if (!Array.isArray(value)) {\n\t\t\tcurrent[name] = [value, ...Array.from({ length: index }), undefined];\n\t\t\tcliAddedItems.set(current[name], index + 1);\n\t\t\treturn { object: current[name], property: index + 1, value: undefined };\n\t\t} else {\n\t\t\tlet addedItems = cliAddedItems.get(value) || 0;\n\t\t\twhile (addedItems <= index) {\n\t\t\t\tvalue.push(undefined);\n\t\t\t\taddedItems++;\n\t\t\t}\n\t\t\tcliAddedItems.set(value, addedItems);\n\t\t\tconst x = value.length - addedItems + index;\n\t\t\tif (value[x] === undefined) {\n\t\t\t\tvalue[x] = {};\n\t\t\t} else if (value[x] === null || typeof value[x] !== \"object\") {\n\t\t\t\treturn {\n\t\t\t\t\tproblem: {\n\t\t\t\t\t\ttype: \"unexpected-non-object-in-path\",\n\t\t\t\t\t\tpath: schemaPath\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tobject: value,\n\t\t\t\tproperty: x,\n\t\t\t\tvalue: value[x]\n\t\t\t};\n\t\t}\n\t}\n\treturn { object: current, property, value };\n};\n\n/**\n * @param {any} config configuration\n * @param {string} schemaPath path in the config\n * @param {any} value parsed value\n * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined\n * @returns {LocalProblem | null} problem or null for success\n */\nconst setValue = (config, schemaPath, value, index) => {\n\tconst { problem, object, property } = getObjectAndProperty(\n\t\tconfig,\n\t\tschemaPath,\n\t\tindex\n\t);\n\tif (problem) return problem;\n\tobject[property] = value;\n\treturn null;\n};\n\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @param {any} config configuration\n * @param {any} value the value\n * @param {number | undefined} index the index if multiple values provided\n * @returns {LocalProblem | null} a problem if any\n */\nconst processArgumentConfig = (argConfig, config, value, index) => {\n\tif (index !== undefined && !argConfig.multiple) {\n\t\treturn {\n\t\t\ttype: \"multiple-values-unexpected\",\n\t\t\tpath: argConfig.path\n\t\t};\n\t}\n\tconst parsed = parseValueForArgumentConfig(argConfig, value);\n\tif (parsed === undefined) {\n\t\treturn {\n\t\t\ttype: \"invalid-value\",\n\t\t\tpath: argConfig.path,\n\t\t\texpected: getExpectedValue(argConfig)\n\t\t};\n\t}\n\tconst problem = setValue(config, argConfig.path, parsed, index);\n\tif (problem) return problem;\n\treturn null;\n};\n\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @returns {string | undefined} expected message\n */\nconst getExpectedValue = argConfig => {\n\tswitch (argConfig.type) {\n\t\tdefault:\n\t\t\treturn argConfig.type;\n\t\tcase \"boolean\":\n\t\t\treturn \"true | false\";\n\t\tcase \"RegExp\":\n\t\t\treturn \"regular expression (example: /ab?c*/)\";\n\t\tcase \"enum\":\n\t\t\treturn argConfig.values.map(v => `${v}`).join(\" | \");\n\t\tcase \"reset\":\n\t\t\treturn \"true (will reset the previous value to an empty array)\";\n\t}\n};\n\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @param {any} value the value\n * @returns {any | undefined} parsed value\n */\nconst parseValueForArgumentConfig = (argConfig, value) => {\n\tswitch (argConfig.type) {\n\t\tcase \"string\":\n\t\t\tif (typeof value === \"string\") {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"path\":\n\t\t\tif (typeof value === \"string\") {\n\t\t\t\treturn path.resolve(value);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"number\":\n\t\t\tif (typeof value === \"number\") return value;\n\t\t\tif (typeof value === \"string\" && /^[+-]?\\d*(\\.\\d*)[eE]\\d+$/) {\n\t\t\t\tconst n = +value;\n\t\t\t\tif (!isNaN(n)) return n;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"boolean\":\n\t\t\tif (typeof value === \"boolean\") return value;\n\t\t\tif (value === \"true\") return true;\n\t\t\tif (value === \"false\") return false;\n\t\t\tbreak;\n\t\tcase \"RegExp\":\n\t\t\tif (value instanceof RegExp) return value;\n\t\t\tif (typeof value === \"string\") {\n\t\t\t\t// cspell:word yugi\n\t\t\t\tconst match = /^\\/(.*)\\/([yugi]*)$/.exec(value);\n\t\t\t\tif (match && !/[^\\\\]\\//.test(match[1]))\n\t\t\t\t\treturn new RegExp(match[1], match[2]);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"enum\":\n\t\t\tif (argConfig.values.includes(value)) return value;\n\t\t\tfor (const item of argConfig.values) {\n\t\t\t\tif (`${item}` === value) return item;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"reset\":\n\t\t\tif (value === true) return [];\n\t\t\tbreak;\n\t}\n};\n\n/**\n * @param {Record<string, Argument>} args object of arguments\n * @param {any} config configuration\n * @param {Record<string, string | number | boolean | RegExp | (string | number | boolean | RegExp)[]>} values object with values\n * @returns {Problem[] | null} problems or null for success\n */\nconst processArguments = (args, config, values) => {\n\t/** @type {Problem[]} */\n\tconst problems = [];\n\tfor (const key of Object.keys(values)) {\n\t\tconst arg = args[key];\n\t\tif (!arg) {\n\t\t\tproblems.push({\n\t\t\t\ttype: \"unknown-argument\",\n\t\t\t\tpath: \"\",\n\t\t\t\targument: key\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tconst processValue = (value, i) => {\n\t\t\tconst currentProblems = [];\n\t\t\tfor (const argConfig of arg.configs) {\n\t\t\t\tconst problem = processArgumentConfig(argConfig, config, value, i);\n\t\t\t\tif (!problem) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentProblems.push({\n\t\t\t\t\t...problem,\n\t\t\t\t\targument: key,\n\t\t\t\t\tvalue: value,\n\t\t\t\t\tindex: i\n\t\t\t\t});\n\t\t\t}\n\t\t\tproblems.push(...currentProblems);\n\t\t};\n\t\tlet value = values[key];\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\tprocessValue(value[i], i);\n\t\t\t}\n\t\t} else {\n\t\t\tprocessValue(value, undefined);\n\t\t}\n\t}\n\tif (problems.length === 0) return null;\n\treturn problems;\n};\n\nexports.getArguments = getArguments;\nexports.processArguments = processArguments;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
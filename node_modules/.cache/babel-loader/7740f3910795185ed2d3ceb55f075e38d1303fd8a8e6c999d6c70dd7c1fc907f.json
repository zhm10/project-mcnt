{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst memoize = require(\"../util/memoize\");\nconst SerializerMiddleware = require(\"./SerializerMiddleware\");\n\n/** @typedef {import(\"./types\").BufferSerializableType} BufferSerializableType */\n/** @typedef {import(\"./types\").PrimitiveSerializableType} PrimitiveSerializableType */\n\n/*\nFormat:\n\nFile -> Section*\n\nSection -> NullsSection |\n\t\t\t\t\t BooleansSection |\n\t\t\t\t\t F64NumbersSection |\n\t\t\t\t\t I32NumbersSection |\n\t\t\t\t\t I8NumbersSection |\n\t\t\t\t\t ShortStringSection |\n\t\t\t\t\t BigIntSection |\n\t\t\t\t\t I32BigIntSection |\n\t\t\t\t\t I8BigIntSection\n\t\t\t\t\t StringSection |\n\t\t\t\t\t BufferSection |\n\t\t\t\t\t NopSection\n\n\n\nNullsSection ->\n\tNullHeaderByte | Null2HeaderByte | Null3HeaderByte |\n\tNulls8HeaderByte 0xnn (n:count - 4) |\n\tNulls32HeaderByte n:ui32 (n:count - 260) |\nBooleansSection -> TrueHeaderByte | FalseHeaderByte | BooleansSectionHeaderByte BooleansCountAndBitsByte\nF64NumbersSection -> F64NumbersSectionHeaderByte f64*\nI32NumbersSection -> I32NumbersSectionHeaderByte i32*\nI8NumbersSection -> I8NumbersSectionHeaderByte i8*\nShortStringSection -> ShortStringSectionHeaderByte ascii-byte*\nStringSection -> StringSectionHeaderByte i32:length utf8-byte*\nBufferSection -> BufferSectionHeaderByte i32:length byte*\nNopSection --> NopSectionHeaderByte\nBigIntSection -> BigIntSectionHeaderByte i32:length ascii-byte*\nI32BigIntSection -> I32BigIntSectionHeaderByte i32\nI8BigIntSection -> I8BigIntSectionHeaderByte i8\n\nShortStringSectionHeaderByte -> 0b1nnn_nnnn (n:length)\n\nF64NumbersSectionHeaderByte -> 0b001n_nnnn (n:count - 1)\nI32NumbersSectionHeaderByte -> 0b010n_nnnn (n:count - 1)\nI8NumbersSectionHeaderByte -> 0b011n_nnnn (n:count - 1)\n\nNullsSectionHeaderByte -> 0b0001_nnnn (n:count - 1)\nBooleansCountAndBitsByte ->\n\t0b0000_1xxx (count = 3) |\n\t0b0001_xxxx (count = 4) |\n\t0b001x_xxxx (count = 5) |\n\t0b01xx_xxxx (count = 6) |\n\t0b1nnn_nnnn (n:count - 7, 7 <= count <= 133)\n\t0xff n:ui32 (n:count, 134 <= count < 2^32)\n\nStringSectionHeaderByte -> 0b0000_1110\nBufferSectionHeaderByte -> 0b0000_1111\nNopSectionHeaderByte -> 0b0000_1011\nBigIntSectionHeaderByte -> 0b0001_1010\nI32BigIntSectionHeaderByte -> 0b0001_1100\nI8BigIntSectionHeaderByte -> 0b0001_1011\nFalseHeaderByte -> 0b0000_1100\nTrueHeaderByte -> 0b0000_1101\n\nRawNumber -> n (n <= 10)\n\n*/\n\nconst LAZY_HEADER = 0x0b;\nconst TRUE_HEADER = 0x0c;\nconst FALSE_HEADER = 0x0d;\nconst BOOLEANS_HEADER = 0x0e;\nconst NULL_HEADER = 0x10;\nconst NULL2_HEADER = 0x11;\nconst NULL3_HEADER = 0x12;\nconst NULLS8_HEADER = 0x13;\nconst NULLS32_HEADER = 0x14;\nconst NULL_AND_I8_HEADER = 0x15;\nconst NULL_AND_I32_HEADER = 0x16;\nconst NULL_AND_TRUE_HEADER = 0x17;\nconst NULL_AND_FALSE_HEADER = 0x18;\nconst BIGINT_HEADER = 0x1a;\nconst BIGINT_I8_HEADER = 0x1b;\nconst BIGINT_I32_HEADER = 0x1c;\nconst STRING_HEADER = 0x1e;\nconst BUFFER_HEADER = 0x1f;\nconst I8_HEADER = 0x60;\nconst I32_HEADER = 0x40;\nconst F64_HEADER = 0x20;\nconst SHORT_STRING_HEADER = 0x80;\n\n/** Uplift high-order bits */\nconst NUMBERS_HEADER_MASK = 0xe0; // 0b1010_0000\nconst NUMBERS_COUNT_MASK = 0x1f; // 0b0001_1111\nconst SHORT_STRING_LENGTH_MASK = 0x7f; // 0b0111_1111\n\nconst HEADER_SIZE = 1;\nconst I8_SIZE = 1;\nconst I32_SIZE = 4;\nconst F64_SIZE = 8;\nconst MEASURE_START_OPERATION = Symbol(\"MEASURE_START_OPERATION\");\nconst MEASURE_END_OPERATION = Symbol(\"MEASURE_END_OPERATION\");\n\n/** @typedef {typeof MEASURE_START_OPERATION} MEASURE_START_OPERATION_TYPE */\n/** @typedef {typeof MEASURE_END_OPERATION} MEASURE_END_OPERATION_TYPE */\n\n/**\n * @param {number} n number\n * @returns {0 | 1 | 2} type of number for serialization\n */\nconst identifyNumber = n => {\n  if (n === (n | 0)) {\n    if (n <= 127 && n >= -128) return 0;\n    if (n <= 2147483647 && n >= -2147483648) return 1;\n  }\n  return 2;\n};\n\n/**\n * @param {bigint} n bigint\n * @returns {0 | 1 | 2} type of bigint for serialization\n */\nconst identifyBigInt = n => {\n  if (n <= BigInt(127) && n >= BigInt(-128)) return 0;\n  if (n <= BigInt(2147483647) && n >= BigInt(-2147483648)) return 1;\n  return 2;\n};\n\n/**\n * @typedef {PrimitiveSerializableType[]} DeserializedType\n * @typedef {BufferSerializableType[]} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\nclass BinaryMiddleware extends SerializerMiddleware {\n  /**\n   * @param {DeserializedType} data data\n   * @param {Object} context context object\n   * @returns {SerializedType|Promise<SerializedType>} serialized data\n   */\n  serialize(data, context) {\n    return this._serialize(data, context);\n  }\n  _serializeLazy(fn, context) {\n    return SerializerMiddleware.serializeLazy(fn, data => this._serialize(data, context));\n  }\n\n  /**\n   * @param {DeserializedType} data data\n   * @param {Object} context context object\n   * @param {{ leftOverBuffer: Buffer | null, allocationSize: number, increaseCounter: number }} allocationScope allocation scope\n   * @returns {SerializedType} serialized data\n   */\n  _serialize(data, context, allocationScope = {\n    allocationSize: 1024,\n    increaseCounter: 0,\n    leftOverBuffer: null\n  }) {\n    /** @type {Buffer} */\n    let leftOverBuffer = null;\n    /** @type {BufferSerializableType[]} */\n    let buffers = [];\n    /** @type {Buffer} */\n    let currentBuffer = allocationScope ? allocationScope.leftOverBuffer : null;\n    allocationScope.leftOverBuffer = null;\n    let currentPosition = 0;\n    if (currentBuffer === null) {\n      currentBuffer = Buffer.allocUnsafe(allocationScope.allocationSize);\n    }\n    const allocate = bytesNeeded => {\n      if (currentBuffer !== null) {\n        if (currentBuffer.length - currentPosition >= bytesNeeded) return;\n        flush();\n      }\n      if (leftOverBuffer && leftOverBuffer.length >= bytesNeeded) {\n        currentBuffer = leftOverBuffer;\n        leftOverBuffer = null;\n      } else {\n        currentBuffer = Buffer.allocUnsafe(Math.max(bytesNeeded, allocationScope.allocationSize));\n        if (!(allocationScope.increaseCounter = (allocationScope.increaseCounter + 1) % 4) && allocationScope.allocationSize < 16777216) {\n          allocationScope.allocationSize = allocationScope.allocationSize << 1;\n        }\n      }\n    };\n    const flush = () => {\n      if (currentBuffer !== null) {\n        if (currentPosition > 0) {\n          buffers.push(Buffer.from(currentBuffer.buffer, currentBuffer.byteOffset, currentPosition));\n        }\n        if (!leftOverBuffer || leftOverBuffer.length < currentBuffer.length - currentPosition) {\n          leftOverBuffer = Buffer.from(currentBuffer.buffer, currentBuffer.byteOffset + currentPosition, currentBuffer.byteLength - currentPosition);\n        }\n        currentBuffer = null;\n        currentPosition = 0;\n      }\n    };\n    /**\n     * @param {number} byte byte\n     */\n    const writeU8 = byte => {\n      currentBuffer.writeUInt8(byte, currentPosition++);\n    };\n    /**\n     * @param {number} ui32 ui32\n     */\n    const writeU32 = ui32 => {\n      currentBuffer.writeUInt32LE(ui32, currentPosition);\n      currentPosition += 4;\n    };\n    /** @type {number[]} */\n    const measureStack = [];\n    const measureStart = () => {\n      measureStack.push(buffers.length, currentPosition);\n    };\n    /**\n     * @returns {number} size\n     */\n    const measureEnd = () => {\n      const oldPos = measureStack.pop();\n      const buffersIndex = measureStack.pop();\n      let size = currentPosition - oldPos;\n      for (let i = buffersIndex; i < buffers.length; i++) {\n        size += buffers[i].length;\n      }\n      return size;\n    };\n    for (let i = 0; i < data.length; i++) {\n      const thing = data[i];\n      switch (typeof thing) {\n        case \"function\":\n          {\n            if (!SerializerMiddleware.isLazy(thing)) throw new Error(\"Unexpected function \" + thing);\n            /** @type {SerializedType | (() => SerializedType)} */\n            let serializedData = SerializerMiddleware.getLazySerializedValue(thing);\n            if (serializedData === undefined) {\n              if (SerializerMiddleware.isLazy(thing, this)) {\n                flush();\n                allocationScope.leftOverBuffer = leftOverBuffer;\n                const result = /** @type {(Exclude<PrimitiveSerializableType, Promise<PrimitiveSerializableType>>)[]} */\n                thing();\n                const data = this._serialize(result, context, allocationScope);\n                leftOverBuffer = allocationScope.leftOverBuffer;\n                allocationScope.leftOverBuffer = null;\n                SerializerMiddleware.setLazySerializedValue(thing, data);\n                serializedData = data;\n              } else {\n                serializedData = this._serializeLazy(thing, context);\n                flush();\n                buffers.push(serializedData);\n                break;\n              }\n            } else {\n              if (typeof serializedData === \"function\") {\n                flush();\n                buffers.push(serializedData);\n                break;\n              }\n            }\n            /** @type {number[]} */\n            const lengths = [];\n            for (const item of serializedData) {\n              let last;\n              if (typeof item === \"function\") {\n                lengths.push(0);\n              } else if (item.length === 0) {\n                // ignore\n              } else if (lengths.length > 0 && (last = lengths[lengths.length - 1]) !== 0) {\n                const remaining = 0xffffffff - last;\n                if (remaining >= item.length) {\n                  lengths[lengths.length - 1] += item.length;\n                } else {\n                  lengths.push(item.length - remaining);\n                  lengths[lengths.length - 2] = 0xffffffff;\n                }\n              } else {\n                lengths.push(item.length);\n              }\n            }\n            allocate(5 + lengths.length * 4);\n            writeU8(LAZY_HEADER);\n            writeU32(lengths.length);\n            for (const l of lengths) {\n              writeU32(l);\n            }\n            flush();\n            for (const item of serializedData) {\n              buffers.push(item);\n            }\n            break;\n          }\n        case \"string\":\n          {\n            const len = Buffer.byteLength(thing);\n            if (len >= 128 || len !== thing.length) {\n              allocate(len + HEADER_SIZE + I32_SIZE);\n              writeU8(STRING_HEADER);\n              writeU32(len);\n              currentBuffer.write(thing, currentPosition);\n              currentPosition += len;\n            } else if (len >= 70) {\n              allocate(len + HEADER_SIZE);\n              writeU8(SHORT_STRING_HEADER | len);\n              currentBuffer.write(thing, currentPosition, \"latin1\");\n              currentPosition += len;\n            } else {\n              allocate(len + HEADER_SIZE);\n              writeU8(SHORT_STRING_HEADER | len);\n              for (let i = 0; i < len; i++) {\n                currentBuffer[currentPosition++] = thing.charCodeAt(i);\n              }\n            }\n            break;\n          }\n        case \"bigint\":\n          {\n            const type = identifyBigInt(thing);\n            if (type === 0 && thing >= 0 && thing <= BigInt(10)) {\n              // shortcut for very small bigints\n              allocate(HEADER_SIZE + I8_SIZE);\n              writeU8(BIGINT_I8_HEADER);\n              writeU8(Number(thing));\n              break;\n            }\n            switch (type) {\n              case 0:\n                {\n                  let n = 1;\n                  allocate(HEADER_SIZE + I8_SIZE * n);\n                  writeU8(BIGINT_I8_HEADER | n - 1);\n                  while (n > 0) {\n                    currentBuffer.writeInt8(Number( /** @type {bigint} */data[i]), currentPosition);\n                    currentPosition += I8_SIZE;\n                    n--;\n                    i++;\n                  }\n                  i--;\n                  break;\n                }\n              case 1:\n                {\n                  let n = 1;\n                  allocate(HEADER_SIZE + I32_SIZE * n);\n                  writeU8(BIGINT_I32_HEADER | n - 1);\n                  while (n > 0) {\n                    currentBuffer.writeInt32LE(Number( /** @type {bigint} */data[i]), currentPosition);\n                    currentPosition += I32_SIZE;\n                    n--;\n                    i++;\n                  }\n                  i--;\n                  break;\n                }\n              default:\n                {\n                  const value = thing.toString();\n                  const len = Buffer.byteLength(value);\n                  allocate(len + HEADER_SIZE + I32_SIZE);\n                  writeU8(BIGINT_HEADER);\n                  writeU32(len);\n                  currentBuffer.write(value, currentPosition);\n                  currentPosition += len;\n                  break;\n                }\n            }\n            break;\n          }\n        case \"number\":\n          {\n            const type = identifyNumber(thing);\n            if (type === 0 && thing >= 0 && thing <= 10) {\n              // shortcut for very small numbers\n              allocate(I8_SIZE);\n              writeU8(thing);\n              break;\n            }\n            /**\n             * amount of numbers to write\n             * @type {number}\n             */\n            let n = 1;\n            for (; n < 32 && i + n < data.length; n++) {\n              const item = data[i + n];\n              if (typeof item !== \"number\") break;\n              if (identifyNumber(item) !== type) break;\n            }\n            switch (type) {\n              case 0:\n                allocate(HEADER_SIZE + I8_SIZE * n);\n                writeU8(I8_HEADER | n - 1);\n                while (n > 0) {\n                  currentBuffer.writeInt8( /** @type {number} */data[i], currentPosition);\n                  currentPosition += I8_SIZE;\n                  n--;\n                  i++;\n                }\n                break;\n              case 1:\n                allocate(HEADER_SIZE + I32_SIZE * n);\n                writeU8(I32_HEADER | n - 1);\n                while (n > 0) {\n                  currentBuffer.writeInt32LE( /** @type {number} */data[i], currentPosition);\n                  currentPosition += I32_SIZE;\n                  n--;\n                  i++;\n                }\n                break;\n              case 2:\n                allocate(HEADER_SIZE + F64_SIZE * n);\n                writeU8(F64_HEADER | n - 1);\n                while (n > 0) {\n                  currentBuffer.writeDoubleLE( /** @type {number} */data[i], currentPosition);\n                  currentPosition += F64_SIZE;\n                  n--;\n                  i++;\n                }\n                break;\n            }\n            i--;\n            break;\n          }\n        case \"boolean\":\n          {\n            let lastByte = thing === true ? 1 : 0;\n            const bytes = [];\n            let count = 1;\n            let n;\n            for (n = 1; n < 0xffffffff && i + n < data.length; n++) {\n              const item = data[i + n];\n              if (typeof item !== \"boolean\") break;\n              const pos = count & 0x7;\n              if (pos === 0) {\n                bytes.push(lastByte);\n                lastByte = item === true ? 1 : 0;\n              } else if (item === true) {\n                lastByte |= 1 << pos;\n              }\n              count++;\n            }\n            i += count - 1;\n            if (count === 1) {\n              allocate(HEADER_SIZE);\n              writeU8(lastByte === 1 ? TRUE_HEADER : FALSE_HEADER);\n            } else if (count === 2) {\n              allocate(HEADER_SIZE * 2);\n              writeU8(lastByte & 1 ? TRUE_HEADER : FALSE_HEADER);\n              writeU8(lastByte & 2 ? TRUE_HEADER : FALSE_HEADER);\n            } else if (count <= 6) {\n              allocate(HEADER_SIZE + I8_SIZE);\n              writeU8(BOOLEANS_HEADER);\n              writeU8(1 << count | lastByte);\n            } else if (count <= 133) {\n              allocate(HEADER_SIZE + I8_SIZE + I8_SIZE * bytes.length + I8_SIZE);\n              writeU8(BOOLEANS_HEADER);\n              writeU8(0x80 | count - 7);\n              for (const byte of bytes) writeU8(byte);\n              writeU8(lastByte);\n            } else {\n              allocate(HEADER_SIZE + I8_SIZE + I32_SIZE + I8_SIZE * bytes.length + I8_SIZE);\n              writeU8(BOOLEANS_HEADER);\n              writeU8(0xff);\n              writeU32(count);\n              for (const byte of bytes) writeU8(byte);\n              writeU8(lastByte);\n            }\n            break;\n          }\n        case \"object\":\n          {\n            if (thing === null) {\n              let n;\n              for (n = 1; n < 0x100000104 && i + n < data.length; n++) {\n                const item = data[i + n];\n                if (item !== null) break;\n              }\n              i += n - 1;\n              if (n === 1) {\n                if (i + 1 < data.length) {\n                  const next = data[i + 1];\n                  if (next === true) {\n                    allocate(HEADER_SIZE);\n                    writeU8(NULL_AND_TRUE_HEADER);\n                    i++;\n                  } else if (next === false) {\n                    allocate(HEADER_SIZE);\n                    writeU8(NULL_AND_FALSE_HEADER);\n                    i++;\n                  } else if (typeof next === \"number\") {\n                    const type = identifyNumber(next);\n                    if (type === 0) {\n                      allocate(HEADER_SIZE + I8_SIZE);\n                      writeU8(NULL_AND_I8_HEADER);\n                      currentBuffer.writeInt8(next, currentPosition);\n                      currentPosition += I8_SIZE;\n                      i++;\n                    } else if (type === 1) {\n                      allocate(HEADER_SIZE + I32_SIZE);\n                      writeU8(NULL_AND_I32_HEADER);\n                      currentBuffer.writeInt32LE(next, currentPosition);\n                      currentPosition += I32_SIZE;\n                      i++;\n                    } else {\n                      allocate(HEADER_SIZE);\n                      writeU8(NULL_HEADER);\n                    }\n                  } else {\n                    allocate(HEADER_SIZE);\n                    writeU8(NULL_HEADER);\n                  }\n                } else {\n                  allocate(HEADER_SIZE);\n                  writeU8(NULL_HEADER);\n                }\n              } else if (n === 2) {\n                allocate(HEADER_SIZE);\n                writeU8(NULL2_HEADER);\n              } else if (n === 3) {\n                allocate(HEADER_SIZE);\n                writeU8(NULL3_HEADER);\n              } else if (n < 260) {\n                allocate(HEADER_SIZE + I8_SIZE);\n                writeU8(NULLS8_HEADER);\n                writeU8(n - 4);\n              } else {\n                allocate(HEADER_SIZE + I32_SIZE);\n                writeU8(NULLS32_HEADER);\n                writeU32(n - 260);\n              }\n            } else if (Buffer.isBuffer(thing)) {\n              if (thing.length < 8192) {\n                allocate(HEADER_SIZE + I32_SIZE + thing.length);\n                writeU8(BUFFER_HEADER);\n                writeU32(thing.length);\n                thing.copy(currentBuffer, currentPosition);\n                currentPosition += thing.length;\n              } else {\n                allocate(HEADER_SIZE + I32_SIZE);\n                writeU8(BUFFER_HEADER);\n                writeU32(thing.length);\n                flush();\n                buffers.push(thing);\n              }\n            }\n            break;\n          }\n        case \"symbol\":\n          {\n            if (thing === MEASURE_START_OPERATION) {\n              measureStart();\n            } else if (thing === MEASURE_END_OPERATION) {\n              const size = measureEnd();\n              allocate(HEADER_SIZE + I32_SIZE);\n              writeU8(I32_HEADER);\n              currentBuffer.writeInt32LE(size, currentPosition);\n              currentPosition += I32_SIZE;\n            }\n            break;\n          }\n      }\n    }\n    flush();\n    allocationScope.leftOverBuffer = leftOverBuffer;\n\n    // avoid leaking memory\n    currentBuffer = null;\n    leftOverBuffer = null;\n    allocationScope = undefined;\n    const _buffers = buffers;\n    buffers = undefined;\n    return _buffers;\n  }\n\n  /**\n   * @param {SerializedType} data data\n   * @param {Object} context context object\n   * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n   */\n  deserialize(data, context) {\n    return this._deserialize(data, context);\n  }\n  _createLazyDeserialized(content, context) {\n    return SerializerMiddleware.createLazy(memoize(() => this._deserialize(content, context)), this, undefined, content);\n  }\n  _deserializeLazy(fn, context) {\n    return SerializerMiddleware.deserializeLazy(fn, data => this._deserialize(data, context));\n  }\n\n  /**\n   * @param {SerializedType} data data\n   * @param {Object} context context object\n   * @returns {DeserializedType} deserialized data\n   */\n  _deserialize(data, context) {\n    let currentDataItem = 0;\n    let currentBuffer = data[0];\n    let currentIsBuffer = Buffer.isBuffer(currentBuffer);\n    let currentPosition = 0;\n    const retainedBuffer = context.retainedBuffer || (x => x);\n    const checkOverflow = () => {\n      if (currentPosition >= currentBuffer.length) {\n        currentPosition = 0;\n        currentDataItem++;\n        currentBuffer = currentDataItem < data.length ? data[currentDataItem] : null;\n        currentIsBuffer = Buffer.isBuffer(currentBuffer);\n      }\n    };\n    const isInCurrentBuffer = n => {\n      return currentIsBuffer && n + currentPosition <= currentBuffer.length;\n    };\n    const ensureBuffer = () => {\n      if (!currentIsBuffer) {\n        throw new Error(currentBuffer === null ? \"Unexpected end of stream\" : \"Unexpected lazy element in stream\");\n      }\n    };\n    /**\n     * Reads n bytes\n     * @param {number} n amount of bytes to read\n     * @returns {Buffer} buffer with bytes\n     */\n    const read = n => {\n      ensureBuffer();\n      const rem = currentBuffer.length - currentPosition;\n      if (rem < n) {\n        const buffers = [read(rem)];\n        n -= rem;\n        ensureBuffer();\n        while (currentBuffer.length < n) {\n          const b = /** @type {Buffer} */currentBuffer;\n          buffers.push(b);\n          n -= b.length;\n          currentDataItem++;\n          currentBuffer = currentDataItem < data.length ? data[currentDataItem] : null;\n          currentIsBuffer = Buffer.isBuffer(currentBuffer);\n          ensureBuffer();\n        }\n        buffers.push(read(n));\n        return Buffer.concat(buffers);\n      }\n      const b = /** @type {Buffer} */currentBuffer;\n      const res = Buffer.from(b.buffer, b.byteOffset + currentPosition, n);\n      currentPosition += n;\n      checkOverflow();\n      return res;\n    };\n    /**\n     * Reads up to n bytes\n     * @param {number} n amount of bytes to read\n     * @returns {Buffer} buffer with bytes\n     */\n    const readUpTo = n => {\n      ensureBuffer();\n      const rem = currentBuffer.length - currentPosition;\n      if (rem < n) {\n        n = rem;\n      }\n      const b = /** @type {Buffer} */currentBuffer;\n      const res = Buffer.from(b.buffer, b.byteOffset + currentPosition, n);\n      currentPosition += n;\n      checkOverflow();\n      return res;\n    };\n    /**\n     * @returns {number} U8\n     */\n    const readU8 = () => {\n      ensureBuffer();\n      /**\n       * There is no need to check remaining buffer size here\n       * since {@link checkOverflow} guarantees at least one byte remaining\n       */\n      const byte = /** @type {Buffer} */currentBuffer.readUInt8(currentPosition);\n      currentPosition += I8_SIZE;\n      checkOverflow();\n      return byte;\n    };\n    /**\n     * @returns {number} U32\n     */\n    const readU32 = () => {\n      return read(I32_SIZE).readUInt32LE(0);\n    };\n    const readBits = (data, n) => {\n      let mask = 1;\n      while (n !== 0) {\n        result.push((data & mask) !== 0);\n        mask = mask << 1;\n        n--;\n      }\n    };\n    const dispatchTable = Array.from({\n      length: 256\n    }).map((_, header) => {\n      switch (header) {\n        case LAZY_HEADER:\n          return () => {\n            const count = readU32();\n            const lengths = Array.from({\n              length: count\n            }).map(() => readU32());\n            const content = [];\n            for (let l of lengths) {\n              if (l === 0) {\n                if (typeof currentBuffer !== \"function\") {\n                  throw new Error(\"Unexpected non-lazy element in stream\");\n                }\n                content.push(currentBuffer);\n                currentDataItem++;\n                currentBuffer = currentDataItem < data.length ? data[currentDataItem] : null;\n                currentIsBuffer = Buffer.isBuffer(currentBuffer);\n              } else {\n                do {\n                  const buf = readUpTo(l);\n                  l -= buf.length;\n                  content.push(retainedBuffer(buf));\n                } while (l > 0);\n              }\n            }\n            result.push(this._createLazyDeserialized(content, context));\n          };\n        case BUFFER_HEADER:\n          return () => {\n            const len = readU32();\n            result.push(retainedBuffer(read(len)));\n          };\n        case TRUE_HEADER:\n          return () => result.push(true);\n        case FALSE_HEADER:\n          return () => result.push(false);\n        case NULL3_HEADER:\n          return () => result.push(null, null, null);\n        case NULL2_HEADER:\n          return () => result.push(null, null);\n        case NULL_HEADER:\n          return () => result.push(null);\n        case NULL_AND_TRUE_HEADER:\n          return () => result.push(null, true);\n        case NULL_AND_FALSE_HEADER:\n          return () => result.push(null, false);\n        case NULL_AND_I8_HEADER:\n          return () => {\n            if (currentIsBuffer) {\n              result.push(null, /** @type {Buffer} */currentBuffer.readInt8(currentPosition));\n              currentPosition += I8_SIZE;\n              checkOverflow();\n            } else {\n              result.push(null, read(I8_SIZE).readInt8(0));\n            }\n          };\n        case NULL_AND_I32_HEADER:\n          return () => {\n            result.push(null);\n            if (isInCurrentBuffer(I32_SIZE)) {\n              result.push( /** @type {Buffer} */currentBuffer.readInt32LE(currentPosition));\n              currentPosition += I32_SIZE;\n              checkOverflow();\n            } else {\n              result.push(read(I32_SIZE).readInt32LE(0));\n            }\n          };\n        case NULLS8_HEADER:\n          return () => {\n            const len = readU8() + 4;\n            for (let i = 0; i < len; i++) {\n              result.push(null);\n            }\n          };\n        case NULLS32_HEADER:\n          return () => {\n            const len = readU32() + 260;\n            for (let i = 0; i < len; i++) {\n              result.push(null);\n            }\n          };\n        case BOOLEANS_HEADER:\n          return () => {\n            const innerHeader = readU8();\n            if ((innerHeader & 0xf0) === 0) {\n              readBits(innerHeader, 3);\n            } else if ((innerHeader & 0xe0) === 0) {\n              readBits(innerHeader, 4);\n            } else if ((innerHeader & 0xc0) === 0) {\n              readBits(innerHeader, 5);\n            } else if ((innerHeader & 0x80) === 0) {\n              readBits(innerHeader, 6);\n            } else if (innerHeader !== 0xff) {\n              let count = (innerHeader & 0x7f) + 7;\n              while (count > 8) {\n                readBits(readU8(), 8);\n                count -= 8;\n              }\n              readBits(readU8(), count);\n            } else {\n              let count = readU32();\n              while (count > 8) {\n                readBits(readU8(), 8);\n                count -= 8;\n              }\n              readBits(readU8(), count);\n            }\n          };\n        case STRING_HEADER:\n          return () => {\n            const len = readU32();\n            if (isInCurrentBuffer(len) && currentPosition + len < 0x7fffffff) {\n              result.push(currentBuffer.toString(undefined, currentPosition, currentPosition + len));\n              currentPosition += len;\n              checkOverflow();\n            } else {\n              result.push(read(len).toString());\n            }\n          };\n        case SHORT_STRING_HEADER:\n          return () => result.push(\"\");\n        case SHORT_STRING_HEADER | 1:\n          return () => {\n            if (currentIsBuffer && currentPosition < 0x7ffffffe) {\n              result.push(currentBuffer.toString(\"latin1\", currentPosition, currentPosition + 1));\n              currentPosition++;\n              checkOverflow();\n            } else {\n              result.push(read(1).toString(\"latin1\"));\n            }\n          };\n        case I8_HEADER:\n          return () => {\n            if (currentIsBuffer) {\n              result.push( /** @type {Buffer} */currentBuffer.readInt8(currentPosition));\n              currentPosition++;\n              checkOverflow();\n            } else {\n              result.push(read(1).readInt8(0));\n            }\n          };\n        case BIGINT_I8_HEADER:\n          {\n            const len = 1;\n            return () => {\n              const need = I8_SIZE * len;\n              if (isInCurrentBuffer(need)) {\n                for (let i = 0; i < len; i++) {\n                  const value = /** @type {Buffer} */\n                  currentBuffer.readInt8(currentPosition);\n                  result.push(BigInt(value));\n                  currentPosition += I8_SIZE;\n                }\n                checkOverflow();\n              } else {\n                const buf = read(need);\n                for (let i = 0; i < len; i++) {\n                  const value = buf.readInt8(i * I8_SIZE);\n                  result.push(BigInt(value));\n                }\n              }\n            };\n          }\n        case BIGINT_I32_HEADER:\n          {\n            const len = 1;\n            return () => {\n              const need = I32_SIZE * len;\n              if (isInCurrentBuffer(need)) {\n                for (let i = 0; i < len; i++) {\n                  const value = /** @type {Buffer} */currentBuffer.readInt32LE(currentPosition);\n                  result.push(BigInt(value));\n                  currentPosition += I32_SIZE;\n                }\n                checkOverflow();\n              } else {\n                const buf = read(need);\n                for (let i = 0; i < len; i++) {\n                  const value = buf.readInt32LE(i * I32_SIZE);\n                  result.push(BigInt(value));\n                }\n              }\n            };\n          }\n        case BIGINT_HEADER:\n          {\n            return () => {\n              const len = readU32();\n              if (isInCurrentBuffer(len) && currentPosition + len < 0x7fffffff) {\n                const value = currentBuffer.toString(undefined, currentPosition, currentPosition + len);\n                result.push(BigInt(value));\n                currentPosition += len;\n                checkOverflow();\n              } else {\n                const value = read(len).toString();\n                result.push(BigInt(value));\n              }\n            };\n          }\n        default:\n          if (header <= 10) {\n            return () => result.push(header);\n          } else if ((header & SHORT_STRING_HEADER) === SHORT_STRING_HEADER) {\n            const len = header & SHORT_STRING_LENGTH_MASK;\n            return () => {\n              if (isInCurrentBuffer(len) && currentPosition + len < 0x7fffffff) {\n                result.push(currentBuffer.toString(\"latin1\", currentPosition, currentPosition + len));\n                currentPosition += len;\n                checkOverflow();\n              } else {\n                result.push(read(len).toString(\"latin1\"));\n              }\n            };\n          } else if ((header & NUMBERS_HEADER_MASK) === F64_HEADER) {\n            const len = (header & NUMBERS_COUNT_MASK) + 1;\n            return () => {\n              const need = F64_SIZE * len;\n              if (isInCurrentBuffer(need)) {\n                for (let i = 0; i < len; i++) {\n                  result.push( /** @type {Buffer} */currentBuffer.readDoubleLE(currentPosition));\n                  currentPosition += F64_SIZE;\n                }\n                checkOverflow();\n              } else {\n                const buf = read(need);\n                for (let i = 0; i < len; i++) {\n                  result.push(buf.readDoubleLE(i * F64_SIZE));\n                }\n              }\n            };\n          } else if ((header & NUMBERS_HEADER_MASK) === I32_HEADER) {\n            const len = (header & NUMBERS_COUNT_MASK) + 1;\n            return () => {\n              const need = I32_SIZE * len;\n              if (isInCurrentBuffer(need)) {\n                for (let i = 0; i < len; i++) {\n                  result.push( /** @type {Buffer} */currentBuffer.readInt32LE(currentPosition));\n                  currentPosition += I32_SIZE;\n                }\n                checkOverflow();\n              } else {\n                const buf = read(need);\n                for (let i = 0; i < len; i++) {\n                  result.push(buf.readInt32LE(i * I32_SIZE));\n                }\n              }\n            };\n          } else if ((header & NUMBERS_HEADER_MASK) === I8_HEADER) {\n            const len = (header & NUMBERS_COUNT_MASK) + 1;\n            return () => {\n              const need = I8_SIZE * len;\n              if (isInCurrentBuffer(need)) {\n                for (let i = 0; i < len; i++) {\n                  result.push( /** @type {Buffer} */currentBuffer.readInt8(currentPosition));\n                  currentPosition += I8_SIZE;\n                }\n                checkOverflow();\n              } else {\n                const buf = read(need);\n                for (let i = 0; i < len; i++) {\n                  result.push(buf.readInt8(i * I8_SIZE));\n                }\n              }\n            };\n          } else {\n            return () => {\n              throw new Error(`Unexpected header byte 0x${header.toString(16)}`);\n            };\n          }\n      }\n    });\n\n    /** @type {DeserializedType} */\n    let result = [];\n    while (currentBuffer !== null) {\n      if (typeof currentBuffer === \"function\") {\n        result.push(this._deserializeLazy(currentBuffer, context));\n        currentDataItem++;\n        currentBuffer = currentDataItem < data.length ? data[currentDataItem] : null;\n        currentIsBuffer = Buffer.isBuffer(currentBuffer);\n      } else {\n        const header = readU8();\n        dispatchTable[header]();\n      }\n    }\n\n    // avoid leaking memory in context\n    let _result = result;\n    result = undefined;\n    return _result;\n  }\n}\nmodule.exports = BinaryMiddleware;\nmodule.exports.MEASURE_START_OPERATION = MEASURE_START_OPERATION;\nmodule.exports.MEASURE_END_OPERATION = MEASURE_END_OPERATION;","map":{"version":3,"names":["memoize","require","SerializerMiddleware","LAZY_HEADER","TRUE_HEADER","FALSE_HEADER","BOOLEANS_HEADER","NULL_HEADER","NULL2_HEADER","NULL3_HEADER","NULLS8_HEADER","NULLS32_HEADER","NULL_AND_I8_HEADER","NULL_AND_I32_HEADER","NULL_AND_TRUE_HEADER","NULL_AND_FALSE_HEADER","BIGINT_HEADER","BIGINT_I8_HEADER","BIGINT_I32_HEADER","STRING_HEADER","BUFFER_HEADER","I8_HEADER","I32_HEADER","F64_HEADER","SHORT_STRING_HEADER","NUMBERS_HEADER_MASK","NUMBERS_COUNT_MASK","SHORT_STRING_LENGTH_MASK","HEADER_SIZE","I8_SIZE","I32_SIZE","F64_SIZE","MEASURE_START_OPERATION","Symbol","MEASURE_END_OPERATION","identifyNumber","n","identifyBigInt","BigInt","BinaryMiddleware","serialize","data","context","_serialize","_serializeLazy","fn","serializeLazy","allocationScope","allocationSize","increaseCounter","leftOverBuffer","buffers","currentBuffer","currentPosition","Buffer","allocUnsafe","allocate","bytesNeeded","length","flush","Math","max","push","from","buffer","byteOffset","byteLength","writeU8","byte","writeUInt8","writeU32","ui32","writeUInt32LE","measureStack","measureStart","measureEnd","oldPos","pop","buffersIndex","size","i","thing","isLazy","Error","serializedData","getLazySerializedValue","undefined","result","setLazySerializedValue","lengths","item","last","remaining","l","len","write","charCodeAt","type","Number","writeInt8","writeInt32LE","value","toString","writeDoubleLE","lastByte","bytes","count","pos","next","isBuffer","copy","_buffers","deserialize","_deserialize","_createLazyDeserialized","content","createLazy","_deserializeLazy","deserializeLazy","currentDataItem","currentIsBuffer","retainedBuffer","x","checkOverflow","isInCurrentBuffer","ensureBuffer","read","rem","b","concat","res","readUpTo","readU8","readUInt8","readU32","readUInt32LE","readBits","mask","dispatchTable","Array","map","_","header","buf","readInt8","readInt32LE","innerHeader","need","readDoubleLE","_result","module","exports"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/serialization/BinaryMiddleware.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst memoize = require(\"../util/memoize\");\nconst SerializerMiddleware = require(\"./SerializerMiddleware\");\n\n/** @typedef {import(\"./types\").BufferSerializableType} BufferSerializableType */\n/** @typedef {import(\"./types\").PrimitiveSerializableType} PrimitiveSerializableType */\n\n/*\nFormat:\n\nFile -> Section*\n\nSection -> NullsSection |\n\t\t\t\t\t BooleansSection |\n\t\t\t\t\t F64NumbersSection |\n\t\t\t\t\t I32NumbersSection |\n\t\t\t\t\t I8NumbersSection |\n\t\t\t\t\t ShortStringSection |\n\t\t\t\t\t BigIntSection |\n\t\t\t\t\t I32BigIntSection |\n\t\t\t\t\t I8BigIntSection\n\t\t\t\t\t StringSection |\n\t\t\t\t\t BufferSection |\n\t\t\t\t\t NopSection\n\n\n\nNullsSection ->\n\tNullHeaderByte | Null2HeaderByte | Null3HeaderByte |\n\tNulls8HeaderByte 0xnn (n:count - 4) |\n\tNulls32HeaderByte n:ui32 (n:count - 260) |\nBooleansSection -> TrueHeaderByte | FalseHeaderByte | BooleansSectionHeaderByte BooleansCountAndBitsByte\nF64NumbersSection -> F64NumbersSectionHeaderByte f64*\nI32NumbersSection -> I32NumbersSectionHeaderByte i32*\nI8NumbersSection -> I8NumbersSectionHeaderByte i8*\nShortStringSection -> ShortStringSectionHeaderByte ascii-byte*\nStringSection -> StringSectionHeaderByte i32:length utf8-byte*\nBufferSection -> BufferSectionHeaderByte i32:length byte*\nNopSection --> NopSectionHeaderByte\nBigIntSection -> BigIntSectionHeaderByte i32:length ascii-byte*\nI32BigIntSection -> I32BigIntSectionHeaderByte i32\nI8BigIntSection -> I8BigIntSectionHeaderByte i8\n\nShortStringSectionHeaderByte -> 0b1nnn_nnnn (n:length)\n\nF64NumbersSectionHeaderByte -> 0b001n_nnnn (n:count - 1)\nI32NumbersSectionHeaderByte -> 0b010n_nnnn (n:count - 1)\nI8NumbersSectionHeaderByte -> 0b011n_nnnn (n:count - 1)\n\nNullsSectionHeaderByte -> 0b0001_nnnn (n:count - 1)\nBooleansCountAndBitsByte ->\n\t0b0000_1xxx (count = 3) |\n\t0b0001_xxxx (count = 4) |\n\t0b001x_xxxx (count = 5) |\n\t0b01xx_xxxx (count = 6) |\n\t0b1nnn_nnnn (n:count - 7, 7 <= count <= 133)\n\t0xff n:ui32 (n:count, 134 <= count < 2^32)\n\nStringSectionHeaderByte -> 0b0000_1110\nBufferSectionHeaderByte -> 0b0000_1111\nNopSectionHeaderByte -> 0b0000_1011\nBigIntSectionHeaderByte -> 0b0001_1010\nI32BigIntSectionHeaderByte -> 0b0001_1100\nI8BigIntSectionHeaderByte -> 0b0001_1011\nFalseHeaderByte -> 0b0000_1100\nTrueHeaderByte -> 0b0000_1101\n\nRawNumber -> n (n <= 10)\n\n*/\n\nconst LAZY_HEADER = 0x0b;\nconst TRUE_HEADER = 0x0c;\nconst FALSE_HEADER = 0x0d;\nconst BOOLEANS_HEADER = 0x0e;\nconst NULL_HEADER = 0x10;\nconst NULL2_HEADER = 0x11;\nconst NULL3_HEADER = 0x12;\nconst NULLS8_HEADER = 0x13;\nconst NULLS32_HEADER = 0x14;\nconst NULL_AND_I8_HEADER = 0x15;\nconst NULL_AND_I32_HEADER = 0x16;\nconst NULL_AND_TRUE_HEADER = 0x17;\nconst NULL_AND_FALSE_HEADER = 0x18;\nconst BIGINT_HEADER = 0x1a;\nconst BIGINT_I8_HEADER = 0x1b;\nconst BIGINT_I32_HEADER = 0x1c;\nconst STRING_HEADER = 0x1e;\nconst BUFFER_HEADER = 0x1f;\nconst I8_HEADER = 0x60;\nconst I32_HEADER = 0x40;\nconst F64_HEADER = 0x20;\nconst SHORT_STRING_HEADER = 0x80;\n\n/** Uplift high-order bits */\nconst NUMBERS_HEADER_MASK = 0xe0; // 0b1010_0000\nconst NUMBERS_COUNT_MASK = 0x1f; // 0b0001_1111\nconst SHORT_STRING_LENGTH_MASK = 0x7f; // 0b0111_1111\n\nconst HEADER_SIZE = 1;\nconst I8_SIZE = 1;\nconst I32_SIZE = 4;\nconst F64_SIZE = 8;\n\nconst MEASURE_START_OPERATION = Symbol(\"MEASURE_START_OPERATION\");\nconst MEASURE_END_OPERATION = Symbol(\"MEASURE_END_OPERATION\");\n\n/** @typedef {typeof MEASURE_START_OPERATION} MEASURE_START_OPERATION_TYPE */\n/** @typedef {typeof MEASURE_END_OPERATION} MEASURE_END_OPERATION_TYPE */\n\n/**\n * @param {number} n number\n * @returns {0 | 1 | 2} type of number for serialization\n */\nconst identifyNumber = n => {\n\tif (n === (n | 0)) {\n\t\tif (n <= 127 && n >= -128) return 0;\n\t\tif (n <= 2147483647 && n >= -2147483648) return 1;\n\t}\n\treturn 2;\n};\n\n/**\n * @param {bigint} n bigint\n * @returns {0 | 1 | 2} type of bigint for serialization\n */\nconst identifyBigInt = n => {\n\tif (n <= BigInt(127) && n >= BigInt(-128)) return 0;\n\tif (n <= BigInt(2147483647) && n >= BigInt(-2147483648)) return 1;\n\treturn 2;\n};\n\n/**\n * @typedef {PrimitiveSerializableType[]} DeserializedType\n * @typedef {BufferSerializableType[]} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\nclass BinaryMiddleware extends SerializerMiddleware {\n\t/**\n\t * @param {DeserializedType} data data\n\t * @param {Object} context context object\n\t * @returns {SerializedType|Promise<SerializedType>} serialized data\n\t */\n\tserialize(data, context) {\n\t\treturn this._serialize(data, context);\n\t}\n\n\t_serializeLazy(fn, context) {\n\t\treturn SerializerMiddleware.serializeLazy(fn, data =>\n\t\t\tthis._serialize(data, context)\n\t\t);\n\t}\n\n\t/**\n\t * @param {DeserializedType} data data\n\t * @param {Object} context context object\n\t * @param {{ leftOverBuffer: Buffer | null, allocationSize: number, increaseCounter: number }} allocationScope allocation scope\n\t * @returns {SerializedType} serialized data\n\t */\n\t_serialize(\n\t\tdata,\n\t\tcontext,\n\t\tallocationScope = {\n\t\t\tallocationSize: 1024,\n\t\t\tincreaseCounter: 0,\n\t\t\tleftOverBuffer: null\n\t\t}\n\t) {\n\t\t/** @type {Buffer} */\n\t\tlet leftOverBuffer = null;\n\t\t/** @type {BufferSerializableType[]} */\n\t\tlet buffers = [];\n\t\t/** @type {Buffer} */\n\t\tlet currentBuffer = allocationScope ? allocationScope.leftOverBuffer : null;\n\t\tallocationScope.leftOverBuffer = null;\n\t\tlet currentPosition = 0;\n\t\tif (currentBuffer === null) {\n\t\t\tcurrentBuffer = Buffer.allocUnsafe(allocationScope.allocationSize);\n\t\t}\n\t\tconst allocate = bytesNeeded => {\n\t\t\tif (currentBuffer !== null) {\n\t\t\t\tif (currentBuffer.length - currentPosition >= bytesNeeded) return;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (leftOverBuffer && leftOverBuffer.length >= bytesNeeded) {\n\t\t\t\tcurrentBuffer = leftOverBuffer;\n\t\t\t\tleftOverBuffer = null;\n\t\t\t} else {\n\t\t\t\tcurrentBuffer = Buffer.allocUnsafe(\n\t\t\t\t\tMath.max(bytesNeeded, allocationScope.allocationSize)\n\t\t\t\t);\n\t\t\t\tif (\n\t\t\t\t\t!(allocationScope.increaseCounter =\n\t\t\t\t\t\t(allocationScope.increaseCounter + 1) % 4) &&\n\t\t\t\t\tallocationScope.allocationSize < 16777216\n\t\t\t\t) {\n\t\t\t\t\tallocationScope.allocationSize = allocationScope.allocationSize << 1;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tconst flush = () => {\n\t\t\tif (currentBuffer !== null) {\n\t\t\t\tif (currentPosition > 0) {\n\t\t\t\t\tbuffers.push(\n\t\t\t\t\t\tBuffer.from(\n\t\t\t\t\t\t\tcurrentBuffer.buffer,\n\t\t\t\t\t\t\tcurrentBuffer.byteOffset,\n\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\t!leftOverBuffer ||\n\t\t\t\t\tleftOverBuffer.length < currentBuffer.length - currentPosition\n\t\t\t\t) {\n\t\t\t\t\tleftOverBuffer = Buffer.from(\n\t\t\t\t\t\tcurrentBuffer.buffer,\n\t\t\t\t\t\tcurrentBuffer.byteOffset + currentPosition,\n\t\t\t\t\t\tcurrentBuffer.byteLength - currentPosition\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tcurrentBuffer = null;\n\t\t\t\tcurrentPosition = 0;\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {number} byte byte\n\t\t */\n\t\tconst writeU8 = byte => {\n\t\t\tcurrentBuffer.writeUInt8(byte, currentPosition++);\n\t\t};\n\t\t/**\n\t\t * @param {number} ui32 ui32\n\t\t */\n\t\tconst writeU32 = ui32 => {\n\t\t\tcurrentBuffer.writeUInt32LE(ui32, currentPosition);\n\t\t\tcurrentPosition += 4;\n\t\t};\n\t\t/** @type {number[]} */\n\t\tconst measureStack = [];\n\t\tconst measureStart = () => {\n\t\t\tmeasureStack.push(buffers.length, currentPosition);\n\t\t};\n\t\t/**\n\t\t * @returns {number} size\n\t\t */\n\t\tconst measureEnd = () => {\n\t\t\tconst oldPos = measureStack.pop();\n\t\t\tconst buffersIndex = measureStack.pop();\n\t\t\tlet size = currentPosition - oldPos;\n\t\t\tfor (let i = buffersIndex; i < buffers.length; i++) {\n\t\t\t\tsize += buffers[i].length;\n\t\t\t}\n\t\t\treturn size;\n\t\t};\n\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\tconst thing = data[i];\n\t\t\tswitch (typeof thing) {\n\t\t\t\tcase \"function\": {\n\t\t\t\t\tif (!SerializerMiddleware.isLazy(thing))\n\t\t\t\t\t\tthrow new Error(\"Unexpected function \" + thing);\n\t\t\t\t\t/** @type {SerializedType | (() => SerializedType)} */\n\t\t\t\t\tlet serializedData =\n\t\t\t\t\t\tSerializerMiddleware.getLazySerializedValue(thing);\n\t\t\t\t\tif (serializedData === undefined) {\n\t\t\t\t\t\tif (SerializerMiddleware.isLazy(thing, this)) {\n\t\t\t\t\t\t\tflush();\n\t\t\t\t\t\t\tallocationScope.leftOverBuffer = leftOverBuffer;\n\t\t\t\t\t\t\tconst result =\n\t\t\t\t\t\t\t\t/** @type {(Exclude<PrimitiveSerializableType, Promise<PrimitiveSerializableType>>)[]} */ (\n\t\t\t\t\t\t\t\t\tthing()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst data = this._serialize(result, context, allocationScope);\n\t\t\t\t\t\t\tleftOverBuffer = allocationScope.leftOverBuffer;\n\t\t\t\t\t\t\tallocationScope.leftOverBuffer = null;\n\t\t\t\t\t\t\tSerializerMiddleware.setLazySerializedValue(thing, data);\n\t\t\t\t\t\t\tserializedData = data;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tserializedData = this._serializeLazy(thing, context);\n\t\t\t\t\t\t\tflush();\n\t\t\t\t\t\t\tbuffers.push(serializedData);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (typeof serializedData === \"function\") {\n\t\t\t\t\t\t\tflush();\n\t\t\t\t\t\t\tbuffers.push(serializedData);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/** @type {number[]} */\n\t\t\t\t\tconst lengths = [];\n\t\t\t\t\tfor (const item of serializedData) {\n\t\t\t\t\t\tlet last;\n\t\t\t\t\t\tif (typeof item === \"function\") {\n\t\t\t\t\t\t\tlengths.push(0);\n\t\t\t\t\t\t} else if (item.length === 0) {\n\t\t\t\t\t\t\t// ignore\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tlengths.length > 0 &&\n\t\t\t\t\t\t\t(last = lengths[lengths.length - 1]) !== 0\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst remaining = 0xffffffff - last;\n\t\t\t\t\t\t\tif (remaining >= item.length) {\n\t\t\t\t\t\t\t\tlengths[lengths.length - 1] += item.length;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlengths.push(item.length - remaining);\n\t\t\t\t\t\t\t\tlengths[lengths.length - 2] = 0xffffffff;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlengths.push(item.length);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tallocate(5 + lengths.length * 4);\n\t\t\t\t\twriteU8(LAZY_HEADER);\n\t\t\t\t\twriteU32(lengths.length);\n\t\t\t\t\tfor (const l of lengths) {\n\t\t\t\t\t\twriteU32(l);\n\t\t\t\t\t}\n\t\t\t\t\tflush();\n\t\t\t\t\tfor (const item of serializedData) {\n\t\t\t\t\t\tbuffers.push(item);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"string\": {\n\t\t\t\t\tconst len = Buffer.byteLength(thing);\n\t\t\t\t\tif (len >= 128 || len !== thing.length) {\n\t\t\t\t\t\tallocate(len + HEADER_SIZE + I32_SIZE);\n\t\t\t\t\t\twriteU8(STRING_HEADER);\n\t\t\t\t\t\twriteU32(len);\n\t\t\t\t\t\tcurrentBuffer.write(thing, currentPosition);\n\t\t\t\t\t\tcurrentPosition += len;\n\t\t\t\t\t} else if (len >= 70) {\n\t\t\t\t\t\tallocate(len + HEADER_SIZE);\n\t\t\t\t\t\twriteU8(SHORT_STRING_HEADER | len);\n\n\t\t\t\t\t\tcurrentBuffer.write(thing, currentPosition, \"latin1\");\n\t\t\t\t\t\tcurrentPosition += len;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tallocate(len + HEADER_SIZE);\n\t\t\t\t\t\twriteU8(SHORT_STRING_HEADER | len);\n\n\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\tcurrentBuffer[currentPosition++] = thing.charCodeAt(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"bigint\": {\n\t\t\t\t\tconst type = identifyBigInt(thing);\n\t\t\t\t\tif (type === 0 && thing >= 0 && thing <= BigInt(10)) {\n\t\t\t\t\t\t// shortcut for very small bigints\n\t\t\t\t\t\tallocate(HEADER_SIZE + I8_SIZE);\n\t\t\t\t\t\twriteU8(BIGINT_I8_HEADER);\n\t\t\t\t\t\twriteU8(Number(thing));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\tlet n = 1;\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I8_SIZE * n);\n\t\t\t\t\t\t\twriteU8(BIGINT_I8_HEADER | (n - 1));\n\t\t\t\t\t\t\twhile (n > 0) {\n\t\t\t\t\t\t\t\tcurrentBuffer.writeInt8(\n\t\t\t\t\t\t\t\t\tNumber(/** @type {bigint} */ (data[i])),\n\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcurrentPosition += I8_SIZE;\n\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 1: {\n\t\t\t\t\t\t\tlet n = 1;\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I32_SIZE * n);\n\t\t\t\t\t\t\twriteU8(BIGINT_I32_HEADER | (n - 1));\n\t\t\t\t\t\t\twhile (n > 0) {\n\t\t\t\t\t\t\t\tcurrentBuffer.writeInt32LE(\n\t\t\t\t\t\t\t\t\tNumber(/** @type {bigint} */ (data[i])),\n\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcurrentPosition += I32_SIZE;\n\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\tconst value = thing.toString();\n\t\t\t\t\t\t\tconst len = Buffer.byteLength(value);\n\t\t\t\t\t\t\tallocate(len + HEADER_SIZE + I32_SIZE);\n\t\t\t\t\t\t\twriteU8(BIGINT_HEADER);\n\t\t\t\t\t\t\twriteU32(len);\n\t\t\t\t\t\t\tcurrentBuffer.write(value, currentPosition);\n\t\t\t\t\t\t\tcurrentPosition += len;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"number\": {\n\t\t\t\t\tconst type = identifyNumber(thing);\n\t\t\t\t\tif (type === 0 && thing >= 0 && thing <= 10) {\n\t\t\t\t\t\t// shortcut for very small numbers\n\t\t\t\t\t\tallocate(I8_SIZE);\n\t\t\t\t\t\twriteU8(thing);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/**\n\t\t\t\t\t * amount of numbers to write\n\t\t\t\t\t * @type {number}\n\t\t\t\t\t */\n\t\t\t\t\tlet n = 1;\n\t\t\t\t\tfor (; n < 32 && i + n < data.length; n++) {\n\t\t\t\t\t\tconst item = data[i + n];\n\t\t\t\t\t\tif (typeof item !== \"number\") break;\n\t\t\t\t\t\tif (identifyNumber(item) !== type) break;\n\t\t\t\t\t}\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I8_SIZE * n);\n\t\t\t\t\t\t\twriteU8(I8_HEADER | (n - 1));\n\t\t\t\t\t\t\twhile (n > 0) {\n\t\t\t\t\t\t\t\tcurrentBuffer.writeInt8(\n\t\t\t\t\t\t\t\t\t/** @type {number} */ (data[i]),\n\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcurrentPosition += I8_SIZE;\n\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I32_SIZE * n);\n\t\t\t\t\t\t\twriteU8(I32_HEADER | (n - 1));\n\t\t\t\t\t\t\twhile (n > 0) {\n\t\t\t\t\t\t\t\tcurrentBuffer.writeInt32LE(\n\t\t\t\t\t\t\t\t\t/** @type {number} */ (data[i]),\n\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcurrentPosition += I32_SIZE;\n\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + F64_SIZE * n);\n\t\t\t\t\t\t\twriteU8(F64_HEADER | (n - 1));\n\t\t\t\t\t\t\twhile (n > 0) {\n\t\t\t\t\t\t\t\tcurrentBuffer.writeDoubleLE(\n\t\t\t\t\t\t\t\t\t/** @type {number} */ (data[i]),\n\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcurrentPosition += F64_SIZE;\n\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\ti--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"boolean\": {\n\t\t\t\t\tlet lastByte = thing === true ? 1 : 0;\n\t\t\t\t\tconst bytes = [];\n\t\t\t\t\tlet count = 1;\n\t\t\t\t\tlet n;\n\t\t\t\t\tfor (n = 1; n < 0xffffffff && i + n < data.length; n++) {\n\t\t\t\t\t\tconst item = data[i + n];\n\t\t\t\t\t\tif (typeof item !== \"boolean\") break;\n\t\t\t\t\t\tconst pos = count & 0x7;\n\t\t\t\t\t\tif (pos === 0) {\n\t\t\t\t\t\t\tbytes.push(lastByte);\n\t\t\t\t\t\t\tlastByte = item === true ? 1 : 0;\n\t\t\t\t\t\t} else if (item === true) {\n\t\t\t\t\t\t\tlastByte |= 1 << pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\ti += count - 1;\n\t\t\t\t\tif (count === 1) {\n\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\twriteU8(lastByte === 1 ? TRUE_HEADER : FALSE_HEADER);\n\t\t\t\t\t} else if (count === 2) {\n\t\t\t\t\t\tallocate(HEADER_SIZE * 2);\n\t\t\t\t\t\twriteU8(lastByte & 1 ? TRUE_HEADER : FALSE_HEADER);\n\t\t\t\t\t\twriteU8(lastByte & 2 ? TRUE_HEADER : FALSE_HEADER);\n\t\t\t\t\t} else if (count <= 6) {\n\t\t\t\t\t\tallocate(HEADER_SIZE + I8_SIZE);\n\t\t\t\t\t\twriteU8(BOOLEANS_HEADER);\n\t\t\t\t\t\twriteU8((1 << count) | lastByte);\n\t\t\t\t\t} else if (count <= 133) {\n\t\t\t\t\t\tallocate(HEADER_SIZE + I8_SIZE + I8_SIZE * bytes.length + I8_SIZE);\n\t\t\t\t\t\twriteU8(BOOLEANS_HEADER);\n\t\t\t\t\t\twriteU8(0x80 | (count - 7));\n\t\t\t\t\t\tfor (const byte of bytes) writeU8(byte);\n\t\t\t\t\t\twriteU8(lastByte);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tallocate(\n\t\t\t\t\t\t\tHEADER_SIZE +\n\t\t\t\t\t\t\t\tI8_SIZE +\n\t\t\t\t\t\t\t\tI32_SIZE +\n\t\t\t\t\t\t\t\tI8_SIZE * bytes.length +\n\t\t\t\t\t\t\t\tI8_SIZE\n\t\t\t\t\t\t);\n\t\t\t\t\t\twriteU8(BOOLEANS_HEADER);\n\t\t\t\t\t\twriteU8(0xff);\n\t\t\t\t\t\twriteU32(count);\n\t\t\t\t\t\tfor (const byte of bytes) writeU8(byte);\n\t\t\t\t\t\twriteU8(lastByte);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"object\": {\n\t\t\t\t\tif (thing === null) {\n\t\t\t\t\t\tlet n;\n\t\t\t\t\t\tfor (n = 1; n < 0x100000104 && i + n < data.length; n++) {\n\t\t\t\t\t\t\tconst item = data[i + n];\n\t\t\t\t\t\t\tif (item !== null) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti += n - 1;\n\t\t\t\t\t\tif (n === 1) {\n\t\t\t\t\t\t\tif (i + 1 < data.length) {\n\t\t\t\t\t\t\t\tconst next = data[i + 1];\n\t\t\t\t\t\t\t\tif (next === true) {\n\t\t\t\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\t\t\t\twriteU8(NULL_AND_TRUE_HEADER);\n\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t} else if (next === false) {\n\t\t\t\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\t\t\t\twriteU8(NULL_AND_FALSE_HEADER);\n\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t} else if (typeof next === \"number\") {\n\t\t\t\t\t\t\t\t\tconst type = identifyNumber(next);\n\t\t\t\t\t\t\t\t\tif (type === 0) {\n\t\t\t\t\t\t\t\t\t\tallocate(HEADER_SIZE + I8_SIZE);\n\t\t\t\t\t\t\t\t\t\twriteU8(NULL_AND_I8_HEADER);\n\t\t\t\t\t\t\t\t\t\tcurrentBuffer.writeInt8(next, currentPosition);\n\t\t\t\t\t\t\t\t\t\tcurrentPosition += I8_SIZE;\n\t\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t\t} else if (type === 1) {\n\t\t\t\t\t\t\t\t\t\tallocate(HEADER_SIZE + I32_SIZE);\n\t\t\t\t\t\t\t\t\t\twriteU8(NULL_AND_I32_HEADER);\n\t\t\t\t\t\t\t\t\t\tcurrentBuffer.writeInt32LE(next, currentPosition);\n\t\t\t\t\t\t\t\t\t\tcurrentPosition += I32_SIZE;\n\t\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\t\t\t\t\twriteU8(NULL_HEADER);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\t\t\t\twriteU8(NULL_HEADER);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\t\t\twriteU8(NULL_HEADER);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (n === 2) {\n\t\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\t\twriteU8(NULL2_HEADER);\n\t\t\t\t\t\t} else if (n === 3) {\n\t\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\t\twriteU8(NULL3_HEADER);\n\t\t\t\t\t\t} else if (n < 260) {\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I8_SIZE);\n\t\t\t\t\t\t\twriteU8(NULLS8_HEADER);\n\t\t\t\t\t\t\twriteU8(n - 4);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I32_SIZE);\n\t\t\t\t\t\t\twriteU8(NULLS32_HEADER);\n\t\t\t\t\t\t\twriteU32(n - 260);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (Buffer.isBuffer(thing)) {\n\t\t\t\t\t\tif (thing.length < 8192) {\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I32_SIZE + thing.length);\n\t\t\t\t\t\t\twriteU8(BUFFER_HEADER);\n\t\t\t\t\t\t\twriteU32(thing.length);\n\t\t\t\t\t\t\tthing.copy(currentBuffer, currentPosition);\n\t\t\t\t\t\t\tcurrentPosition += thing.length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I32_SIZE);\n\t\t\t\t\t\t\twriteU8(BUFFER_HEADER);\n\t\t\t\t\t\t\twriteU32(thing.length);\n\t\t\t\t\t\t\tflush();\n\t\t\t\t\t\t\tbuffers.push(thing);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"symbol\": {\n\t\t\t\t\tif (thing === MEASURE_START_OPERATION) {\n\t\t\t\t\t\tmeasureStart();\n\t\t\t\t\t} else if (thing === MEASURE_END_OPERATION) {\n\t\t\t\t\t\tconst size = measureEnd();\n\t\t\t\t\t\tallocate(HEADER_SIZE + I32_SIZE);\n\t\t\t\t\t\twriteU8(I32_HEADER);\n\t\t\t\t\t\tcurrentBuffer.writeInt32LE(size, currentPosition);\n\t\t\t\t\t\tcurrentPosition += I32_SIZE;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tflush();\n\n\t\tallocationScope.leftOverBuffer = leftOverBuffer;\n\n\t\t// avoid leaking memory\n\t\tcurrentBuffer = null;\n\t\tleftOverBuffer = null;\n\t\tallocationScope = undefined;\n\t\tconst _buffers = buffers;\n\t\tbuffers = undefined;\n\t\treturn _buffers;\n\t}\n\n\t/**\n\t * @param {SerializedType} data data\n\t * @param {Object} context context object\n\t * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n\t */\n\tdeserialize(data, context) {\n\t\treturn this._deserialize(data, context);\n\t}\n\n\t_createLazyDeserialized(content, context) {\n\t\treturn SerializerMiddleware.createLazy(\n\t\t\tmemoize(() => this._deserialize(content, context)),\n\t\t\tthis,\n\t\t\tundefined,\n\t\t\tcontent\n\t\t);\n\t}\n\n\t_deserializeLazy(fn, context) {\n\t\treturn SerializerMiddleware.deserializeLazy(fn, data =>\n\t\t\tthis._deserialize(data, context)\n\t\t);\n\t}\n\n\t/**\n\t * @param {SerializedType} data data\n\t * @param {Object} context context object\n\t * @returns {DeserializedType} deserialized data\n\t */\n\t_deserialize(data, context) {\n\t\tlet currentDataItem = 0;\n\t\tlet currentBuffer = data[0];\n\t\tlet currentIsBuffer = Buffer.isBuffer(currentBuffer);\n\t\tlet currentPosition = 0;\n\n\t\tconst retainedBuffer = context.retainedBuffer || (x => x);\n\n\t\tconst checkOverflow = () => {\n\t\t\tif (currentPosition >= currentBuffer.length) {\n\t\t\t\tcurrentPosition = 0;\n\t\t\t\tcurrentDataItem++;\n\t\t\t\tcurrentBuffer =\n\t\t\t\t\tcurrentDataItem < data.length ? data[currentDataItem] : null;\n\t\t\t\tcurrentIsBuffer = Buffer.isBuffer(currentBuffer);\n\t\t\t}\n\t\t};\n\t\tconst isInCurrentBuffer = n => {\n\t\t\treturn currentIsBuffer && n + currentPosition <= currentBuffer.length;\n\t\t};\n\t\tconst ensureBuffer = () => {\n\t\t\tif (!currentIsBuffer) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\tcurrentBuffer === null\n\t\t\t\t\t\t? \"Unexpected end of stream\"\n\t\t\t\t\t\t: \"Unexpected lazy element in stream\"\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * Reads n bytes\n\t\t * @param {number} n amount of bytes to read\n\t\t * @returns {Buffer} buffer with bytes\n\t\t */\n\t\tconst read = n => {\n\t\t\tensureBuffer();\n\t\t\tconst rem = currentBuffer.length - currentPosition;\n\t\t\tif (rem < n) {\n\t\t\t\tconst buffers = [read(rem)];\n\t\t\t\tn -= rem;\n\t\t\t\tensureBuffer();\n\t\t\t\twhile (currentBuffer.length < n) {\n\t\t\t\t\tconst b = /** @type {Buffer} */ (currentBuffer);\n\t\t\t\t\tbuffers.push(b);\n\t\t\t\t\tn -= b.length;\n\t\t\t\t\tcurrentDataItem++;\n\t\t\t\t\tcurrentBuffer =\n\t\t\t\t\t\tcurrentDataItem < data.length ? data[currentDataItem] : null;\n\t\t\t\t\tcurrentIsBuffer = Buffer.isBuffer(currentBuffer);\n\t\t\t\t\tensureBuffer();\n\t\t\t\t}\n\t\t\t\tbuffers.push(read(n));\n\t\t\t\treturn Buffer.concat(buffers);\n\t\t\t}\n\t\t\tconst b = /** @type {Buffer} */ (currentBuffer);\n\t\t\tconst res = Buffer.from(b.buffer, b.byteOffset + currentPosition, n);\n\t\t\tcurrentPosition += n;\n\t\t\tcheckOverflow();\n\t\t\treturn res;\n\t\t};\n\t\t/**\n\t\t * Reads up to n bytes\n\t\t * @param {number} n amount of bytes to read\n\t\t * @returns {Buffer} buffer with bytes\n\t\t */\n\t\tconst readUpTo = n => {\n\t\t\tensureBuffer();\n\t\t\tconst rem = currentBuffer.length - currentPosition;\n\t\t\tif (rem < n) {\n\t\t\t\tn = rem;\n\t\t\t}\n\t\t\tconst b = /** @type {Buffer} */ (currentBuffer);\n\t\t\tconst res = Buffer.from(b.buffer, b.byteOffset + currentPosition, n);\n\t\t\tcurrentPosition += n;\n\t\t\tcheckOverflow();\n\t\t\treturn res;\n\t\t};\n\t\t/**\n\t\t * @returns {number} U8\n\t\t */\n\t\tconst readU8 = () => {\n\t\t\tensureBuffer();\n\t\t\t/**\n\t\t\t * There is no need to check remaining buffer size here\n\t\t\t * since {@link checkOverflow} guarantees at least one byte remaining\n\t\t\t */\n\t\t\tconst byte = /** @type {Buffer} */ (currentBuffer).readUInt8(\n\t\t\t\tcurrentPosition\n\t\t\t);\n\t\t\tcurrentPosition += I8_SIZE;\n\t\t\tcheckOverflow();\n\t\t\treturn byte;\n\t\t};\n\t\t/**\n\t\t * @returns {number} U32\n\t\t */\n\t\tconst readU32 = () => {\n\t\t\treturn read(I32_SIZE).readUInt32LE(0);\n\t\t};\n\t\tconst readBits = (data, n) => {\n\t\t\tlet mask = 1;\n\t\t\twhile (n !== 0) {\n\t\t\t\tresult.push((data & mask) !== 0);\n\t\t\t\tmask = mask << 1;\n\t\t\t\tn--;\n\t\t\t}\n\t\t};\n\t\tconst dispatchTable = Array.from({ length: 256 }).map((_, header) => {\n\t\t\tswitch (header) {\n\t\t\t\tcase LAZY_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst count = readU32();\n\t\t\t\t\t\tconst lengths = Array.from({ length: count }).map(() => readU32());\n\t\t\t\t\t\tconst content = [];\n\t\t\t\t\t\tfor (let l of lengths) {\n\t\t\t\t\t\t\tif (l === 0) {\n\t\t\t\t\t\t\t\tif (typeof currentBuffer !== \"function\") {\n\t\t\t\t\t\t\t\t\tthrow new Error(\"Unexpected non-lazy element in stream\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontent.push(currentBuffer);\n\t\t\t\t\t\t\t\tcurrentDataItem++;\n\t\t\t\t\t\t\t\tcurrentBuffer =\n\t\t\t\t\t\t\t\t\tcurrentDataItem < data.length ? data[currentDataItem] : null;\n\t\t\t\t\t\t\t\tcurrentIsBuffer = Buffer.isBuffer(currentBuffer);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\tconst buf = readUpTo(l);\n\t\t\t\t\t\t\t\t\tl -= buf.length;\n\t\t\t\t\t\t\t\t\tcontent.push(retainedBuffer(buf));\n\t\t\t\t\t\t\t\t} while (l > 0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.push(this._createLazyDeserialized(content, context));\n\t\t\t\t\t};\n\t\t\t\tcase BUFFER_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst len = readU32();\n\t\t\t\t\t\tresult.push(retainedBuffer(read(len)));\n\t\t\t\t\t};\n\t\t\t\tcase TRUE_HEADER:\n\t\t\t\t\treturn () => result.push(true);\n\t\t\t\tcase FALSE_HEADER:\n\t\t\t\t\treturn () => result.push(false);\n\t\t\t\tcase NULL3_HEADER:\n\t\t\t\t\treturn () => result.push(null, null, null);\n\t\t\t\tcase NULL2_HEADER:\n\t\t\t\t\treturn () => result.push(null, null);\n\t\t\t\tcase NULL_HEADER:\n\t\t\t\t\treturn () => result.push(null);\n\t\t\t\tcase NULL_AND_TRUE_HEADER:\n\t\t\t\t\treturn () => result.push(null, true);\n\t\t\t\tcase NULL_AND_FALSE_HEADER:\n\t\t\t\t\treturn () => result.push(null, false);\n\t\t\t\tcase NULL_AND_I8_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tif (currentIsBuffer) {\n\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t/** @type {Buffer} */ (currentBuffer).readInt8(currentPosition)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcurrentPosition += I8_SIZE;\n\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.push(null, read(I8_SIZE).readInt8(0));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase NULL_AND_I32_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tresult.push(null);\n\t\t\t\t\t\tif (isInCurrentBuffer(I32_SIZE)) {\n\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\t/** @type {Buffer} */ (currentBuffer).readInt32LE(\n\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcurrentPosition += I32_SIZE;\n\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.push(read(I32_SIZE).readInt32LE(0));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase NULLS8_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst len = readU8() + 4;\n\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\tresult.push(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase NULLS32_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst len = readU32() + 260;\n\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\tresult.push(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase BOOLEANS_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst innerHeader = readU8();\n\t\t\t\t\t\tif ((innerHeader & 0xf0) === 0) {\n\t\t\t\t\t\t\treadBits(innerHeader, 3);\n\t\t\t\t\t\t} else if ((innerHeader & 0xe0) === 0) {\n\t\t\t\t\t\t\treadBits(innerHeader, 4);\n\t\t\t\t\t\t} else if ((innerHeader & 0xc0) === 0) {\n\t\t\t\t\t\t\treadBits(innerHeader, 5);\n\t\t\t\t\t\t} else if ((innerHeader & 0x80) === 0) {\n\t\t\t\t\t\t\treadBits(innerHeader, 6);\n\t\t\t\t\t\t} else if (innerHeader !== 0xff) {\n\t\t\t\t\t\t\tlet count = (innerHeader & 0x7f) + 7;\n\t\t\t\t\t\t\twhile (count > 8) {\n\t\t\t\t\t\t\t\treadBits(readU8(), 8);\n\t\t\t\t\t\t\t\tcount -= 8;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treadBits(readU8(), count);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet count = readU32();\n\t\t\t\t\t\t\twhile (count > 8) {\n\t\t\t\t\t\t\t\treadBits(readU8(), 8);\n\t\t\t\t\t\t\t\tcount -= 8;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treadBits(readU8(), count);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase STRING_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst len = readU32();\n\t\t\t\t\t\tif (isInCurrentBuffer(len) && currentPosition + len < 0x7fffffff) {\n\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\tcurrentBuffer.toString(\n\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\tcurrentPosition,\n\t\t\t\t\t\t\t\t\tcurrentPosition + len\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcurrentPosition += len;\n\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.push(read(len).toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase SHORT_STRING_HEADER:\n\t\t\t\t\treturn () => result.push(\"\");\n\t\t\t\tcase SHORT_STRING_HEADER | 1:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tif (currentIsBuffer && currentPosition < 0x7ffffffe) {\n\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\tcurrentBuffer.toString(\n\t\t\t\t\t\t\t\t\t\"latin1\",\n\t\t\t\t\t\t\t\t\tcurrentPosition,\n\t\t\t\t\t\t\t\t\tcurrentPosition + 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcurrentPosition++;\n\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.push(read(1).toString(\"latin1\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase I8_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tif (currentIsBuffer) {\n\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\t/** @type {Buffer} */ (currentBuffer).readInt8(currentPosition)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcurrentPosition++;\n\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.push(read(1).readInt8(0));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase BIGINT_I8_HEADER: {\n\t\t\t\t\tconst len = 1;\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst need = I8_SIZE * len;\n\n\t\t\t\t\t\tif (isInCurrentBuffer(need)) {\n\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\tconst value =\n\t\t\t\t\t\t\t\t\t/** @type {Buffer} */\n\t\t\t\t\t\t\t\t\t(currentBuffer).readInt8(currentPosition);\n\t\t\t\t\t\t\t\tresult.push(BigInt(value));\n\t\t\t\t\t\t\t\tcurrentPosition += I8_SIZE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst buf = read(need);\n\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\tconst value = buf.readInt8(i * I8_SIZE);\n\t\t\t\t\t\t\t\tresult.push(BigInt(value));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase BIGINT_I32_HEADER: {\n\t\t\t\t\tconst len = 1;\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst need = I32_SIZE * len;\n\t\t\t\t\t\tif (isInCurrentBuffer(need)) {\n\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\tconst value = /** @type {Buffer} */ (currentBuffer).readInt32LE(\n\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tresult.push(BigInt(value));\n\t\t\t\t\t\t\t\tcurrentPosition += I32_SIZE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst buf = read(need);\n\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\tconst value = buf.readInt32LE(i * I32_SIZE);\n\t\t\t\t\t\t\t\tresult.push(BigInt(value));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase BIGINT_HEADER: {\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst len = readU32();\n\t\t\t\t\t\tif (isInCurrentBuffer(len) && currentPosition + len < 0x7fffffff) {\n\t\t\t\t\t\t\tconst value = currentBuffer.toString(\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tcurrentPosition,\n\t\t\t\t\t\t\t\tcurrentPosition + len\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tresult.push(BigInt(value));\n\t\t\t\t\t\t\tcurrentPosition += len;\n\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst value = read(len).toString();\n\t\t\t\t\t\t\tresult.push(BigInt(value));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tif (header <= 10) {\n\t\t\t\t\t\treturn () => result.push(header);\n\t\t\t\t\t} else if ((header & SHORT_STRING_HEADER) === SHORT_STRING_HEADER) {\n\t\t\t\t\t\tconst len = header & SHORT_STRING_LENGTH_MASK;\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tisInCurrentBuffer(len) &&\n\t\t\t\t\t\t\t\tcurrentPosition + len < 0x7fffffff\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\t\tcurrentBuffer.toString(\n\t\t\t\t\t\t\t\t\t\t\"latin1\",\n\t\t\t\t\t\t\t\t\t\tcurrentPosition,\n\t\t\t\t\t\t\t\t\t\tcurrentPosition + len\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcurrentPosition += len;\n\t\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult.push(read(len).toString(\"latin1\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if ((header & NUMBERS_HEADER_MASK) === F64_HEADER) {\n\t\t\t\t\t\tconst len = (header & NUMBERS_COUNT_MASK) + 1;\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\tconst need = F64_SIZE * len;\n\t\t\t\t\t\t\tif (isInCurrentBuffer(need)) {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\t\t\t/** @type {Buffer} */ (currentBuffer).readDoubleLE(\n\t\t\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tcurrentPosition += F64_SIZE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst buf = read(need);\n\t\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\t\tresult.push(buf.readDoubleLE(i * F64_SIZE));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if ((header & NUMBERS_HEADER_MASK) === I32_HEADER) {\n\t\t\t\t\t\tconst len = (header & NUMBERS_COUNT_MASK) + 1;\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\tconst need = I32_SIZE * len;\n\t\t\t\t\t\t\tif (isInCurrentBuffer(need)) {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\t\t\t/** @type {Buffer} */ (currentBuffer).readInt32LE(\n\t\t\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tcurrentPosition += I32_SIZE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst buf = read(need);\n\t\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\t\tresult.push(buf.readInt32LE(i * I32_SIZE));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if ((header & NUMBERS_HEADER_MASK) === I8_HEADER) {\n\t\t\t\t\t\tconst len = (header & NUMBERS_COUNT_MASK) + 1;\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\tconst need = I8_SIZE * len;\n\t\t\t\t\t\t\tif (isInCurrentBuffer(need)) {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\t\t\t/** @type {Buffer} */ (currentBuffer).readInt8(\n\t\t\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tcurrentPosition += I8_SIZE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst buf = read(need);\n\t\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\t\tresult.push(buf.readInt8(i * I8_SIZE));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Unexpected header byte 0x${header.toString(16)}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t/** @type {DeserializedType} */\n\t\tlet result = [];\n\t\twhile (currentBuffer !== null) {\n\t\t\tif (typeof currentBuffer === \"function\") {\n\t\t\t\tresult.push(this._deserializeLazy(currentBuffer, context));\n\t\t\t\tcurrentDataItem++;\n\t\t\t\tcurrentBuffer =\n\t\t\t\t\tcurrentDataItem < data.length ? data[currentDataItem] : null;\n\t\t\t\tcurrentIsBuffer = Buffer.isBuffer(currentBuffer);\n\t\t\t} else {\n\t\t\t\tconst header = readU8();\n\t\t\t\tdispatchTable[header]();\n\t\t\t}\n\t\t}\n\n\t\t// avoid leaking memory in context\n\t\tlet _result = result;\n\t\tresult = undefined;\n\t\treturn _result;\n\t}\n}\n\nmodule.exports = BinaryMiddleware;\n\nmodule.exports.MEASURE_START_OPERATION = MEASURE_START_OPERATION;\nmodule.exports.MEASURE_END_OPERATION = MEASURE_END_OPERATION;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
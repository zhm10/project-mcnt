{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Florent Cailhol @ooflorent\n*/\n\n\"use strict\";\n\nconst {\n  ConcatSource\n} = require(\"webpack-sources\");\nconst makeSerializable = require(\"./util/makeSerializable\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./Generator\").GenerateContext} GenerateContext */\n/** @typedef {import(\"./serialization/ObjectMiddleware\").ObjectDeserializerContext} ObjectDeserializerContext */\n/** @typedef {import(\"./serialization/ObjectMiddleware\").ObjectSerializerContext} ObjectSerializerContext */\n\n/**\n * @template T\n * @param {InitFragment<T>} fragment the init fragment\n * @param {number} index index\n * @returns {[InitFragment<T>, number]} tuple with both\n */\nconst extractFragmentIndex = (fragment, index) => [fragment, index];\n\n/**\n * @template T\n * @param {[InitFragment<T>, number]} a first pair\n * @param {[InitFragment<T>, number]} b second pair\n * @returns {number} sort value\n */\nconst sortFragmentWithIndex = ([a, i], [b, j]) => {\n  const stageCmp = a.stage - b.stage;\n  if (stageCmp !== 0) return stageCmp;\n  const positionCmp = a.position - b.position;\n  if (positionCmp !== 0) return positionCmp;\n  return i - j;\n};\n\n/**\n * @template GenerateContext\n */\nclass InitFragment {\n  /**\n   * @param {string | Source | undefined} content the source code that will be included as initialization code\n   * @param {number} stage category of initialization code (contribute to order)\n   * @param {number} position position in the category (contribute to order)\n   * @param {string=} key unique key to avoid emitting the same initialization code twice\n   * @param {string | Source=} endContent the source code that will be included at the end of the module\n   */\n  constructor(content, stage, position, key, endContent) {\n    this.content = content;\n    this.stage = stage;\n    this.position = position;\n    this.key = key;\n    this.endContent = endContent;\n  }\n\n  /**\n   * @param {GenerateContext} context context\n   * @returns {string | Source | undefined} the source code that will be included as initialization code\n   */\n  getContent(context) {\n    return this.content;\n  }\n\n  /**\n   * @param {GenerateContext} context context\n   * @returns {string|Source=} the source code that will be included at the end of the module\n   */\n  getEndContent(context) {\n    return this.endContent;\n  }\n\n  /**\n   * @template Context\n   * @template T\n   * @param {Source} source sources\n   * @param {InitFragment<T>[]} initFragments init fragments\n   * @param {Context} context context\n   * @returns {Source} source\n   */\n  static addToSource(source, initFragments, context) {\n    if (initFragments.length > 0) {\n      // Sort fragments by position. If 2 fragments have the same position,\n      // use their index.\n      const sortedFragments = initFragments.map(extractFragmentIndex).sort(sortFragmentWithIndex);\n\n      // Deduplicate fragments. If a fragment has no key, it is always included.\n      const keyedFragments = new Map();\n      for (const [fragment] of sortedFragments) {\n        if (typeof ( /** @type {InitFragment<T> & { mergeAll?: (fragments: InitFragment<Context>[]) => InitFragment<Context>[] }} */\n        fragment.mergeAll) === \"function\") {\n          if (!fragment.key) {\n            throw new Error(`InitFragment with mergeAll function must have a valid key: ${fragment.constructor.name}`);\n          }\n          const oldValue = keyedFragments.get(fragment.key);\n          if (oldValue === undefined) {\n            keyedFragments.set(fragment.key, fragment);\n          } else if (Array.isArray(oldValue)) {\n            oldValue.push(fragment);\n          } else {\n            keyedFragments.set(fragment.key, [oldValue, fragment]);\n          }\n          continue;\n        } else if (typeof fragment.merge === \"function\") {\n          const oldValue = keyedFragments.get(fragment.key);\n          if (oldValue !== undefined) {\n            keyedFragments.set(fragment.key, fragment.merge(oldValue));\n            continue;\n          }\n        }\n        keyedFragments.set(fragment.key || Symbol(), fragment);\n      }\n      const concatSource = new ConcatSource();\n      const endContents = [];\n      for (let fragment of keyedFragments.values()) {\n        if (Array.isArray(fragment)) {\n          fragment = fragment[0].mergeAll(fragment);\n        }\n        concatSource.add(fragment.getContent(context));\n        const endContent = fragment.getEndContent(context);\n        if (endContent) {\n          endContents.push(endContent);\n        }\n      }\n      concatSource.add(source);\n      for (const content of endContents.reverse()) {\n        concatSource.add(content);\n      }\n      return concatSource;\n    } else {\n      return source;\n    }\n  }\n\n  /**\n   * @param {ObjectSerializerContext} context context\n   */\n  serialize(context) {\n    const {\n      write\n    } = context;\n    write(this.content);\n    write(this.stage);\n    write(this.position);\n    write(this.key);\n    write(this.endContent);\n  }\n\n  /**\n   * @param {ObjectDeserializerContext} context context\n   */\n  deserialize(context) {\n    const {\n      read\n    } = context;\n    this.content = read();\n    this.stage = read();\n    this.position = read();\n    this.key = read();\n    this.endContent = read();\n  }\n}\nmakeSerializable(InitFragment, \"webpack/lib/InitFragment\");\nInitFragment.prototype.merge = /** @type {TODO} */\nundefined;\nInitFragment.STAGE_CONSTANTS = 10;\nInitFragment.STAGE_ASYNC_BOUNDARY = 20;\nInitFragment.STAGE_HARMONY_EXPORTS = 30;\nInitFragment.STAGE_HARMONY_IMPORTS = 40;\nInitFragment.STAGE_PROVIDES = 50;\nInitFragment.STAGE_ASYNC_DEPENDENCIES = 60;\nInitFragment.STAGE_ASYNC_HARMONY_IMPORTS = 70;\nmodule.exports = InitFragment;","map":{"version":3,"names":["ConcatSource","require","makeSerializable","extractFragmentIndex","fragment","index","sortFragmentWithIndex","a","i","b","j","stageCmp","stage","positionCmp","position","InitFragment","constructor","content","key","endContent","getContent","context","getEndContent","addToSource","source","initFragments","length","sortedFragments","map","sort","keyedFragments","Map","mergeAll","Error","name","oldValue","get","undefined","set","Array","isArray","push","merge","Symbol","concatSource","endContents","values","add","reverse","serialize","write","deserialize","read","prototype","STAGE_CONSTANTS","STAGE_ASYNC_BOUNDARY","STAGE_HARMONY_EXPORTS","STAGE_HARMONY_IMPORTS","STAGE_PROVIDES","STAGE_ASYNC_DEPENDENCIES","STAGE_ASYNC_HARMONY_IMPORTS","module","exports"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/InitFragment.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Florent Cailhol @ooflorent\n*/\n\n\"use strict\";\n\nconst { ConcatSource } = require(\"webpack-sources\");\nconst makeSerializable = require(\"./util/makeSerializable\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./Generator\").GenerateContext} GenerateContext */\n/** @typedef {import(\"./serialization/ObjectMiddleware\").ObjectDeserializerContext} ObjectDeserializerContext */\n/** @typedef {import(\"./serialization/ObjectMiddleware\").ObjectSerializerContext} ObjectSerializerContext */\n\n/**\n * @template T\n * @param {InitFragment<T>} fragment the init fragment\n * @param {number} index index\n * @returns {[InitFragment<T>, number]} tuple with both\n */\nconst extractFragmentIndex = (fragment, index) => [fragment, index];\n\n/**\n * @template T\n * @param {[InitFragment<T>, number]} a first pair\n * @param {[InitFragment<T>, number]} b second pair\n * @returns {number} sort value\n */\nconst sortFragmentWithIndex = ([a, i], [b, j]) => {\n\tconst stageCmp = a.stage - b.stage;\n\tif (stageCmp !== 0) return stageCmp;\n\tconst positionCmp = a.position - b.position;\n\tif (positionCmp !== 0) return positionCmp;\n\treturn i - j;\n};\n\n/**\n * @template GenerateContext\n */\nclass InitFragment {\n\t/**\n\t * @param {string | Source | undefined} content the source code that will be included as initialization code\n\t * @param {number} stage category of initialization code (contribute to order)\n\t * @param {number} position position in the category (contribute to order)\n\t * @param {string=} key unique key to avoid emitting the same initialization code twice\n\t * @param {string | Source=} endContent the source code that will be included at the end of the module\n\t */\n\tconstructor(content, stage, position, key, endContent) {\n\t\tthis.content = content;\n\t\tthis.stage = stage;\n\t\tthis.position = position;\n\t\tthis.key = key;\n\t\tthis.endContent = endContent;\n\t}\n\n\t/**\n\t * @param {GenerateContext} context context\n\t * @returns {string | Source | undefined} the source code that will be included as initialization code\n\t */\n\tgetContent(context) {\n\t\treturn this.content;\n\t}\n\n\t/**\n\t * @param {GenerateContext} context context\n\t * @returns {string|Source=} the source code that will be included at the end of the module\n\t */\n\tgetEndContent(context) {\n\t\treturn this.endContent;\n\t}\n\n\t/**\n\t * @template Context\n\t * @template T\n\t * @param {Source} source sources\n\t * @param {InitFragment<T>[]} initFragments init fragments\n\t * @param {Context} context context\n\t * @returns {Source} source\n\t */\n\tstatic addToSource(source, initFragments, context) {\n\t\tif (initFragments.length > 0) {\n\t\t\t// Sort fragments by position. If 2 fragments have the same position,\n\t\t\t// use their index.\n\t\t\tconst sortedFragments = initFragments\n\t\t\t\t.map(extractFragmentIndex)\n\t\t\t\t.sort(sortFragmentWithIndex);\n\n\t\t\t// Deduplicate fragments. If a fragment has no key, it is always included.\n\t\t\tconst keyedFragments = new Map();\n\t\t\tfor (const [fragment] of sortedFragments) {\n\t\t\t\tif (\n\t\t\t\t\ttypeof (\n\t\t\t\t\t\t/** @type {InitFragment<T> & { mergeAll?: (fragments: InitFragment<Context>[]) => InitFragment<Context>[] }} */\n\t\t\t\t\t\t(fragment).mergeAll\n\t\t\t\t\t) === \"function\"\n\t\t\t\t) {\n\t\t\t\t\tif (!fragment.key) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`InitFragment with mergeAll function must have a valid key: ${fragment.constructor.name}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tconst oldValue = keyedFragments.get(fragment.key);\n\t\t\t\t\tif (oldValue === undefined) {\n\t\t\t\t\t\tkeyedFragments.set(fragment.key, fragment);\n\t\t\t\t\t} else if (Array.isArray(oldValue)) {\n\t\t\t\t\t\toldValue.push(fragment);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkeyedFragments.set(fragment.key, [oldValue, fragment]);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (typeof fragment.merge === \"function\") {\n\t\t\t\t\tconst oldValue = keyedFragments.get(fragment.key);\n\t\t\t\t\tif (oldValue !== undefined) {\n\t\t\t\t\t\tkeyedFragments.set(fragment.key, fragment.merge(oldValue));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tkeyedFragments.set(fragment.key || Symbol(), fragment);\n\t\t\t}\n\n\t\t\tconst concatSource = new ConcatSource();\n\t\t\tconst endContents = [];\n\t\t\tfor (let fragment of keyedFragments.values()) {\n\t\t\t\tif (Array.isArray(fragment)) {\n\t\t\t\t\tfragment = fragment[0].mergeAll(fragment);\n\t\t\t\t}\n\t\t\t\tconcatSource.add(fragment.getContent(context));\n\t\t\t\tconst endContent = fragment.getEndContent(context);\n\t\t\t\tif (endContent) {\n\t\t\t\t\tendContents.push(endContent);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconcatSource.add(source);\n\t\t\tfor (const content of endContents.reverse()) {\n\t\t\t\tconcatSource.add(content);\n\t\t\t}\n\t\t\treturn concatSource;\n\t\t} else {\n\t\t\treturn source;\n\t\t}\n\t}\n\n\t/**\n\t * @param {ObjectSerializerContext} context context\n\t */\n\tserialize(context) {\n\t\tconst { write } = context;\n\n\t\twrite(this.content);\n\t\twrite(this.stage);\n\t\twrite(this.position);\n\t\twrite(this.key);\n\t\twrite(this.endContent);\n\t}\n\n\t/**\n\t * @param {ObjectDeserializerContext} context context\n\t */\n\tdeserialize(context) {\n\t\tconst { read } = context;\n\n\t\tthis.content = read();\n\t\tthis.stage = read();\n\t\tthis.position = read();\n\t\tthis.key = read();\n\t\tthis.endContent = read();\n\t}\n}\n\nmakeSerializable(InitFragment, \"webpack/lib/InitFragment\");\n\nInitFragment.prototype.merge =\n\t/** @type {TODO} */\n\t(undefined);\n\nInitFragment.STAGE_CONSTANTS = 10;\nInitFragment.STAGE_ASYNC_BOUNDARY = 20;\nInitFragment.STAGE_HARMONY_EXPORTS = 30;\nInitFragment.STAGE_HARMONY_IMPORTS = 40;\nInitFragment.STAGE_PROVIDES = 50;\nInitFragment.STAGE_ASYNC_DEPENDENCIES = 60;\nInitFragment.STAGE_ASYNC_HARMONY_IMPORTS = 70;\n\nmodule.exports = InitFragment;\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAM;EAAEA;AAAa,CAAC,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AACnD,MAAMC,gBAAgB,GAAGD,OAAO,CAAC,yBAAyB,CAAC;;AAE3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,oBAAoB,GAAGA,CAACC,QAAQ,EAAEC,KAAK,KAAK,CAACD,QAAQ,EAAEC,KAAK,CAAC;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,qBAAqB,GAAGA,CAAC,CAACC,CAAC,EAAEC,CAAC,CAAC,EAAE,CAACC,CAAC,EAAEC,CAAC,CAAC,KAAK;EACjD,MAAMC,QAAQ,GAAGJ,CAAC,CAACK,KAAK,GAAGH,CAAC,CAACG,KAAK;EAClC,IAAID,QAAQ,KAAK,CAAC,EAAE,OAAOA,QAAQ;EACnC,MAAME,WAAW,GAAGN,CAAC,CAACO,QAAQ,GAAGL,CAAC,CAACK,QAAQ;EAC3C,IAAID,WAAW,KAAK,CAAC,EAAE,OAAOA,WAAW;EACzC,OAAOL,CAAC,GAAGE,CAAC;AACb,CAAC;;AAED;AACA;AACA;AACA,MAAMK,YAAY,CAAC;EAClB;AACD;AACA;AACA;AACA;AACA;AACA;EACCC,WAAWA,CAACC,OAAO,EAAEL,KAAK,EAAEE,QAAQ,EAAEI,GAAG,EAAEC,UAAU,EAAE;IACtD,IAAI,CAACF,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACL,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACE,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACI,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,UAAU,GAAGA,UAAU;EAC7B;;EAEA;AACD;AACA;AACA;EACCC,UAAUA,CAACC,OAAO,EAAE;IACnB,OAAO,IAAI,CAACJ,OAAO;EACpB;;EAEA;AACD;AACA;AACA;EACCK,aAAaA,CAACD,OAAO,EAAE;IACtB,OAAO,IAAI,CAACF,UAAU;EACvB;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;EACC,OAAOI,WAAWA,CAACC,MAAM,EAAEC,aAAa,EAAEJ,OAAO,EAAE;IAClD,IAAII,aAAa,CAACC,MAAM,GAAG,CAAC,EAAE;MAC7B;MACA;MACA,MAAMC,eAAe,GAAGF,aAAa,CACnCG,GAAG,CAACzB,oBAAoB,CAAC,CACzB0B,IAAI,CAACvB,qBAAqB,CAAC;;MAE7B;MACA,MAAMwB,cAAc,GAAG,IAAIC,GAAG,CAAC,CAAC;MAChC,KAAK,MAAM,CAAC3B,QAAQ,CAAC,IAAIuB,eAAe,EAAE;QACzC,IACC,SACC;QACCvB,QAAQ,CAAE4B,QAAQ,CACnB,KAAK,UAAU,EACf;UACD,IAAI,CAAC5B,QAAQ,CAACc,GAAG,EAAE;YAClB,MAAM,IAAIe,KAAK,CACd,8DAA8D7B,QAAQ,CAACY,WAAW,CAACkB,IAAI,EACxF,CAAC;UACF;UACA,MAAMC,QAAQ,GAAGL,cAAc,CAACM,GAAG,CAAChC,QAAQ,CAACc,GAAG,CAAC;UACjD,IAAIiB,QAAQ,KAAKE,SAAS,EAAE;YAC3BP,cAAc,CAACQ,GAAG,CAAClC,QAAQ,CAACc,GAAG,EAAEd,QAAQ,CAAC;UAC3C,CAAC,MAAM,IAAImC,KAAK,CAACC,OAAO,CAACL,QAAQ,CAAC,EAAE;YACnCA,QAAQ,CAACM,IAAI,CAACrC,QAAQ,CAAC;UACxB,CAAC,MAAM;YACN0B,cAAc,CAACQ,GAAG,CAAClC,QAAQ,CAACc,GAAG,EAAE,CAACiB,QAAQ,EAAE/B,QAAQ,CAAC,CAAC;UACvD;UACA;QACD,CAAC,MAAM,IAAI,OAAOA,QAAQ,CAACsC,KAAK,KAAK,UAAU,EAAE;UAChD,MAAMP,QAAQ,GAAGL,cAAc,CAACM,GAAG,CAAChC,QAAQ,CAACc,GAAG,CAAC;UACjD,IAAIiB,QAAQ,KAAKE,SAAS,EAAE;YAC3BP,cAAc,CAACQ,GAAG,CAAClC,QAAQ,CAACc,GAAG,EAAEd,QAAQ,CAACsC,KAAK,CAACP,QAAQ,CAAC,CAAC;YAC1D;UACD;QACD;QACAL,cAAc,CAACQ,GAAG,CAAClC,QAAQ,CAACc,GAAG,IAAIyB,MAAM,CAAC,CAAC,EAAEvC,QAAQ,CAAC;MACvD;MAEA,MAAMwC,YAAY,GAAG,IAAI5C,YAAY,CAAC,CAAC;MACvC,MAAM6C,WAAW,GAAG,EAAE;MACtB,KAAK,IAAIzC,QAAQ,IAAI0B,cAAc,CAACgB,MAAM,CAAC,CAAC,EAAE;QAC7C,IAAIP,KAAK,CAACC,OAAO,CAACpC,QAAQ,CAAC,EAAE;UAC5BA,QAAQ,GAAGA,QAAQ,CAAC,CAAC,CAAC,CAAC4B,QAAQ,CAAC5B,QAAQ,CAAC;QAC1C;QACAwC,YAAY,CAACG,GAAG,CAAC3C,QAAQ,CAACgB,UAAU,CAACC,OAAO,CAAC,CAAC;QAC9C,MAAMF,UAAU,GAAGf,QAAQ,CAACkB,aAAa,CAACD,OAAO,CAAC;QAClD,IAAIF,UAAU,EAAE;UACf0B,WAAW,CAACJ,IAAI,CAACtB,UAAU,CAAC;QAC7B;MACD;MAEAyB,YAAY,CAACG,GAAG,CAACvB,MAAM,CAAC;MACxB,KAAK,MAAMP,OAAO,IAAI4B,WAAW,CAACG,OAAO,CAAC,CAAC,EAAE;QAC5CJ,YAAY,CAACG,GAAG,CAAC9B,OAAO,CAAC;MAC1B;MACA,OAAO2B,YAAY;IACpB,CAAC,MAAM;MACN,OAAOpB,MAAM;IACd;EACD;;EAEA;AACD;AACA;EACCyB,SAASA,CAAC5B,OAAO,EAAE;IAClB,MAAM;MAAE6B;IAAM,CAAC,GAAG7B,OAAO;IAEzB6B,KAAK,CAAC,IAAI,CAACjC,OAAO,CAAC;IACnBiC,KAAK,CAAC,IAAI,CAACtC,KAAK,CAAC;IACjBsC,KAAK,CAAC,IAAI,CAACpC,QAAQ,CAAC;IACpBoC,KAAK,CAAC,IAAI,CAAChC,GAAG,CAAC;IACfgC,KAAK,CAAC,IAAI,CAAC/B,UAAU,CAAC;EACvB;;EAEA;AACD;AACA;EACCgC,WAAWA,CAAC9B,OAAO,EAAE;IACpB,MAAM;MAAE+B;IAAK,CAAC,GAAG/B,OAAO;IAExB,IAAI,CAACJ,OAAO,GAAGmC,IAAI,CAAC,CAAC;IACrB,IAAI,CAACxC,KAAK,GAAGwC,IAAI,CAAC,CAAC;IACnB,IAAI,CAACtC,QAAQ,GAAGsC,IAAI,CAAC,CAAC;IACtB,IAAI,CAAClC,GAAG,GAAGkC,IAAI,CAAC,CAAC;IACjB,IAAI,CAACjC,UAAU,GAAGiC,IAAI,CAAC,CAAC;EACzB;AACD;AAEAlD,gBAAgB,CAACa,YAAY,EAAE,0BAA0B,CAAC;AAE1DA,YAAY,CAACsC,SAAS,CAACX,KAAK,GAC3B;AACCL,SAAU;AAEZtB,YAAY,CAACuC,eAAe,GAAG,EAAE;AACjCvC,YAAY,CAACwC,oBAAoB,GAAG,EAAE;AACtCxC,YAAY,CAACyC,qBAAqB,GAAG,EAAE;AACvCzC,YAAY,CAAC0C,qBAAqB,GAAG,EAAE;AACvC1C,YAAY,CAAC2C,cAAc,GAAG,EAAE;AAChC3C,YAAY,CAAC4C,wBAAwB,GAAG,EAAE;AAC1C5C,YAAY,CAAC6C,2BAA2B,GAAG,EAAE;AAE7CC,MAAM,CAACC,OAAO,GAAG/C,YAAY","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
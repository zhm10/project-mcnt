{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  fileURLToPath\n} = require(\"url\");\nconst CommentCompilationWarning = require(\"../CommentCompilationWarning\");\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst UnsupportedFeatureWarning = require(\"../UnsupportedFeatureWarning\");\nconst WebpackError = require(\"../WebpackError\");\nconst BasicEvaluatedExpression = require(\"../javascript/BasicEvaluatedExpression\");\nconst {\n  evaluateToIdentifier,\n  evaluateToString,\n  expressionIsUnsupported,\n  toConstantDependency\n} = require(\"../javascript/JavascriptParserHelpers\");\nconst CommonJsFullRequireDependency = require(\"./CommonJsFullRequireDependency\");\nconst CommonJsRequireContextDependency = require(\"./CommonJsRequireContextDependency\");\nconst CommonJsRequireDependency = require(\"./CommonJsRequireDependency\");\nconst ConstDependency = require(\"./ConstDependency\");\nconst ContextDependencyHelpers = require(\"./ContextDependencyHelpers\");\nconst LocalModuleDependency = require(\"./LocalModuleDependency\");\nconst {\n  getLocalModule\n} = require(\"./LocalModulesHelpers\");\nconst RequireHeaderDependency = require(\"./RequireHeaderDependency\");\nconst RequireResolveContextDependency = require(\"./RequireResolveContextDependency\");\nconst RequireResolveDependency = require(\"./RequireResolveDependency\");\nconst RequireResolveHeaderDependency = require(\"./RequireResolveHeaderDependency\");\n\n/** @typedef {import(\"estree\").CallExpression} CallExpression */\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"estree\").NewExpression} NewExpression */\n/** @typedef {import(\"../../declarations/WebpackOptions\").JavascriptParserOptions} JavascriptParserOptions */\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../javascript/JavascriptParser\").ImportSource} ImportSource */\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n\nconst createRequireSpecifierTag = Symbol(\"createRequire\");\nconst createdRequireIdentifierTag = Symbol(\"createRequire()\");\nclass CommonJsImportsParserPlugin {\n  /**\n   * @param {JavascriptParserOptions} options parser options\n   */\n  constructor(options) {\n    this.options = options;\n  }\n\n  /**\n   * @param {JavascriptParser} parser the parser\n   * @returns {void}\n   */\n  apply(parser) {\n    const options = this.options;\n    const getContext = () => {\n      if (parser.currentTagData) {\n        const {\n          context\n        } = parser.currentTagData;\n        return context;\n      }\n    };\n\n    //#region metadata\n    /**\n     * @param {string} expression expression\n     * @param {() => string[]} getMembers get members\n     */\n    const tapRequireExpression = (expression, getMembers) => {\n      parser.hooks.typeof.for(expression).tap(\"CommonJsImportsParserPlugin\", toConstantDependency(parser, JSON.stringify(\"function\")));\n      parser.hooks.evaluateTypeof.for(expression).tap(\"CommonJsImportsParserPlugin\", evaluateToString(\"function\"));\n      parser.hooks.evaluateIdentifier.for(expression).tap(\"CommonJsImportsParserPlugin\", evaluateToIdentifier(expression, \"require\", getMembers, true));\n    };\n    /**\n     * @param {string | symbol} tag tag\n     */\n    const tapRequireExpressionTag = tag => {\n      parser.hooks.typeof.for(tag).tap(\"CommonJsImportsParserPlugin\", toConstantDependency(parser, JSON.stringify(\"function\")));\n      parser.hooks.evaluateTypeof.for(tag).tap(\"CommonJsImportsParserPlugin\", evaluateToString(\"function\"));\n    };\n    tapRequireExpression(\"require\", () => []);\n    tapRequireExpression(\"require.resolve\", () => [\"resolve\"]);\n    tapRequireExpression(\"require.resolveWeak\", () => [\"resolveWeak\"]);\n    //#endregion\n\n    // Weird stuff //\n    parser.hooks.assign.for(\"require\").tap(\"CommonJsImportsParserPlugin\", expr => {\n      // to not leak to global \"require\", we need to define a local require here.\n      const dep = new ConstDependency(\"var require;\", 0);\n      dep.loc = /** @type {DependencyLocation} */expr.loc;\n      parser.state.module.addPresentationalDependency(dep);\n      return true;\n    });\n\n    //#region Unsupported\n    parser.hooks.expression.for(\"require.main\").tap(\"CommonJsImportsParserPlugin\", expressionIsUnsupported(parser, \"require.main is not supported by webpack.\"));\n    parser.hooks.call.for(\"require.main.require\").tap(\"CommonJsImportsParserPlugin\", expressionIsUnsupported(parser, \"require.main.require is not supported by webpack.\"));\n    parser.hooks.expression.for(\"module.parent.require\").tap(\"CommonJsImportsParserPlugin\", expressionIsUnsupported(parser, \"module.parent.require is not supported by webpack.\"));\n    parser.hooks.call.for(\"module.parent.require\").tap(\"CommonJsImportsParserPlugin\", expressionIsUnsupported(parser, \"module.parent.require is not supported by webpack.\"));\n    //#endregion\n\n    //#region Renaming\n    /**\n     * @param {Expression} expr expression\n     * @returns {boolean} true when set undefined\n     */\n    const defineUndefined = expr => {\n      // To avoid \"not defined\" error, replace the value with undefined\n      const dep = new ConstDependency(\"undefined\", /** @type {Range} */expr.range);\n      dep.loc = /** @type {DependencyLocation} */expr.loc;\n      parser.state.module.addPresentationalDependency(dep);\n      return false;\n    };\n    parser.hooks.canRename.for(\"require\").tap(\"CommonJsImportsParserPlugin\", () => true);\n    parser.hooks.rename.for(\"require\").tap(\"CommonJsImportsParserPlugin\", defineUndefined);\n    //#endregion\n\n    //#region Inspection\n    const requireCache = toConstantDependency(parser, RuntimeGlobals.moduleCache, [RuntimeGlobals.moduleCache, RuntimeGlobals.moduleId, RuntimeGlobals.moduleLoaded]);\n    parser.hooks.expression.for(\"require.cache\").tap(\"CommonJsImportsParserPlugin\", requireCache);\n    //#endregion\n\n    //#region Require as expression\n    /**\n     * @param {Expression} expr expression\n     * @returns {boolean} true when handled\n     */\n    const requireAsExpressionHandler = expr => {\n      const dep = new CommonJsRequireContextDependency({\n        request: options.unknownContextRequest,\n        recursive: options.unknownContextRecursive,\n        regExp: options.unknownContextRegExp,\n        mode: \"sync\"\n      }, /** @type {Range} */expr.range, undefined, parser.scope.inShorthand, getContext());\n      dep.critical = options.unknownContextCritical && \"require function is used in a way in which dependencies cannot be statically extracted\";\n      dep.loc = /** @type {DependencyLocation} */expr.loc;\n      dep.optional = !!parser.scope.inTry;\n      parser.state.current.addDependency(dep);\n      return true;\n    };\n    parser.hooks.expression.for(\"require\").tap(\"CommonJsImportsParserPlugin\", requireAsExpressionHandler);\n    //#endregion\n\n    //#region Require\n    /**\n     * @param {CallExpression | NewExpression} expr expression\n     * @param {BasicEvaluatedExpression} param param\n     * @returns {boolean | void} true when handled\n     */\n    const processRequireItem = (expr, param) => {\n      if (param.isString()) {\n        const dep = new CommonJsRequireDependency( /** @type {string} */param.string, /** @type {Range} */param.range, getContext());\n        dep.loc = /** @type {DependencyLocation} */expr.loc;\n        dep.optional = !!parser.scope.inTry;\n        parser.state.current.addDependency(dep);\n        return true;\n      }\n    };\n    /**\n     * @param {CallExpression | NewExpression} expr expression\n     * @param {BasicEvaluatedExpression} param param\n     * @returns {boolean | void} true when handled\n     */\n    const processRequireContext = (expr, param) => {\n      const dep = ContextDependencyHelpers.create(CommonJsRequireContextDependency, /** @type {Range} */expr.range, param, expr, options, {\n        category: \"commonjs\"\n      }, parser, undefined, getContext());\n      if (!dep) return;\n      dep.loc = /** @type {DependencyLocation} */expr.loc;\n      dep.optional = !!parser.scope.inTry;\n      parser.state.current.addDependency(dep);\n      return true;\n    };\n    /**\n     * @param {boolean} callNew true, when require is called with new\n     * @returns {(expr: CallExpression | NewExpression) => (boolean | void)} handler\n     */\n    const createRequireHandler = callNew => expr => {\n      if (options.commonjsMagicComments) {\n        const {\n          options: requireOptions,\n          errors: commentErrors\n        } = parser.parseCommentOptions( /** @type {Range} */expr.range);\n        if (commentErrors) {\n          for (const e of commentErrors) {\n            const {\n              comment\n            } = e;\n            parser.state.module.addWarning(new CommentCompilationWarning(`Compilation error while processing magic comment(-s): /*${comment.value}*/: ${e.message}`, comment.loc));\n          }\n        }\n        if (requireOptions) {\n          if (requireOptions.webpackIgnore !== undefined) {\n            if (typeof requireOptions.webpackIgnore !== \"boolean\") {\n              parser.state.module.addWarning(new UnsupportedFeatureWarning(`\\`webpackIgnore\\` expected a boolean, but received: ${requireOptions.webpackIgnore}.`, /** @type {DependencyLocation} */expr.loc));\n            } else {\n              // Do not instrument `require()` if `webpackIgnore` is `true`\n              if (requireOptions.webpackIgnore) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n      if (expr.arguments.length !== 1) return;\n      let localModule;\n      const param = parser.evaluateExpression(expr.arguments[0]);\n      if (param.isConditional()) {\n        let isExpression = false;\n        for (const p of ( /** @type {BasicEvaluatedExpression[]} */\n        param.options)) {\n          const result = processRequireItem(expr, p);\n          if (result === undefined) {\n            isExpression = true;\n          }\n        }\n        if (!isExpression) {\n          const dep = new RequireHeaderDependency( /** @type {Range} */expr.callee.range);\n          dep.loc = /** @type {DependencyLocation} */expr.loc;\n          parser.state.module.addPresentationalDependency(dep);\n          return true;\n        }\n      }\n      if (param.isString() && (localModule = getLocalModule(parser.state, /** @type {string} */param.string))) {\n        localModule.flagUsed();\n        const dep = new LocalModuleDependency(localModule, /** @type {Range} */expr.range, callNew);\n        dep.loc = /** @type {DependencyLocation} */expr.loc;\n        parser.state.module.addPresentationalDependency(dep);\n      } else {\n        const result = processRequireItem(expr, param);\n        if (result === undefined) {\n          processRequireContext(expr, param);\n        } else {\n          const dep = new RequireHeaderDependency( /** @type {Range} */expr.callee.range);\n          dep.loc = /** @type {DependencyLocation} */expr.loc;\n          parser.state.module.addPresentationalDependency(dep);\n        }\n      }\n      return true;\n    };\n    parser.hooks.call.for(\"require\").tap(\"CommonJsImportsParserPlugin\", createRequireHandler(false));\n    parser.hooks.new.for(\"require\").tap(\"CommonJsImportsParserPlugin\", createRequireHandler(true));\n    parser.hooks.call.for(\"module.require\").tap(\"CommonJsImportsParserPlugin\", createRequireHandler(false));\n    parser.hooks.new.for(\"module.require\").tap(\"CommonJsImportsParserPlugin\", createRequireHandler(true));\n    //#endregion\n\n    //#region Require with property access\n    /**\n     * @param {Expression} expr expression\n     * @param {string[]} calleeMembers callee members\n     * @param {CallExpression} callExpr call expression\n     * @param {string[]} members members\n     * @param {Range[]} memberRanges member ranges\n     * @returns {boolean | void} true when handled\n     */\n    const chainHandler = (expr, calleeMembers, callExpr, members, memberRanges) => {\n      if (callExpr.arguments.length !== 1) return;\n      const param = parser.evaluateExpression(callExpr.arguments[0]);\n      if (param.isString() && !getLocalModule(parser.state, /** @type {string} */param.string)) {\n        const dep = new CommonJsFullRequireDependency( /** @type {string} */param.string, /** @type {Range} */expr.range, members, /** @type {Range[]} */memberRanges);\n        dep.asiSafe = !parser.isAsiPosition( /** @type {Range} */expr.range[0]);\n        dep.optional = !!parser.scope.inTry;\n        dep.loc = /** @type {DependencyLocation} */expr.loc;\n        parser.state.current.addDependency(dep);\n        return true;\n      }\n    };\n    /**\n     * @param {CallExpression} expr expression\n     * @param {string[]} calleeMembers callee members\n     * @param {CallExpression} callExpr call expression\n     * @param {string[]} members members\n     * @param {Range[]} memberRanges member ranges\n     * @returns {boolean | void} true when handled\n     */\n    const callChainHandler = (expr, calleeMembers, callExpr, members, memberRanges) => {\n      if (callExpr.arguments.length !== 1) return;\n      const param = parser.evaluateExpression(callExpr.arguments[0]);\n      if (param.isString() && !getLocalModule(parser.state, /** @type {string} */param.string)) {\n        const dep = new CommonJsFullRequireDependency( /** @type {string} */param.string, /** @type {Range} */expr.callee.range, members, /** @type {Range[]} */memberRanges);\n        dep.call = true;\n        dep.asiSafe = !parser.isAsiPosition( /** @type {Range} */expr.range[0]);\n        dep.optional = !!parser.scope.inTry;\n        dep.loc = /** @type {DependencyLocation} */expr.callee.loc;\n        parser.state.current.addDependency(dep);\n        parser.walkExpressions(expr.arguments);\n        return true;\n      }\n    };\n    parser.hooks.memberChainOfCallMemberChain.for(\"require\").tap(\"CommonJsImportsParserPlugin\", chainHandler);\n    parser.hooks.memberChainOfCallMemberChain.for(\"module.require\").tap(\"CommonJsImportsParserPlugin\", chainHandler);\n    parser.hooks.callMemberChainOfCallMemberChain.for(\"require\").tap(\"CommonJsImportsParserPlugin\", callChainHandler);\n    parser.hooks.callMemberChainOfCallMemberChain.for(\"module.require\").tap(\"CommonJsImportsParserPlugin\", callChainHandler);\n    //#endregion\n\n    //#region Require.resolve\n    /**\n     * @param {CallExpression} expr call expression\n     * @param {boolean} weak weak\n     * @returns {boolean | void} true when handled\n     */\n    const processResolve = (expr, weak) => {\n      if (expr.arguments.length !== 1) return;\n      const param = parser.evaluateExpression(expr.arguments[0]);\n      if (param.isConditional()) {\n        for (const option of ( /** @type {BasicEvaluatedExpression[]} */\n        param.options)) {\n          const result = processResolveItem(expr, option, weak);\n          if (result === undefined) {\n            processResolveContext(expr, option, weak);\n          }\n        }\n        const dep = new RequireResolveHeaderDependency( /** @type {Range} */expr.callee.range);\n        dep.loc = /** @type {DependencyLocation} */expr.loc;\n        parser.state.module.addPresentationalDependency(dep);\n        return true;\n      } else {\n        const result = processResolveItem(expr, param, weak);\n        if (result === undefined) {\n          processResolveContext(expr, param, weak);\n        }\n        const dep = new RequireResolveHeaderDependency( /** @type {Range} */expr.callee.range);\n        dep.loc = /** @type {DependencyLocation} */expr.loc;\n        parser.state.module.addPresentationalDependency(dep);\n        return true;\n      }\n    };\n    /**\n     * @param {CallExpression} expr call expression\n     * @param {BasicEvaluatedExpression} param param\n     * @param {boolean} weak weak\n     * @returns {boolean | void} true when handled\n     */\n    const processResolveItem = (expr, param, weak) => {\n      if (param.isString()) {\n        const dep = new RequireResolveDependency( /** @type {string} */param.string, /** @type {Range} */param.range, getContext());\n        dep.loc = /** @type {DependencyLocation} */expr.loc;\n        dep.optional = !!parser.scope.inTry;\n        dep.weak = weak;\n        parser.state.current.addDependency(dep);\n        return true;\n      }\n    };\n    /**\n     * @param {CallExpression} expr call expression\n     * @param {BasicEvaluatedExpression} param param\n     * @param {boolean} weak weak\n     * @returns {boolean | void} true when handled\n     */\n    const processResolveContext = (expr, param, weak) => {\n      const dep = ContextDependencyHelpers.create(RequireResolveContextDependency, /** @type {Range} */param.range, param, expr, options, {\n        category: \"commonjs\",\n        mode: weak ? \"weak\" : \"sync\"\n      }, parser, getContext());\n      if (!dep) return;\n      dep.loc = /** @type {DependencyLocation} */expr.loc;\n      dep.optional = !!parser.scope.inTry;\n      parser.state.current.addDependency(dep);\n      return true;\n    };\n    parser.hooks.call.for(\"require.resolve\").tap(\"CommonJsImportsParserPlugin\", expr => {\n      return processResolve(expr, false);\n    });\n    parser.hooks.call.for(\"require.resolveWeak\").tap(\"CommonJsImportsParserPlugin\", expr => {\n      return processResolve(expr, true);\n    });\n    //#endregion\n\n    //#region Create require\n\n    if (!options.createRequire) return;\n\n    /** @type {ImportSource[]} */\n    let moduleName = [];\n    /** @type {string | undefined} */\n    let specifierName;\n    if (options.createRequire === true) {\n      moduleName = [\"module\", \"node:module\"];\n      specifierName = \"createRequire\";\n    } else {\n      let moduleName;\n      const match = /^(.*) from (.*)$/.exec(options.createRequire);\n      if (match) {\n        [, specifierName, moduleName] = match;\n      }\n      if (!specifierName || !moduleName) {\n        const err = new WebpackError(`Parsing javascript parser option \"createRequire\" failed, got ${JSON.stringify(options.createRequire)}`);\n        err.details = 'Expected string in format \"createRequire from module\", where \"createRequire\" is specifier name and \"module\" name of the module';\n        throw err;\n      }\n    }\n    tapRequireExpressionTag(createdRequireIdentifierTag);\n    tapRequireExpressionTag(createRequireSpecifierTag);\n    parser.hooks.evaluateCallExpression.for(createRequireSpecifierTag).tap(\"CommonJsImportsParserPlugin\", expr => {\n      const context = parseCreateRequireArguments(expr);\n      if (context === undefined) return;\n      const ident = parser.evaluatedVariable({\n        tag: createdRequireIdentifierTag,\n        data: {\n          context\n        },\n        next: undefined\n      });\n      return new BasicEvaluatedExpression().setIdentifier( /** @type {TODO} */ident, /** @type {TODO} */ident, () => []).setSideEffects(false).setRange( /** @type {Range} */expr.range);\n    });\n    parser.hooks.unhandledExpressionMemberChain.for(createdRequireIdentifierTag).tap(\"CommonJsImportsParserPlugin\", (expr, members) => {\n      return expressionIsUnsupported(parser, `createRequire().${members.join(\".\")} is not supported by webpack.`)(expr);\n    });\n    parser.hooks.canRename.for(createdRequireIdentifierTag).tap(\"CommonJsImportsParserPlugin\", () => true);\n    parser.hooks.canRename.for(createRequireSpecifierTag).tap(\"CommonJsImportsParserPlugin\", () => true);\n    parser.hooks.rename.for(createRequireSpecifierTag).tap(\"CommonJsImportsParserPlugin\", defineUndefined);\n    parser.hooks.expression.for(createdRequireIdentifierTag).tap(\"CommonJsImportsParserPlugin\", requireAsExpressionHandler);\n    parser.hooks.call.for(createdRequireIdentifierTag).tap(\"CommonJsImportsParserPlugin\", createRequireHandler(false));\n    /**\n     * @param {CallExpression} expr call expression\n     * @returns {string | void} context\n     */\n    const parseCreateRequireArguments = expr => {\n      const args = expr.arguments;\n      if (args.length !== 1) {\n        const err = new WebpackError(\"module.createRequire supports only one argument.\");\n        err.loc = /** @type {DependencyLocation} */expr.loc;\n        parser.state.module.addWarning(err);\n        return;\n      }\n      const arg = args[0];\n      const evaluated = parser.evaluateExpression(arg);\n      if (!evaluated.isString()) {\n        const err = new WebpackError(\"module.createRequire failed parsing argument.\");\n        err.loc = /** @type {DependencyLocation} */arg.loc;\n        parser.state.module.addWarning(err);\n        return;\n      }\n      const ctx = /** @type {string} */evaluated.string.startsWith(\"file://\") ? fileURLToPath( /** @type {string} */evaluated.string) : ( /** @type {string} */evaluated.string);\n      // argument always should be a filename\n      return ctx.slice(0, ctx.lastIndexOf(ctx.startsWith(\"/\") ? \"/\" : \"\\\\\"));\n    };\n    parser.hooks.import.tap({\n      name: \"CommonJsImportsParserPlugin\",\n      stage: -10\n    }, (statement, source) => {\n      if (!moduleName.includes(source) || statement.specifiers.length !== 1 || statement.specifiers[0].type !== \"ImportSpecifier\" || statement.specifiers[0].imported.type !== \"Identifier\" || statement.specifiers[0].imported.name !== specifierName) return;\n      // clear for 'import { createRequire as x } from \"module\"'\n      // if any other specifier was used import module\n      const clearDep = new ConstDependency(parser.isAsiPosition( /** @type {Range} */statement.range[0]) ? \";\" : \"\", /** @type {Range} */statement.range);\n      clearDep.loc = /** @type {DependencyLocation} */statement.loc;\n      parser.state.module.addPresentationalDependency(clearDep);\n      parser.unsetAsiPosition( /** @type {Range} */statement.range[1]);\n      return true;\n    });\n    parser.hooks.importSpecifier.tap({\n      name: \"CommonJsImportsParserPlugin\",\n      stage: -10\n    }, (statement, source, id, name) => {\n      if (!moduleName.includes(source) || id !== specifierName) return;\n      parser.tagVariable(name, createRequireSpecifierTag);\n      return true;\n    });\n    parser.hooks.preDeclarator.tap(\"CommonJsImportsParserPlugin\", declarator => {\n      if (declarator.id.type !== \"Identifier\" || !declarator.init || declarator.init.type !== \"CallExpression\" || declarator.init.callee.type !== \"Identifier\") return;\n      const variableInfo = /** @type {TODO} */\n      parser.getVariableInfo(declarator.init.callee.name);\n      if (variableInfo && variableInfo.tagInfo && variableInfo.tagInfo.tag === createRequireSpecifierTag) {\n        const context = parseCreateRequireArguments(declarator.init);\n        if (context === undefined) return;\n        parser.tagVariable(declarator.id.name, createdRequireIdentifierTag, {\n          name: declarator.id.name,\n          context\n        });\n        return true;\n      }\n    });\n    parser.hooks.memberChainOfCallMemberChain.for(createRequireSpecifierTag).tap(\"CommonJsImportsParserPlugin\", (expr, calleeMembers, callExpr, members) => {\n      if (calleeMembers.length !== 0 || members.length !== 1 || members[0] !== \"cache\") return;\n      // createRequire().cache\n      const context = parseCreateRequireArguments(callExpr);\n      if (context === undefined) return;\n      return requireCache(expr);\n    });\n    parser.hooks.callMemberChainOfCallMemberChain.for(createRequireSpecifierTag).tap(\"CommonJsImportsParserPlugin\", (expr, calleeMembers, innerCallExpression, members) => {\n      if (calleeMembers.length !== 0 || members.length !== 1 || members[0] !== \"resolve\") return;\n      // createRequire().resolve()\n      return processResolve(expr, false);\n    });\n    parser.hooks.expressionMemberChain.for(createdRequireIdentifierTag).tap(\"CommonJsImportsParserPlugin\", (expr, members) => {\n      // require.cache\n      if (members.length === 1 && members[0] === \"cache\") {\n        return requireCache(expr);\n      }\n    });\n    parser.hooks.callMemberChain.for(createdRequireIdentifierTag).tap(\"CommonJsImportsParserPlugin\", (expr, members) => {\n      // require.resolve()\n      if (members.length === 1 && members[0] === \"resolve\") {\n        return processResolve(expr, false);\n      }\n    });\n    parser.hooks.call.for(createRequireSpecifierTag).tap(\"CommonJsImportsParserPlugin\", expr => {\n      const clearDep = new ConstDependency(\"/* createRequire() */ undefined\", /** @type {Range} */expr.range);\n      clearDep.loc = /** @type {DependencyLocation} */expr.loc;\n      parser.state.module.addPresentationalDependency(clearDep);\n      return true;\n    });\n    //#endregion\n  }\n}\nmodule.exports = CommonJsImportsParserPlugin;","map":{"version":3,"names":["fileURLToPath","require","CommentCompilationWarning","RuntimeGlobals","UnsupportedFeatureWarning","WebpackError","BasicEvaluatedExpression","evaluateToIdentifier","evaluateToString","expressionIsUnsupported","toConstantDependency","CommonJsFullRequireDependency","CommonJsRequireContextDependency","CommonJsRequireDependency","ConstDependency","ContextDependencyHelpers","LocalModuleDependency","getLocalModule","RequireHeaderDependency","RequireResolveContextDependency","RequireResolveDependency","RequireResolveHeaderDependency","createRequireSpecifierTag","Symbol","createdRequireIdentifierTag","CommonJsImportsParserPlugin","constructor","options","apply","parser","getContext","currentTagData","context","tapRequireExpression","expression","getMembers","hooks","typeof","for","tap","JSON","stringify","evaluateTypeof","evaluateIdentifier","tapRequireExpressionTag","tag","assign","expr","dep","loc","state","module","addPresentationalDependency","call","defineUndefined","range","canRename","rename","requireCache","moduleCache","moduleId","moduleLoaded","requireAsExpressionHandler","request","unknownContextRequest","recursive","unknownContextRecursive","regExp","unknownContextRegExp","mode","undefined","scope","inShorthand","critical","unknownContextCritical","optional","inTry","current","addDependency","processRequireItem","param","isString","string","processRequireContext","create","category","createRequireHandler","callNew","commonjsMagicComments","requireOptions","errors","commentErrors","parseCommentOptions","e","comment","addWarning","value","message","webpackIgnore","arguments","length","localModule","evaluateExpression","isConditional","isExpression","p","result","callee","flagUsed","new","chainHandler","calleeMembers","callExpr","members","memberRanges","asiSafe","isAsiPosition","callChainHandler","walkExpressions","memberChainOfCallMemberChain","callMemberChainOfCallMemberChain","processResolve","weak","option","processResolveItem","processResolveContext","createRequire","moduleName","specifierName","match","exec","err","details","evaluateCallExpression","parseCreateRequireArguments","ident","evaluatedVariable","data","next","setIdentifier","setSideEffects","setRange","unhandledExpressionMemberChain","join","args","arg","evaluated","ctx","startsWith","slice","lastIndexOf","import","name","stage","statement","source","includes","specifiers","type","imported","clearDep","unsetAsiPosition","importSpecifier","id","tagVariable","preDeclarator","declarator","init","variableInfo","getVariableInfo","tagInfo","innerCallExpression","expressionMemberChain","callMemberChain","exports"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/dependencies/CommonJsImportsParserPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { fileURLToPath } = require(\"url\");\nconst CommentCompilationWarning = require(\"../CommentCompilationWarning\");\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst UnsupportedFeatureWarning = require(\"../UnsupportedFeatureWarning\");\nconst WebpackError = require(\"../WebpackError\");\nconst BasicEvaluatedExpression = require(\"../javascript/BasicEvaluatedExpression\");\nconst {\n\tevaluateToIdentifier,\n\tevaluateToString,\n\texpressionIsUnsupported,\n\ttoConstantDependency\n} = require(\"../javascript/JavascriptParserHelpers\");\nconst CommonJsFullRequireDependency = require(\"./CommonJsFullRequireDependency\");\nconst CommonJsRequireContextDependency = require(\"./CommonJsRequireContextDependency\");\nconst CommonJsRequireDependency = require(\"./CommonJsRequireDependency\");\nconst ConstDependency = require(\"./ConstDependency\");\nconst ContextDependencyHelpers = require(\"./ContextDependencyHelpers\");\nconst LocalModuleDependency = require(\"./LocalModuleDependency\");\nconst { getLocalModule } = require(\"./LocalModulesHelpers\");\nconst RequireHeaderDependency = require(\"./RequireHeaderDependency\");\nconst RequireResolveContextDependency = require(\"./RequireResolveContextDependency\");\nconst RequireResolveDependency = require(\"./RequireResolveDependency\");\nconst RequireResolveHeaderDependency = require(\"./RequireResolveHeaderDependency\");\n\n/** @typedef {import(\"estree\").CallExpression} CallExpression */\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"estree\").NewExpression} NewExpression */\n/** @typedef {import(\"../../declarations/WebpackOptions\").JavascriptParserOptions} JavascriptParserOptions */\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../javascript/JavascriptParser\").ImportSource} ImportSource */\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n\nconst createRequireSpecifierTag = Symbol(\"createRequire\");\nconst createdRequireIdentifierTag = Symbol(\"createRequire()\");\n\nclass CommonJsImportsParserPlugin {\n\t/**\n\t * @param {JavascriptParserOptions} options parser options\n\t */\n\tconstructor(options) {\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * @param {JavascriptParser} parser the parser\n\t * @returns {void}\n\t */\n\tapply(parser) {\n\t\tconst options = this.options;\n\n\t\tconst getContext = () => {\n\t\t\tif (parser.currentTagData) {\n\t\t\t\tconst { context } = parser.currentTagData;\n\t\t\t\treturn context;\n\t\t\t}\n\t\t};\n\n\t\t//#region metadata\n\t\t/**\n\t\t * @param {string} expression expression\n\t\t * @param {() => string[]} getMembers get members\n\t\t */\n\t\tconst tapRequireExpression = (expression, getMembers) => {\n\t\t\tparser.hooks.typeof\n\t\t\t\t.for(expression)\n\t\t\t\t.tap(\n\t\t\t\t\t\"CommonJsImportsParserPlugin\",\n\t\t\t\t\ttoConstantDependency(parser, JSON.stringify(\"function\"))\n\t\t\t\t);\n\t\t\tparser.hooks.evaluateTypeof\n\t\t\t\t.for(expression)\n\t\t\t\t.tap(\"CommonJsImportsParserPlugin\", evaluateToString(\"function\"));\n\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t.for(expression)\n\t\t\t\t.tap(\n\t\t\t\t\t\"CommonJsImportsParserPlugin\",\n\t\t\t\t\tevaluateToIdentifier(expression, \"require\", getMembers, true)\n\t\t\t\t);\n\t\t};\n\t\t/**\n\t\t * @param {string | symbol} tag tag\n\t\t */\n\t\tconst tapRequireExpressionTag = tag => {\n\t\t\tparser.hooks.typeof\n\t\t\t\t.for(tag)\n\t\t\t\t.tap(\n\t\t\t\t\t\"CommonJsImportsParserPlugin\",\n\t\t\t\t\ttoConstantDependency(parser, JSON.stringify(\"function\"))\n\t\t\t\t);\n\t\t\tparser.hooks.evaluateTypeof\n\t\t\t\t.for(tag)\n\t\t\t\t.tap(\"CommonJsImportsParserPlugin\", evaluateToString(\"function\"));\n\t\t};\n\t\ttapRequireExpression(\"require\", () => []);\n\t\ttapRequireExpression(\"require.resolve\", () => [\"resolve\"]);\n\t\ttapRequireExpression(\"require.resolveWeak\", () => [\"resolveWeak\"]);\n\t\t//#endregion\n\n\t\t// Weird stuff //\n\t\tparser.hooks.assign\n\t\t\t.for(\"require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", expr => {\n\t\t\t\t// to not leak to global \"require\", we need to define a local require here.\n\t\t\t\tconst dep = new ConstDependency(\"var require;\", 0);\n\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\treturn true;\n\t\t\t});\n\n\t\t//#region Unsupported\n\t\tparser.hooks.expression\n\t\t\t.for(\"require.main\")\n\t\t\t.tap(\n\t\t\t\t\"CommonJsImportsParserPlugin\",\n\t\t\t\texpressionIsUnsupported(\n\t\t\t\t\tparser,\n\t\t\t\t\t\"require.main is not supported by webpack.\"\n\t\t\t\t)\n\t\t\t);\n\t\tparser.hooks.call\n\t\t\t.for(\"require.main.require\")\n\t\t\t.tap(\n\t\t\t\t\"CommonJsImportsParserPlugin\",\n\t\t\t\texpressionIsUnsupported(\n\t\t\t\t\tparser,\n\t\t\t\t\t\"require.main.require is not supported by webpack.\"\n\t\t\t\t)\n\t\t\t);\n\t\tparser.hooks.expression\n\t\t\t.for(\"module.parent.require\")\n\t\t\t.tap(\n\t\t\t\t\"CommonJsImportsParserPlugin\",\n\t\t\t\texpressionIsUnsupported(\n\t\t\t\t\tparser,\n\t\t\t\t\t\"module.parent.require is not supported by webpack.\"\n\t\t\t\t)\n\t\t\t);\n\t\tparser.hooks.call\n\t\t\t.for(\"module.parent.require\")\n\t\t\t.tap(\n\t\t\t\t\"CommonJsImportsParserPlugin\",\n\t\t\t\texpressionIsUnsupported(\n\t\t\t\t\tparser,\n\t\t\t\t\t\"module.parent.require is not supported by webpack.\"\n\t\t\t\t)\n\t\t\t);\n\t\t//#endregion\n\n\t\t//#region Renaming\n\t\t/**\n\t\t * @param {Expression} expr expression\n\t\t * @returns {boolean} true when set undefined\n\t\t */\n\t\tconst defineUndefined = expr => {\n\t\t\t// To avoid \"not defined\" error, replace the value with undefined\n\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\"undefined\",\n\t\t\t\t/** @type {Range} */ (expr.range)\n\t\t\t);\n\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\treturn false;\n\t\t};\n\t\tparser.hooks.canRename\n\t\t\t.for(\"require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", () => true);\n\t\tparser.hooks.rename\n\t\t\t.for(\"require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", defineUndefined);\n\t\t//#endregion\n\n\t\t//#region Inspection\n\t\tconst requireCache = toConstantDependency(\n\t\t\tparser,\n\t\t\tRuntimeGlobals.moduleCache,\n\t\t\t[\n\t\t\t\tRuntimeGlobals.moduleCache,\n\t\t\t\tRuntimeGlobals.moduleId,\n\t\t\t\tRuntimeGlobals.moduleLoaded\n\t\t\t]\n\t\t);\n\n\t\tparser.hooks.expression\n\t\t\t.for(\"require.cache\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", requireCache);\n\t\t//#endregion\n\n\t\t//#region Require as expression\n\t\t/**\n\t\t * @param {Expression} expr expression\n\t\t * @returns {boolean} true when handled\n\t\t */\n\t\tconst requireAsExpressionHandler = expr => {\n\t\t\tconst dep = new CommonJsRequireContextDependency(\n\t\t\t\t{\n\t\t\t\t\trequest: options.unknownContextRequest,\n\t\t\t\t\trecursive: options.unknownContextRecursive,\n\t\t\t\t\tregExp: options.unknownContextRegExp,\n\t\t\t\t\tmode: \"sync\"\n\t\t\t\t},\n\t\t\t\t/** @type {Range} */ (expr.range),\n\t\t\t\tundefined,\n\t\t\t\tparser.scope.inShorthand,\n\t\t\t\tgetContext()\n\t\t\t);\n\t\t\tdep.critical =\n\t\t\t\toptions.unknownContextCritical &&\n\t\t\t\t\"require function is used in a way in which dependencies cannot be statically extracted\";\n\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\tparser.state.current.addDependency(dep);\n\t\t\treturn true;\n\t\t};\n\t\tparser.hooks.expression\n\t\t\t.for(\"require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", requireAsExpressionHandler);\n\t\t//#endregion\n\n\t\t//#region Require\n\t\t/**\n\t\t * @param {CallExpression | NewExpression} expr expression\n\t\t * @param {BasicEvaluatedExpression} param param\n\t\t * @returns {boolean | void} true when handled\n\t\t */\n\t\tconst processRequireItem = (expr, param) => {\n\t\t\tif (param.isString()) {\n\t\t\t\tconst dep = new CommonJsRequireDependency(\n\t\t\t\t\t/** @type {string} */ (param.string),\n\t\t\t\t\t/** @type {Range} */ (param.range),\n\t\t\t\t\tgetContext()\n\t\t\t\t);\n\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {CallExpression | NewExpression} expr expression\n\t\t * @param {BasicEvaluatedExpression} param param\n\t\t * @returns {boolean | void} true when handled\n\t\t */\n\t\tconst processRequireContext = (expr, param) => {\n\t\t\tconst dep = ContextDependencyHelpers.create(\n\t\t\t\tCommonJsRequireContextDependency,\n\t\t\t\t/** @type {Range} */ (expr.range),\n\t\t\t\tparam,\n\t\t\t\texpr,\n\t\t\t\toptions,\n\t\t\t\t{\n\t\t\t\t\tcategory: \"commonjs\"\n\t\t\t\t},\n\t\t\t\tparser,\n\t\t\t\tundefined,\n\t\t\t\tgetContext()\n\t\t\t);\n\t\t\tif (!dep) return;\n\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\tparser.state.current.addDependency(dep);\n\t\t\treturn true;\n\t\t};\n\t\t/**\n\t\t * @param {boolean} callNew true, when require is called with new\n\t\t * @returns {(expr: CallExpression | NewExpression) => (boolean | void)} handler\n\t\t */\n\t\tconst createRequireHandler = callNew => expr => {\n\t\t\tif (options.commonjsMagicComments) {\n\t\t\t\tconst { options: requireOptions, errors: commentErrors } =\n\t\t\t\t\tparser.parseCommentOptions(/** @type {Range} */ (expr.range));\n\n\t\t\t\tif (commentErrors) {\n\t\t\t\t\tfor (const e of commentErrors) {\n\t\t\t\t\t\tconst { comment } = e;\n\t\t\t\t\t\tparser.state.module.addWarning(\n\t\t\t\t\t\t\tnew CommentCompilationWarning(\n\t\t\t\t\t\t\t\t`Compilation error while processing magic comment(-s): /*${comment.value}*/: ${e.message}`,\n\t\t\t\t\t\t\t\tcomment.loc\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (requireOptions) {\n\t\t\t\t\tif (requireOptions.webpackIgnore !== undefined) {\n\t\t\t\t\t\tif (typeof requireOptions.webpackIgnore !== \"boolean\") {\n\t\t\t\t\t\t\tparser.state.module.addWarning(\n\t\t\t\t\t\t\t\tnew UnsupportedFeatureWarning(\n\t\t\t\t\t\t\t\t\t`\\`webpackIgnore\\` expected a boolean, but received: ${requireOptions.webpackIgnore}.`,\n\t\t\t\t\t\t\t\t\t/** @type {DependencyLocation} */ (expr.loc)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Do not instrument `require()` if `webpackIgnore` is `true`\n\t\t\t\t\t\t\tif (requireOptions.webpackIgnore) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (expr.arguments.length !== 1) return;\n\t\t\tlet localModule;\n\t\t\tconst param = parser.evaluateExpression(expr.arguments[0]);\n\t\t\tif (param.isConditional()) {\n\t\t\t\tlet isExpression = false;\n\t\t\t\tfor (const p of /** @type {BasicEvaluatedExpression[]} */ (\n\t\t\t\t\tparam.options\n\t\t\t\t)) {\n\t\t\t\t\tconst result = processRequireItem(expr, p);\n\t\t\t\t\tif (result === undefined) {\n\t\t\t\t\t\tisExpression = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isExpression) {\n\t\t\t\t\tconst dep = new RequireHeaderDependency(\n\t\t\t\t\t\t/** @type {Range} */ (expr.callee.range)\n\t\t\t\t\t);\n\t\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (\n\t\t\t\tparam.isString() &&\n\t\t\t\t(localModule = getLocalModule(\n\t\t\t\t\tparser.state,\n\t\t\t\t\t/** @type {string} */ (param.string)\n\t\t\t\t))\n\t\t\t) {\n\t\t\t\tlocalModule.flagUsed();\n\t\t\t\tconst dep = new LocalModuleDependency(\n\t\t\t\t\tlocalModule,\n\t\t\t\t\t/** @type {Range} */ (expr.range),\n\t\t\t\t\tcallNew\n\t\t\t\t);\n\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t} else {\n\t\t\t\tconst result = processRequireItem(expr, param);\n\t\t\t\tif (result === undefined) {\n\t\t\t\t\tprocessRequireContext(expr, param);\n\t\t\t\t} else {\n\t\t\t\t\tconst dep = new RequireHeaderDependency(\n\t\t\t\t\t\t/** @type {Range} */ (expr.callee.range)\n\t\t\t\t\t);\n\t\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\tparser.hooks.call\n\t\t\t.for(\"require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", createRequireHandler(false));\n\t\tparser.hooks.new\n\t\t\t.for(\"require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", createRequireHandler(true));\n\t\tparser.hooks.call\n\t\t\t.for(\"module.require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", createRequireHandler(false));\n\t\tparser.hooks.new\n\t\t\t.for(\"module.require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", createRequireHandler(true));\n\t\t//#endregion\n\n\t\t//#region Require with property access\n\t\t/**\n\t\t * @param {Expression} expr expression\n\t\t * @param {string[]} calleeMembers callee members\n\t\t * @param {CallExpression} callExpr call expression\n\t\t * @param {string[]} members members\n\t\t * @param {Range[]} memberRanges member ranges\n\t\t * @returns {boolean | void} true when handled\n\t\t */\n\t\tconst chainHandler = (\n\t\t\texpr,\n\t\t\tcalleeMembers,\n\t\t\tcallExpr,\n\t\t\tmembers,\n\t\t\tmemberRanges\n\t\t) => {\n\t\t\tif (callExpr.arguments.length !== 1) return;\n\t\t\tconst param = parser.evaluateExpression(callExpr.arguments[0]);\n\t\t\tif (\n\t\t\t\tparam.isString() &&\n\t\t\t\t!getLocalModule(parser.state, /** @type {string} */ (param.string))\n\t\t\t) {\n\t\t\t\tconst dep = new CommonJsFullRequireDependency(\n\t\t\t\t\t/** @type {string} */ (param.string),\n\t\t\t\t\t/** @type {Range} */ (expr.range),\n\t\t\t\t\tmembers,\n\t\t\t\t\t/** @type {Range[]} */ memberRanges\n\t\t\t\t);\n\t\t\t\tdep.asiSafe = !parser.isAsiPosition(\n\t\t\t\t\t/** @type {Range} */ (expr.range)[0]\n\t\t\t\t);\n\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {CallExpression} expr expression\n\t\t * @param {string[]} calleeMembers callee members\n\t\t * @param {CallExpression} callExpr call expression\n\t\t * @param {string[]} members members\n\t\t * @param {Range[]} memberRanges member ranges\n\t\t * @returns {boolean | void} true when handled\n\t\t */\n\t\tconst callChainHandler = (\n\t\t\texpr,\n\t\t\tcalleeMembers,\n\t\t\tcallExpr,\n\t\t\tmembers,\n\t\t\tmemberRanges\n\t\t) => {\n\t\t\tif (callExpr.arguments.length !== 1) return;\n\t\t\tconst param = parser.evaluateExpression(callExpr.arguments[0]);\n\t\t\tif (\n\t\t\t\tparam.isString() &&\n\t\t\t\t!getLocalModule(parser.state, /** @type {string} */ (param.string))\n\t\t\t) {\n\t\t\t\tconst dep = new CommonJsFullRequireDependency(\n\t\t\t\t\t/** @type {string} */ (param.string),\n\t\t\t\t\t/** @type {Range} */ (expr.callee.range),\n\t\t\t\t\tmembers,\n\t\t\t\t\t/** @type {Range[]} */ memberRanges\n\t\t\t\t);\n\t\t\t\tdep.call = true;\n\t\t\t\tdep.asiSafe = !parser.isAsiPosition(\n\t\t\t\t\t/** @type {Range} */ (expr.range)[0]\n\t\t\t\t);\n\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.callee.loc);\n\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\tparser.walkExpressions(expr.arguments);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\tparser.hooks.memberChainOfCallMemberChain\n\t\t\t.for(\"require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", chainHandler);\n\t\tparser.hooks.memberChainOfCallMemberChain\n\t\t\t.for(\"module.require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", chainHandler);\n\t\tparser.hooks.callMemberChainOfCallMemberChain\n\t\t\t.for(\"require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", callChainHandler);\n\t\tparser.hooks.callMemberChainOfCallMemberChain\n\t\t\t.for(\"module.require\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", callChainHandler);\n\t\t//#endregion\n\n\t\t//#region Require.resolve\n\t\t/**\n\t\t * @param {CallExpression} expr call expression\n\t\t * @param {boolean} weak weak\n\t\t * @returns {boolean | void} true when handled\n\t\t */\n\t\tconst processResolve = (expr, weak) => {\n\t\t\tif (expr.arguments.length !== 1) return;\n\t\t\tconst param = parser.evaluateExpression(expr.arguments[0]);\n\t\t\tif (param.isConditional()) {\n\t\t\t\tfor (const option of /** @type {BasicEvaluatedExpression[]} */ (\n\t\t\t\t\tparam.options\n\t\t\t\t)) {\n\t\t\t\t\tconst result = processResolveItem(expr, option, weak);\n\t\t\t\t\tif (result === undefined) {\n\t\t\t\t\t\tprocessResolveContext(expr, option, weak);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst dep = new RequireResolveHeaderDependency(\n\t\t\t\t\t/** @type {Range} */ (expr.callee.range)\n\t\t\t\t);\n\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tconst result = processResolveItem(expr, param, weak);\n\t\t\t\tif (result === undefined) {\n\t\t\t\t\tprocessResolveContext(expr, param, weak);\n\t\t\t\t}\n\t\t\t\tconst dep = new RequireResolveHeaderDependency(\n\t\t\t\t\t/** @type {Range} */ (expr.callee.range)\n\t\t\t\t);\n\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {CallExpression} expr call expression\n\t\t * @param {BasicEvaluatedExpression} param param\n\t\t * @param {boolean} weak weak\n\t\t * @returns {boolean | void} true when handled\n\t\t */\n\t\tconst processResolveItem = (expr, param, weak) => {\n\t\t\tif (param.isString()) {\n\t\t\t\tconst dep = new RequireResolveDependency(\n\t\t\t\t\t/** @type {string} */ (param.string),\n\t\t\t\t\t/** @type {Range} */ (param.range),\n\t\t\t\t\tgetContext()\n\t\t\t\t);\n\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\tdep.weak = weak;\n\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {CallExpression} expr call expression\n\t\t * @param {BasicEvaluatedExpression} param param\n\t\t * @param {boolean} weak weak\n\t\t * @returns {boolean | void} true when handled\n\t\t */\n\t\tconst processResolveContext = (expr, param, weak) => {\n\t\t\tconst dep = ContextDependencyHelpers.create(\n\t\t\t\tRequireResolveContextDependency,\n\t\t\t\t/** @type {Range} */ (param.range),\n\t\t\t\tparam,\n\t\t\t\texpr,\n\t\t\t\toptions,\n\t\t\t\t{\n\t\t\t\t\tcategory: \"commonjs\",\n\t\t\t\t\tmode: weak ? \"weak\" : \"sync\"\n\t\t\t\t},\n\t\t\t\tparser,\n\t\t\t\tgetContext()\n\t\t\t);\n\t\t\tif (!dep) return;\n\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\tparser.state.current.addDependency(dep);\n\t\t\treturn true;\n\t\t};\n\n\t\tparser.hooks.call\n\t\t\t.for(\"require.resolve\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", expr => {\n\t\t\t\treturn processResolve(expr, false);\n\t\t\t});\n\t\tparser.hooks.call\n\t\t\t.for(\"require.resolveWeak\")\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", expr => {\n\t\t\t\treturn processResolve(expr, true);\n\t\t\t});\n\t\t//#endregion\n\n\t\t//#region Create require\n\n\t\tif (!options.createRequire) return;\n\n\t\t/** @type {ImportSource[]} */\n\t\tlet moduleName = [];\n\t\t/** @type {string | undefined} */\n\t\tlet specifierName;\n\n\t\tif (options.createRequire === true) {\n\t\t\tmoduleName = [\"module\", \"node:module\"];\n\t\t\tspecifierName = \"createRequire\";\n\t\t} else {\n\t\t\tlet moduleName;\n\t\t\tconst match = /^(.*) from (.*)$/.exec(options.createRequire);\n\t\t\tif (match) {\n\t\t\t\t[, specifierName, moduleName] = match;\n\t\t\t}\n\t\t\tif (!specifierName || !moduleName) {\n\t\t\t\tconst err = new WebpackError(\n\t\t\t\t\t`Parsing javascript parser option \"createRequire\" failed, got ${JSON.stringify(\n\t\t\t\t\t\toptions.createRequire\n\t\t\t\t\t)}`\n\t\t\t\t);\n\t\t\t\terr.details =\n\t\t\t\t\t'Expected string in format \"createRequire from module\", where \"createRequire\" is specifier name and \"module\" name of the module';\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\n\t\ttapRequireExpressionTag(createdRequireIdentifierTag);\n\t\ttapRequireExpressionTag(createRequireSpecifierTag);\n\t\tparser.hooks.evaluateCallExpression\n\t\t\t.for(createRequireSpecifierTag)\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", expr => {\n\t\t\t\tconst context = parseCreateRequireArguments(expr);\n\t\t\t\tif (context === undefined) return;\n\t\t\t\tconst ident = parser.evaluatedVariable({\n\t\t\t\t\ttag: createdRequireIdentifierTag,\n\t\t\t\t\tdata: { context },\n\t\t\t\t\tnext: undefined\n\t\t\t\t});\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setIdentifier(\n\t\t\t\t\t\t/** @type {TODO} */ (ident),\n\t\t\t\t\t\t/** @type {TODO} */ (ident),\n\t\t\t\t\t\t() => []\n\t\t\t\t\t)\n\t\t\t\t\t.setSideEffects(false)\n\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t});\n\t\tparser.hooks.unhandledExpressionMemberChain\n\t\t\t.for(createdRequireIdentifierTag)\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", (expr, members) => {\n\t\t\t\treturn expressionIsUnsupported(\n\t\t\t\t\tparser,\n\t\t\t\t\t`createRequire().${members.join(\".\")} is not supported by webpack.`\n\t\t\t\t)(expr);\n\t\t\t});\n\t\tparser.hooks.canRename\n\t\t\t.for(createdRequireIdentifierTag)\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", () => true);\n\t\tparser.hooks.canRename\n\t\t\t.for(createRequireSpecifierTag)\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", () => true);\n\t\tparser.hooks.rename\n\t\t\t.for(createRequireSpecifierTag)\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", defineUndefined);\n\t\tparser.hooks.expression\n\t\t\t.for(createdRequireIdentifierTag)\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", requireAsExpressionHandler);\n\t\tparser.hooks.call\n\t\t\t.for(createdRequireIdentifierTag)\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", createRequireHandler(false));\n\t\t/**\n\t\t * @param {CallExpression} expr call expression\n\t\t * @returns {string | void} context\n\t\t */\n\t\tconst parseCreateRequireArguments = expr => {\n\t\t\tconst args = expr.arguments;\n\t\t\tif (args.length !== 1) {\n\t\t\t\tconst err = new WebpackError(\n\t\t\t\t\t\"module.createRequire supports only one argument.\"\n\t\t\t\t);\n\t\t\t\terr.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\tparser.state.module.addWarning(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst arg = args[0];\n\t\t\tconst evaluated = parser.evaluateExpression(arg);\n\t\t\tif (!evaluated.isString()) {\n\t\t\t\tconst err = new WebpackError(\n\t\t\t\t\t\"module.createRequire failed parsing argument.\"\n\t\t\t\t);\n\t\t\t\terr.loc = /** @type {DependencyLocation} */ (arg.loc);\n\t\t\t\tparser.state.module.addWarning(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst ctx = /** @type {string} */ (evaluated.string).startsWith(\"file://\")\n\t\t\t\t? fileURLToPath(/** @type {string} */ (evaluated.string))\n\t\t\t\t: /** @type {string} */ (evaluated.string);\n\t\t\t// argument always should be a filename\n\t\t\treturn ctx.slice(0, ctx.lastIndexOf(ctx.startsWith(\"/\") ? \"/\" : \"\\\\\"));\n\t\t};\n\n\t\tparser.hooks.import.tap(\n\t\t\t{\n\t\t\t\tname: \"CommonJsImportsParserPlugin\",\n\t\t\t\tstage: -10\n\t\t\t},\n\t\t\t(statement, source) => {\n\t\t\t\tif (\n\t\t\t\t\t!moduleName.includes(source) ||\n\t\t\t\t\tstatement.specifiers.length !== 1 ||\n\t\t\t\t\tstatement.specifiers[0].type !== \"ImportSpecifier\" ||\n\t\t\t\t\tstatement.specifiers[0].imported.type !== \"Identifier\" ||\n\t\t\t\t\tstatement.specifiers[0].imported.name !== specifierName\n\t\t\t\t)\n\t\t\t\t\treturn;\n\t\t\t\t// clear for 'import { createRequire as x } from \"module\"'\n\t\t\t\t// if any other specifier was used import module\n\t\t\t\tconst clearDep = new ConstDependency(\n\t\t\t\t\tparser.isAsiPosition(/** @type {Range} */ (statement.range)[0])\n\t\t\t\t\t\t? \";\"\n\t\t\t\t\t\t: \"\",\n\t\t\t\t\t/** @type {Range} */ (statement.range)\n\t\t\t\t);\n\t\t\t\tclearDep.loc = /** @type {DependencyLocation} */ (statement.loc);\n\t\t\t\tparser.state.module.addPresentationalDependency(clearDep);\n\t\t\t\tparser.unsetAsiPosition(/** @type {Range} */ (statement.range)[1]);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t);\n\t\tparser.hooks.importSpecifier.tap(\n\t\t\t{\n\t\t\t\tname: \"CommonJsImportsParserPlugin\",\n\t\t\t\tstage: -10\n\t\t\t},\n\t\t\t(statement, source, id, name) => {\n\t\t\t\tif (!moduleName.includes(source) || id !== specifierName) return;\n\t\t\t\tparser.tagVariable(name, createRequireSpecifierTag);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t);\n\t\tparser.hooks.preDeclarator.tap(\n\t\t\t\"CommonJsImportsParserPlugin\",\n\t\t\tdeclarator => {\n\t\t\t\tif (\n\t\t\t\t\tdeclarator.id.type !== \"Identifier\" ||\n\t\t\t\t\t!declarator.init ||\n\t\t\t\t\tdeclarator.init.type !== \"CallExpression\" ||\n\t\t\t\t\tdeclarator.init.callee.type !== \"Identifier\"\n\t\t\t\t)\n\t\t\t\t\treturn;\n\t\t\t\tconst variableInfo =\n\t\t\t\t\t/** @type {TODO} */\n\t\t\t\t\t(parser.getVariableInfo(declarator.init.callee.name));\n\t\t\t\tif (\n\t\t\t\t\tvariableInfo &&\n\t\t\t\t\tvariableInfo.tagInfo &&\n\t\t\t\t\tvariableInfo.tagInfo.tag === createRequireSpecifierTag\n\t\t\t\t) {\n\t\t\t\t\tconst context = parseCreateRequireArguments(declarator.init);\n\t\t\t\t\tif (context === undefined) return;\n\t\t\t\t\tparser.tagVariable(declarator.id.name, createdRequireIdentifierTag, {\n\t\t\t\t\t\tname: declarator.id.name,\n\t\t\t\t\t\tcontext\n\t\t\t\t\t});\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tparser.hooks.memberChainOfCallMemberChain\n\t\t\t.for(createRequireSpecifierTag)\n\t\t\t.tap(\n\t\t\t\t\"CommonJsImportsParserPlugin\",\n\t\t\t\t(expr, calleeMembers, callExpr, members) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tcalleeMembers.length !== 0 ||\n\t\t\t\t\t\tmembers.length !== 1 ||\n\t\t\t\t\t\tmembers[0] !== \"cache\"\n\t\t\t\t\t)\n\t\t\t\t\t\treturn;\n\t\t\t\t\t// createRequire().cache\n\t\t\t\t\tconst context = parseCreateRequireArguments(callExpr);\n\t\t\t\t\tif (context === undefined) return;\n\t\t\t\t\treturn requireCache(expr);\n\t\t\t\t}\n\t\t\t);\n\t\tparser.hooks.callMemberChainOfCallMemberChain\n\t\t\t.for(createRequireSpecifierTag)\n\t\t\t.tap(\n\t\t\t\t\"CommonJsImportsParserPlugin\",\n\t\t\t\t(expr, calleeMembers, innerCallExpression, members) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tcalleeMembers.length !== 0 ||\n\t\t\t\t\t\tmembers.length !== 1 ||\n\t\t\t\t\t\tmembers[0] !== \"resolve\"\n\t\t\t\t\t)\n\t\t\t\t\t\treturn;\n\t\t\t\t\t// createRequire().resolve()\n\t\t\t\t\treturn processResolve(expr, false);\n\t\t\t\t}\n\t\t\t);\n\t\tparser.hooks.expressionMemberChain\n\t\t\t.for(createdRequireIdentifierTag)\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", (expr, members) => {\n\t\t\t\t// require.cache\n\t\t\t\tif (members.length === 1 && members[0] === \"cache\") {\n\t\t\t\t\treturn requireCache(expr);\n\t\t\t\t}\n\t\t\t});\n\t\tparser.hooks.callMemberChain\n\t\t\t.for(createdRequireIdentifierTag)\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", (expr, members) => {\n\t\t\t\t// require.resolve()\n\t\t\t\tif (members.length === 1 && members[0] === \"resolve\") {\n\t\t\t\t\treturn processResolve(expr, false);\n\t\t\t\t}\n\t\t\t});\n\t\tparser.hooks.call\n\t\t\t.for(createRequireSpecifierTag)\n\t\t\t.tap(\"CommonJsImportsParserPlugin\", expr => {\n\t\t\t\tconst clearDep = new ConstDependency(\n\t\t\t\t\t\"/* createRequire() */ undefined\",\n\t\t\t\t\t/** @type {Range} */ (expr.range)\n\t\t\t\t);\n\t\t\t\tclearDep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\tparser.state.module.addPresentationalDependency(clearDep);\n\t\t\t\treturn true;\n\t\t\t});\n\t\t//#endregion\n\t}\n}\nmodule.exports = CommonJsImportsParserPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst nextTick = require(\"process\").nextTick;\n\n/** @typedef {import(\"./Resolver\").FileSystem} FileSystem */\n/** @typedef {import(\"./Resolver\").PathLike} PathLike */\n/** @typedef {import(\"./Resolver\").PathOrFileDescriptor} PathOrFileDescriptor */\n/** @typedef {import(\"./Resolver\").SyncFileSystem} SyncFileSystem */\n/** @typedef {FileSystem & SyncFileSystem} BaseFileSystem */\n\n/**\n * @template T\n * @typedef {import(\"./Resolver\").FileSystemCallback<T>} FileSystemCallback<T>\n */\n\n/**\n * @param {string} path path\n * @returns {string} dirname\n */\nconst dirname = path => {\n  let idx = path.length - 1;\n  while (idx >= 0) {\n    const c = path.charCodeAt(idx);\n    // slash or backslash\n    if (c === 47 || c === 92) break;\n    idx--;\n  }\n  if (idx < 0) return \"\";\n  return path.slice(0, idx);\n};\n\n/**\n * @template T\n * @param {FileSystemCallback<T>[]} callbacks callbacks\n * @param {Error | null} err error\n * @param {T} result result\n */\nconst runCallbacks = (callbacks, err, result) => {\n  if (callbacks.length === 1) {\n    callbacks[0](err, result);\n    callbacks.length = 0;\n    return;\n  }\n  let error;\n  for (const callback of callbacks) {\n    try {\n      callback(err, result);\n    } catch (e) {\n      if (!error) error = e;\n    }\n  }\n  callbacks.length = 0;\n  if (error) throw error;\n};\nclass OperationMergerBackend {\n  /**\n   * @param {Function | undefined} provider async method in filesystem\n   * @param {Function | undefined} syncProvider sync method in filesystem\n   * @param {BaseFileSystem} providerContext call context for the provider methods\n   */\n  constructor(provider, syncProvider, providerContext) {\n    this._provider = provider;\n    this._syncProvider = syncProvider;\n    this._providerContext = providerContext;\n    this._activeAsyncOperations = new Map();\n    this.provide = this._provider ?\n    /**\n     * @param {PathLike | PathOrFileDescriptor} path path\n     * @param {object | FileSystemCallback<any> | undefined} options options\n     * @param {FileSystemCallback<any>=} callback callback\n     * @returns {any} result\n     */\n    (path, options, callback) => {\n      if (typeof options === \"function\") {\n        callback = /** @type {FileSystemCallback<any>} */options;\n        options = undefined;\n      }\n      if (typeof path !== \"string\" && !Buffer.isBuffer(path) && !(path instanceof URL) && typeof path !== \"number\") {\n        /** @type {Function} */\n        callback(new TypeError(\"path must be a string, Buffer, URL or number\"));\n        return;\n      }\n      if (options) {\n        return /** @type {Function} */this._provider.call(this._providerContext, path, options, callback);\n      }\n      let callbacks = this._activeAsyncOperations.get(path);\n      if (callbacks) {\n        callbacks.push(callback);\n        return;\n      }\n      this._activeAsyncOperations.set(path, callbacks = [callback]);\n      /** @type {Function} */\n      provider(path,\n      /**\n       * @param {Error} err error\n       * @param {any} result result\n       */\n      (err, result) => {\n        this._activeAsyncOperations.delete(path);\n        runCallbacks(callbacks, err, result);\n      });\n    } : null;\n    this.provideSync = this._syncProvider ?\n    /**\n     * @param {PathLike | PathOrFileDescriptor} path path\n     * @param {object=} options options\n     * @returns {any} result\n     */\n    (path, options) => {\n      return /** @type {Function} */this._syncProvider.call(this._providerContext, path, options);\n    } : null;\n  }\n  purge() {}\n  purgeParent() {}\n}\n\n/*\n\nIDLE:\n\tinsert data: goto SYNC\n\nSYNC:\n\tbefore provide: run ticks\n\tevent loop tick: goto ASYNC_ACTIVE\n\nASYNC:\n\ttimeout: run tick, goto ASYNC_PASSIVE\n\nASYNC_PASSIVE:\n\tbefore provide: run ticks\n\nIDLE --[insert data]--> SYNC --[event loop tick]--> ASYNC_ACTIVE --[interval tick]-> ASYNC_PASSIVE\n                                                          ^                             |\n                                                          +---------[insert data]-------+\n*/\n\nconst STORAGE_MODE_IDLE = 0;\nconst STORAGE_MODE_SYNC = 1;\nconst STORAGE_MODE_ASYNC = 2;\n\n/**\n * @callback Provide\n * @param {PathLike | PathOrFileDescriptor} path path\n * @param {any} options options\n * @param {FileSystemCallback<any>} callback callback\n * @returns {void}\n */\n\nclass CacheBackend {\n  /**\n   * @param {number} duration max cache duration of items\n   * @param {function | undefined} provider async method\n   * @param {function | undefined} syncProvider sync method\n   * @param {BaseFileSystem} providerContext call context for the provider methods\n   */\n  constructor(duration, provider, syncProvider, providerContext) {\n    this._duration = duration;\n    this._provider = provider;\n    this._syncProvider = syncProvider;\n    this._providerContext = providerContext;\n    /** @type {Map<string, FileSystemCallback<any>[]>} */\n    this._activeAsyncOperations = new Map();\n    /** @type {Map<string, { err: Error | null, result?: any, level: Set<string> }>} */\n    this._data = new Map();\n    /** @type {Set<string>[]} */\n    this._levels = [];\n    for (let i = 0; i < 10; i++) this._levels.push(new Set());\n    for (let i = 5000; i < duration; i += 500) this._levels.push(new Set());\n    this._currentLevel = 0;\n    this._tickInterval = Math.floor(duration / this._levels.length);\n    /** @type {STORAGE_MODE_IDLE | STORAGE_MODE_SYNC | STORAGE_MODE_ASYNC} */\n    this._mode = STORAGE_MODE_IDLE;\n\n    /** @type {NodeJS.Timeout | undefined} */\n    this._timeout = undefined;\n    /** @type {number | undefined} */\n    this._nextDecay = undefined;\n\n    // @ts-ignore\n    this.provide = provider ? this.provide.bind(this) : null;\n    // @ts-ignore\n    this.provideSync = syncProvider ? this.provideSync.bind(this) : null;\n  }\n\n  /**\n   * @param {PathLike | PathOrFileDescriptor} path path\n   * @param {any} options options\n   * @param {FileSystemCallback<any>} callback callback\n   * @returns {void}\n   */\n  provide(path, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options;\n      options = undefined;\n    }\n    if (typeof path !== \"string\" && !Buffer.isBuffer(path) && !(path instanceof URL) && typeof path !== \"number\") {\n      callback(new TypeError(\"path must be a string, Buffer, URL or number\"));\n      return;\n    }\n    const strPath = typeof path !== \"string\" ? path.toString() : path;\n    if (options) {\n      return /** @type {Function} */this._provider.call(this._providerContext, path, options, callback);\n    }\n\n    // When in sync mode we can move to async mode\n    if (this._mode === STORAGE_MODE_SYNC) {\n      this._enterAsyncMode();\n    }\n\n    // Check in cache\n    let cacheEntry = this._data.get(strPath);\n    if (cacheEntry !== undefined) {\n      if (cacheEntry.err) return nextTick(callback, cacheEntry.err);\n      return nextTick(callback, null, cacheEntry.result);\n    }\n\n    // Check if there is already the same operation running\n    let callbacks = this._activeAsyncOperations.get(strPath);\n    if (callbacks !== undefined) {\n      callbacks.push(callback);\n      return;\n    }\n    this._activeAsyncOperations.set(strPath, callbacks = [callback]);\n\n    // Run the operation\n    /** @type {Function} */\n    this._provider.call(this._providerContext, path,\n    /**\n     * @param {Error | null} err error\n     * @param {any} [result] result\n     */\n    (err, result) => {\n      this._activeAsyncOperations.delete(strPath);\n      this._storeResult(strPath, err, result);\n\n      // Enter async mode if not yet done\n      this._enterAsyncMode();\n      runCallbacks( /** @type {FileSystemCallback<any>[]} */callbacks, err, result);\n    });\n  }\n\n  /**\n   * @param {PathLike | PathOrFileDescriptor} path path\n   * @param {any} options options\n   * @returns {any} result\n   */\n  provideSync(path, options) {\n    if (typeof path !== \"string\" && !Buffer.isBuffer(path) && !(path instanceof URL) && typeof path !== \"number\") {\n      throw new TypeError(\"path must be a string\");\n    }\n    const strPath = typeof path !== \"string\" ? path.toString() : path;\n    if (options) {\n      return /** @type {Function} */this._syncProvider.call(this._providerContext, path, options);\n    }\n\n    // In sync mode we may have to decay some cache items\n    if (this._mode === STORAGE_MODE_SYNC) {\n      this._runDecays();\n    }\n\n    // Check in cache\n    let cacheEntry = this._data.get(strPath);\n    if (cacheEntry !== undefined) {\n      if (cacheEntry.err) throw cacheEntry.err;\n      return cacheEntry.result;\n    }\n\n    // Get all active async operations\n    // This sync operation will also complete them\n    const callbacks = this._activeAsyncOperations.get(strPath);\n    this._activeAsyncOperations.delete(strPath);\n\n    // Run the operation\n    // When in idle mode, we will enter sync mode\n    let result;\n    try {\n      result = /** @type {Function} */this._syncProvider.call(this._providerContext, path);\n    } catch (err) {\n      this._storeResult(strPath, /** @type {Error} */err, undefined);\n      this._enterSyncModeWhenIdle();\n      if (callbacks) {\n        runCallbacks(callbacks, /** @type {Error} */err, undefined);\n      }\n      throw err;\n    }\n    this._storeResult(strPath, null, result);\n    this._enterSyncModeWhenIdle();\n    if (callbacks) {\n      runCallbacks(callbacks, null, result);\n    }\n    return result;\n  }\n\n  /**\n   * @param {string | Buffer | URL | number | (string | URL | Buffer | number)[] | Set<string | URL | Buffer | number>} [what] what to purge\n   */\n  purge(what) {\n    if (!what) {\n      if (this._mode !== STORAGE_MODE_IDLE) {\n        this._data.clear();\n        for (const level of this._levels) {\n          level.clear();\n        }\n        this._enterIdleMode();\n      }\n    } else if (typeof what === \"string\" || Buffer.isBuffer(what) || what instanceof URL || typeof what === \"number\") {\n      const strWhat = typeof what !== \"string\" ? what.toString() : what;\n      for (let [key, data] of this._data) {\n        if (key.startsWith(strWhat)) {\n          this._data.delete(key);\n          data.level.delete(key);\n        }\n      }\n      if (this._data.size === 0) {\n        this._enterIdleMode();\n      }\n    } else {\n      for (let [key, data] of this._data) {\n        for (const item of what) {\n          const strItem = typeof item !== \"string\" ? item.toString() : item;\n          if (key.startsWith(strItem)) {\n            this._data.delete(key);\n            data.level.delete(key);\n            break;\n          }\n        }\n      }\n      if (this._data.size === 0) {\n        this._enterIdleMode();\n      }\n    }\n  }\n\n  /**\n   * @param {string | Buffer | URL | number | (string | URL | Buffer | number)[] | Set<string | URL | Buffer | number>} [what] what to purge\n   */\n  purgeParent(what) {\n    if (!what) {\n      this.purge();\n    } else if (typeof what === \"string\" || Buffer.isBuffer(what) || what instanceof URL || typeof what === \"number\") {\n      const strWhat = typeof what !== \"string\" ? what.toString() : what;\n      this.purge(dirname(strWhat));\n    } else {\n      const set = new Set();\n      for (const item of what) {\n        const strItem = typeof item !== \"string\" ? item.toString() : item;\n        set.add(dirname(strItem));\n      }\n      this.purge(set);\n    }\n  }\n\n  /**\n   * @param {string} path path\n   * @param {Error | null} err error\n   * @param {any} result result\n   */\n  _storeResult(path, err, result) {\n    if (this._data.has(path)) return;\n    const level = this._levels[this._currentLevel];\n    this._data.set(path, {\n      err,\n      result,\n      level\n    });\n    level.add(path);\n  }\n  _decayLevel() {\n    const nextLevel = (this._currentLevel + 1) % this._levels.length;\n    const decay = this._levels[nextLevel];\n    this._currentLevel = nextLevel;\n    for (let item of decay) {\n      this._data.delete(item);\n    }\n    decay.clear();\n    if (this._data.size === 0) {\n      this._enterIdleMode();\n    } else {\n      /** @type {number} */\n      this._nextDecay += this._tickInterval;\n    }\n  }\n  _runDecays() {\n    while ( /** @type {number} */this._nextDecay <= Date.now() && this._mode !== STORAGE_MODE_IDLE) {\n      this._decayLevel();\n    }\n  }\n  _enterAsyncMode() {\n    let timeout = 0;\n    switch (this._mode) {\n      case STORAGE_MODE_ASYNC:\n        return;\n      case STORAGE_MODE_IDLE:\n        this._nextDecay = Date.now() + this._tickInterval;\n        timeout = this._tickInterval;\n        break;\n      case STORAGE_MODE_SYNC:\n        this._runDecays();\n        // _runDecays may change the mode\n        if ( /** @type {STORAGE_MODE_IDLE | STORAGE_MODE_SYNC | STORAGE_MODE_ASYNC}*/\n        this._mode === STORAGE_MODE_IDLE) return;\n        timeout = Math.max(0, /** @type {number} */this._nextDecay - Date.now());\n        break;\n    }\n    this._mode = STORAGE_MODE_ASYNC;\n    const ref = setTimeout(() => {\n      this._mode = STORAGE_MODE_SYNC;\n      this._runDecays();\n    }, timeout);\n    if (ref.unref) ref.unref();\n    this._timeout = ref;\n  }\n  _enterSyncModeWhenIdle() {\n    if (this._mode === STORAGE_MODE_IDLE) {\n      this._mode = STORAGE_MODE_SYNC;\n      this._nextDecay = Date.now() + this._tickInterval;\n    }\n  }\n  _enterIdleMode() {\n    this._mode = STORAGE_MODE_IDLE;\n    this._nextDecay = undefined;\n    if (this._timeout) clearTimeout(this._timeout);\n  }\n}\n\n/**\n * @template {function} Provider\n * @template {function} AsyncProvider\n * @template FileSystem\n * @param {number} duration duration in ms files are cached\n * @param {Provider | undefined} provider provider\n * @param {AsyncProvider | undefined} syncProvider sync provider\n * @param {BaseFileSystem} providerContext provider context\n * @returns {OperationMergerBackend | CacheBackend} backend\n */\nconst createBackend = (duration, provider, syncProvider, providerContext) => {\n  if (duration > 0) {\n    return new CacheBackend(duration, provider, syncProvider, providerContext);\n  }\n  return new OperationMergerBackend(provider, syncProvider, providerContext);\n};\nmodule.exports = class CachedInputFileSystem {\n  /**\n   * @param {BaseFileSystem} fileSystem file system\n   * @param {number} duration duration in ms files are cached\n   */\n  constructor(fileSystem, duration) {\n    this.fileSystem = fileSystem;\n    this._lstatBackend = createBackend(duration, this.fileSystem.lstat, this.fileSystem.lstatSync, this.fileSystem);\n    const lstat = this._lstatBackend.provide;\n    this.lstat = /** @type {FileSystem[\"lstat\"]} */lstat;\n    const lstatSync = this._lstatBackend.provideSync;\n    this.lstatSync = /** @type {SyncFileSystem[\"lstatSync\"]} */lstatSync;\n    this._statBackend = createBackend(duration, this.fileSystem.stat, this.fileSystem.statSync, this.fileSystem);\n    const stat = this._statBackend.provide;\n    this.stat = /** @type {FileSystem[\"stat\"]} */stat;\n    const statSync = this._statBackend.provideSync;\n    this.statSync = /** @type {SyncFileSystem[\"statSync\"]} */statSync;\n    this._readdirBackend = createBackend(duration, this.fileSystem.readdir, this.fileSystem.readdirSync, this.fileSystem);\n    const readdir = this._readdirBackend.provide;\n    this.readdir = /** @type {FileSystem[\"readdir\"]} */readdir;\n    const readdirSync = this._readdirBackend.provideSync;\n    this.readdirSync = /** @type {SyncFileSystem[\"readdirSync\"]} */\n    readdirSync;\n    this._readFileBackend = createBackend(duration, this.fileSystem.readFile, this.fileSystem.readFileSync, this.fileSystem);\n    const readFile = this._readFileBackend.provide;\n    this.readFile = /** @type {FileSystem[\"readFile\"]} */readFile;\n    const readFileSync = this._readFileBackend.provideSync;\n    this.readFileSync = /** @type {SyncFileSystem[\"readFileSync\"]} */\n    readFileSync;\n    this._readJsonBackend = createBackend(duration,\n    // prettier-ignore\n    this.fileSystem.readJson || this.readFile && (\n    /**\n     * @param {string} path path\n     * @param {FileSystemCallback<any>} callback\n     */\n    (path, callback) => {\n      this.readFile(path, (err, buffer) => {\n        if (err) return callback(err);\n        if (!buffer || buffer.length === 0) return callback(new Error(\"No file content\"));\n        let data;\n        try {\n          data = JSON.parse(buffer.toString(\"utf-8\"));\n        } catch (e) {\n          return callback( /** @type {Error} */e);\n        }\n        callback(null, data);\n      });\n    }),\n    // prettier-ignore\n    this.fileSystem.readJsonSync || this.readFileSync && (\n    /**\n     * @param {string} path path\n     * @returns {any} result\n     */\n    path => {\n      const buffer = this.readFileSync(path);\n      const data = JSON.parse(buffer.toString(\"utf-8\"));\n      return data;\n    }), this.fileSystem);\n    const readJson = this._readJsonBackend.provide;\n    this.readJson = /** @type {FileSystem[\"readJson\"]} */readJson;\n    const readJsonSync = this._readJsonBackend.provideSync;\n    this.readJsonSync = /** @type {SyncFileSystem[\"readJsonSync\"]} */\n    readJsonSync;\n    this._readlinkBackend = createBackend(duration, this.fileSystem.readlink, this.fileSystem.readlinkSync, this.fileSystem);\n    const readlink = this._readlinkBackend.provide;\n    this.readlink = /** @type {FileSystem[\"readlink\"]} */readlink;\n    const readlinkSync = this._readlinkBackend.provideSync;\n    this.readlinkSync = /** @type {SyncFileSystem[\"readlinkSync\"]} */\n    readlinkSync;\n    this._realpathBackend = createBackend(duration, this.fileSystem.realpath, this.fileSystem.realpathSync, this.fileSystem);\n    const realpath = this._realpathBackend.provide;\n    this.realpath = /** @type {FileSystem[\"realpath\"]} */realpath;\n    const realpathSync = this._realpathBackend.provideSync;\n    this.realpathSync = /** @type {SyncFileSystem[\"realpathSync\"]} */\n    realpathSync;\n  }\n\n  /**\n   * @param {string | Buffer | URL | number | (string | URL | Buffer | number)[] | Set<string | URL | Buffer | number>} [what] what to purge\n   */\n  purge(what) {\n    this._statBackend.purge(what);\n    this._lstatBackend.purge(what);\n    this._readdirBackend.purgeParent(what);\n    this._readFileBackend.purge(what);\n    this._readlinkBackend.purge(what);\n    this._readJsonBackend.purge(what);\n    this._realpathBackend.purge(what);\n  }\n};","map":{"version":3,"names":["nextTick","require","dirname","path","idx","length","c","charCodeAt","slice","runCallbacks","callbacks","err","result","error","callback","e","OperationMergerBackend","constructor","provider","syncProvider","providerContext","_provider","_syncProvider","_providerContext","_activeAsyncOperations","Map","provide","options","undefined","Buffer","isBuffer","URL","TypeError","call","get","push","set","delete","provideSync","purge","purgeParent","STORAGE_MODE_IDLE","STORAGE_MODE_SYNC","STORAGE_MODE_ASYNC","CacheBackend","duration","_duration","_data","_levels","i","Set","_currentLevel","_tickInterval","Math","floor","_mode","_timeout","_nextDecay","bind","strPath","toString","_enterAsyncMode","cacheEntry","_storeResult","_runDecays","_enterSyncModeWhenIdle","what","clear","level","_enterIdleMode","strWhat","key","data","startsWith","size","item","strItem","add","has","_decayLevel","nextLevel","decay","Date","now","timeout","max","ref","setTimeout","unref","clearTimeout","createBackend","module","exports","CachedInputFileSystem","fileSystem","_lstatBackend","lstat","lstatSync","_statBackend","stat","statSync","_readdirBackend","readdir","readdirSync","_readFileBackend","readFile","readFileSync","_readJsonBackend","readJson","buffer","Error","JSON","parse","readJsonSync","_readlinkBackend","readlink","readlinkSync","_realpathBackend","realpath","realpathSync"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/enhanced-resolve/lib/CachedInputFileSystem.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst nextTick = require(\"process\").nextTick;\n\n/** @typedef {import(\"./Resolver\").FileSystem} FileSystem */\n/** @typedef {import(\"./Resolver\").PathLike} PathLike */\n/** @typedef {import(\"./Resolver\").PathOrFileDescriptor} PathOrFileDescriptor */\n/** @typedef {import(\"./Resolver\").SyncFileSystem} SyncFileSystem */\n/** @typedef {FileSystem & SyncFileSystem} BaseFileSystem */\n\n/**\n * @template T\n * @typedef {import(\"./Resolver\").FileSystemCallback<T>} FileSystemCallback<T>\n */\n\n/**\n * @param {string} path path\n * @returns {string} dirname\n */\nconst dirname = path => {\n\tlet idx = path.length - 1;\n\twhile (idx >= 0) {\n\t\tconst c = path.charCodeAt(idx);\n\t\t// slash or backslash\n\t\tif (c === 47 || c === 92) break;\n\t\tidx--;\n\t}\n\tif (idx < 0) return \"\";\n\treturn path.slice(0, idx);\n};\n\n/**\n * @template T\n * @param {FileSystemCallback<T>[]} callbacks callbacks\n * @param {Error | null} err error\n * @param {T} result result\n */\nconst runCallbacks = (callbacks, err, result) => {\n\tif (callbacks.length === 1) {\n\t\tcallbacks[0](err, result);\n\t\tcallbacks.length = 0;\n\t\treturn;\n\t}\n\tlet error;\n\tfor (const callback of callbacks) {\n\t\ttry {\n\t\t\tcallback(err, result);\n\t\t} catch (e) {\n\t\t\tif (!error) error = e;\n\t\t}\n\t}\n\tcallbacks.length = 0;\n\tif (error) throw error;\n};\n\nclass OperationMergerBackend {\n\t/**\n\t * @param {Function | undefined} provider async method in filesystem\n\t * @param {Function | undefined} syncProvider sync method in filesystem\n\t * @param {BaseFileSystem} providerContext call context for the provider methods\n\t */\n\tconstructor(provider, syncProvider, providerContext) {\n\t\tthis._provider = provider;\n\t\tthis._syncProvider = syncProvider;\n\t\tthis._providerContext = providerContext;\n\t\tthis._activeAsyncOperations = new Map();\n\n\t\tthis.provide = this._provider\n\t\t\t? /**\n\t\t\t   * @param {PathLike | PathOrFileDescriptor} path path\n\t\t\t   * @param {object | FileSystemCallback<any> | undefined} options options\n\t\t\t   * @param {FileSystemCallback<any>=} callback callback\n\t\t\t   * @returns {any} result\n\t\t\t   */\n\t\t\t  (path, options, callback) => {\n\t\t\t\t\tif (typeof options === \"function\") {\n\t\t\t\t\t\tcallback = /** @type {FileSystemCallback<any>} */ (options);\n\t\t\t\t\t\toptions = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\ttypeof path !== \"string\" &&\n\t\t\t\t\t\t!Buffer.isBuffer(path) &&\n\t\t\t\t\t\t!(path instanceof URL) &&\n\t\t\t\t\t\ttypeof path !== \"number\"\n\t\t\t\t\t) {\n\t\t\t\t\t\t/** @type {Function} */\n\t\t\t\t\t\t(callback)(\n\t\t\t\t\t\t\tnew TypeError(\"path must be a string, Buffer, URL or number\")\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (options) {\n\t\t\t\t\t\treturn /** @type {Function} */ (this._provider).call(\n\t\t\t\t\t\t\tthis._providerContext,\n\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tlet callbacks = this._activeAsyncOperations.get(path);\n\t\t\t\t\tif (callbacks) {\n\t\t\t\t\t\tcallbacks.push(callback);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis._activeAsyncOperations.set(path, (callbacks = [callback]));\n\t\t\t\t\t/** @type {Function} */\n\t\t\t\t\t(provider)(\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {Error} err error\n\t\t\t\t\t\t * @param {any} result result\n\t\t\t\t\t\t */\n\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\tthis._activeAsyncOperations.delete(path);\n\t\t\t\t\t\t\trunCallbacks(callbacks, err, result);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t  }\n\t\t\t: null;\n\t\tthis.provideSync = this._syncProvider\n\t\t\t? /**\n\t\t\t   * @param {PathLike | PathOrFileDescriptor} path path\n\t\t\t   * @param {object=} options options\n\t\t\t   * @returns {any} result\n\t\t\t   */\n\t\t\t  (path, options) => {\n\t\t\t\t\treturn /** @type {Function} */ (this._syncProvider).call(\n\t\t\t\t\t\tthis._providerContext,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\toptions\n\t\t\t\t\t);\n\t\t\t  }\n\t\t\t: null;\n\t}\n\n\tpurge() {}\n\tpurgeParent() {}\n}\n\n/*\n\nIDLE:\n\tinsert data: goto SYNC\n\nSYNC:\n\tbefore provide: run ticks\n\tevent loop tick: goto ASYNC_ACTIVE\n\nASYNC:\n\ttimeout: run tick, goto ASYNC_PASSIVE\n\nASYNC_PASSIVE:\n\tbefore provide: run ticks\n\nIDLE --[insert data]--> SYNC --[event loop tick]--> ASYNC_ACTIVE --[interval tick]-> ASYNC_PASSIVE\n                                                          ^                             |\n                                                          +---------[insert data]-------+\n*/\n\nconst STORAGE_MODE_IDLE = 0;\nconst STORAGE_MODE_SYNC = 1;\nconst STORAGE_MODE_ASYNC = 2;\n\n/**\n * @callback Provide\n * @param {PathLike | PathOrFileDescriptor} path path\n * @param {any} options options\n * @param {FileSystemCallback<any>} callback callback\n * @returns {void}\n */\n\nclass CacheBackend {\n\t/**\n\t * @param {number} duration max cache duration of items\n\t * @param {function | undefined} provider async method\n\t * @param {function | undefined} syncProvider sync method\n\t * @param {BaseFileSystem} providerContext call context for the provider methods\n\t */\n\tconstructor(duration, provider, syncProvider, providerContext) {\n\t\tthis._duration = duration;\n\t\tthis._provider = provider;\n\t\tthis._syncProvider = syncProvider;\n\t\tthis._providerContext = providerContext;\n\t\t/** @type {Map<string, FileSystemCallback<any>[]>} */\n\t\tthis._activeAsyncOperations = new Map();\n\t\t/** @type {Map<string, { err: Error | null, result?: any, level: Set<string> }>} */\n\t\tthis._data = new Map();\n\t\t/** @type {Set<string>[]} */\n\t\tthis._levels = [];\n\t\tfor (let i = 0; i < 10; i++) this._levels.push(new Set());\n\t\tfor (let i = 5000; i < duration; i += 500) this._levels.push(new Set());\n\t\tthis._currentLevel = 0;\n\t\tthis._tickInterval = Math.floor(duration / this._levels.length);\n\t\t/** @type {STORAGE_MODE_IDLE | STORAGE_MODE_SYNC | STORAGE_MODE_ASYNC} */\n\t\tthis._mode = STORAGE_MODE_IDLE;\n\n\t\t/** @type {NodeJS.Timeout | undefined} */\n\t\tthis._timeout = undefined;\n\t\t/** @type {number | undefined} */\n\t\tthis._nextDecay = undefined;\n\n\t\t// @ts-ignore\n\t\tthis.provide = provider ? this.provide.bind(this) : null;\n\t\t// @ts-ignore\n\t\tthis.provideSync = syncProvider ? this.provideSync.bind(this) : null;\n\t}\n\n\t/**\n\t * @param {PathLike | PathOrFileDescriptor} path path\n\t * @param {any} options options\n\t * @param {FileSystemCallback<any>} callback callback\n\t * @returns {void}\n\t */\n\tprovide(path, options, callback) {\n\t\tif (typeof options === \"function\") {\n\t\t\tcallback = options;\n\t\t\toptions = undefined;\n\t\t}\n\t\tif (\n\t\t\ttypeof path !== \"string\" &&\n\t\t\t!Buffer.isBuffer(path) &&\n\t\t\t!(path instanceof URL) &&\n\t\t\ttypeof path !== \"number\"\n\t\t) {\n\t\t\tcallback(new TypeError(\"path must be a string, Buffer, URL or number\"));\n\t\t\treturn;\n\t\t}\n\t\tconst strPath = typeof path !== \"string\" ? path.toString() : path;\n\t\tif (options) {\n\t\t\treturn /** @type {Function} */ (this._provider).call(\n\t\t\t\tthis._providerContext,\n\t\t\t\tpath,\n\t\t\t\toptions,\n\t\t\t\tcallback\n\t\t\t);\n\t\t}\n\n\t\t// When in sync mode we can move to async mode\n\t\tif (this._mode === STORAGE_MODE_SYNC) {\n\t\t\tthis._enterAsyncMode();\n\t\t}\n\n\t\t// Check in cache\n\t\tlet cacheEntry = this._data.get(strPath);\n\t\tif (cacheEntry !== undefined) {\n\t\t\tif (cacheEntry.err) return nextTick(callback, cacheEntry.err);\n\t\t\treturn nextTick(callback, null, cacheEntry.result);\n\t\t}\n\n\t\t// Check if there is already the same operation running\n\t\tlet callbacks = this._activeAsyncOperations.get(strPath);\n\t\tif (callbacks !== undefined) {\n\t\t\tcallbacks.push(callback);\n\t\t\treturn;\n\t\t}\n\t\tthis._activeAsyncOperations.set(strPath, (callbacks = [callback]));\n\n\t\t// Run the operation\n\t\t/** @type {Function} */\n\t\t(this._provider).call(\n\t\t\tthis._providerContext,\n\t\t\tpath,\n\t\t\t/**\n\t\t\t * @param {Error | null} err error\n\t\t\t * @param {any} [result] result\n\t\t\t */\n\t\t\t(err, result) => {\n\t\t\t\tthis._activeAsyncOperations.delete(strPath);\n\t\t\t\tthis._storeResult(strPath, err, result);\n\n\t\t\t\t// Enter async mode if not yet done\n\t\t\t\tthis._enterAsyncMode();\n\n\t\t\t\trunCallbacks(\n\t\t\t\t\t/** @type {FileSystemCallback<any>[]} */ (callbacks),\n\t\t\t\t\terr,\n\t\t\t\t\tresult\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {PathLike | PathOrFileDescriptor} path path\n\t * @param {any} options options\n\t * @returns {any} result\n\t */\n\tprovideSync(path, options) {\n\t\tif (\n\t\t\ttypeof path !== \"string\" &&\n\t\t\t!Buffer.isBuffer(path) &&\n\t\t\t!(path instanceof URL) &&\n\t\t\ttypeof path !== \"number\"\n\t\t) {\n\t\t\tthrow new TypeError(\"path must be a string\");\n\t\t}\n\t\tconst strPath = typeof path !== \"string\" ? path.toString() : path;\n\t\tif (options) {\n\t\t\treturn /** @type {Function} */ (this._syncProvider).call(\n\t\t\t\tthis._providerContext,\n\t\t\t\tpath,\n\t\t\t\toptions\n\t\t\t);\n\t\t}\n\n\t\t// In sync mode we may have to decay some cache items\n\t\tif (this._mode === STORAGE_MODE_SYNC) {\n\t\t\tthis._runDecays();\n\t\t}\n\n\t\t// Check in cache\n\t\tlet cacheEntry = this._data.get(strPath);\n\t\tif (cacheEntry !== undefined) {\n\t\t\tif (cacheEntry.err) throw cacheEntry.err;\n\t\t\treturn cacheEntry.result;\n\t\t}\n\n\t\t// Get all active async operations\n\t\t// This sync operation will also complete them\n\t\tconst callbacks = this._activeAsyncOperations.get(strPath);\n\t\tthis._activeAsyncOperations.delete(strPath);\n\n\t\t// Run the operation\n\t\t// When in idle mode, we will enter sync mode\n\t\tlet result;\n\t\ttry {\n\t\t\tresult = /** @type {Function} */ (this._syncProvider).call(\n\t\t\t\tthis._providerContext,\n\t\t\t\tpath\n\t\t\t);\n\t\t} catch (err) {\n\t\t\tthis._storeResult(strPath, /** @type {Error} */ (err), undefined);\n\t\t\tthis._enterSyncModeWhenIdle();\n\t\t\tif (callbacks) {\n\t\t\t\trunCallbacks(callbacks, /** @type {Error} */ (err), undefined);\n\t\t\t}\n\t\t\tthrow err;\n\t\t}\n\t\tthis._storeResult(strPath, null, result);\n\t\tthis._enterSyncModeWhenIdle();\n\t\tif (callbacks) {\n\t\t\trunCallbacks(callbacks, null, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {string | Buffer | URL | number | (string | URL | Buffer | number)[] | Set<string | URL | Buffer | number>} [what] what to purge\n\t */\n\tpurge(what) {\n\t\tif (!what) {\n\t\t\tif (this._mode !== STORAGE_MODE_IDLE) {\n\t\t\t\tthis._data.clear();\n\t\t\t\tfor (const level of this._levels) {\n\t\t\t\t\tlevel.clear();\n\t\t\t\t}\n\t\t\t\tthis._enterIdleMode();\n\t\t\t}\n\t\t} else if (\n\t\t\ttypeof what === \"string\" ||\n\t\t\tBuffer.isBuffer(what) ||\n\t\t\twhat instanceof URL ||\n\t\t\ttypeof what === \"number\"\n\t\t) {\n\t\t\tconst strWhat = typeof what !== \"string\" ? what.toString() : what;\n\t\t\tfor (let [key, data] of this._data) {\n\t\t\t\tif (key.startsWith(strWhat)) {\n\t\t\t\t\tthis._data.delete(key);\n\t\t\t\t\tdata.level.delete(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._data.size === 0) {\n\t\t\t\tthis._enterIdleMode();\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let [key, data] of this._data) {\n\t\t\t\tfor (const item of what) {\n\t\t\t\t\tconst strItem = typeof item !== \"string\" ? item.toString() : item;\n\t\t\t\t\tif (key.startsWith(strItem)) {\n\t\t\t\t\t\tthis._data.delete(key);\n\t\t\t\t\t\tdata.level.delete(key);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._data.size === 0) {\n\t\t\t\tthis._enterIdleMode();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {string | Buffer | URL | number | (string | URL | Buffer | number)[] | Set<string | URL | Buffer | number>} [what] what to purge\n\t */\n\tpurgeParent(what) {\n\t\tif (!what) {\n\t\t\tthis.purge();\n\t\t} else if (\n\t\t\ttypeof what === \"string\" ||\n\t\t\tBuffer.isBuffer(what) ||\n\t\t\twhat instanceof URL ||\n\t\t\ttypeof what === \"number\"\n\t\t) {\n\t\t\tconst strWhat = typeof what !== \"string\" ? what.toString() : what;\n\t\t\tthis.purge(dirname(strWhat));\n\t\t} else {\n\t\t\tconst set = new Set();\n\t\t\tfor (const item of what) {\n\t\t\t\tconst strItem = typeof item !== \"string\" ? item.toString() : item;\n\t\t\t\tset.add(dirname(strItem));\n\t\t\t}\n\t\t\tthis.purge(set);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} path path\n\t * @param {Error | null} err error\n\t * @param {any} result result\n\t */\n\t_storeResult(path, err, result) {\n\t\tif (this._data.has(path)) return;\n\t\tconst level = this._levels[this._currentLevel];\n\t\tthis._data.set(path, { err, result, level });\n\t\tlevel.add(path);\n\t}\n\n\t_decayLevel() {\n\t\tconst nextLevel = (this._currentLevel + 1) % this._levels.length;\n\t\tconst decay = this._levels[nextLevel];\n\t\tthis._currentLevel = nextLevel;\n\t\tfor (let item of decay) {\n\t\t\tthis._data.delete(item);\n\t\t}\n\t\tdecay.clear();\n\t\tif (this._data.size === 0) {\n\t\t\tthis._enterIdleMode();\n\t\t} else {\n\t\t\t/** @type {number} */\n\t\t\t(this._nextDecay) += this._tickInterval;\n\t\t}\n\t}\n\n\t_runDecays() {\n\t\twhile (\n\t\t\t/** @type {number} */ (this._nextDecay) <= Date.now() &&\n\t\t\tthis._mode !== STORAGE_MODE_IDLE\n\t\t) {\n\t\t\tthis._decayLevel();\n\t\t}\n\t}\n\n\t_enterAsyncMode() {\n\t\tlet timeout = 0;\n\t\tswitch (this._mode) {\n\t\t\tcase STORAGE_MODE_ASYNC:\n\t\t\t\treturn;\n\t\t\tcase STORAGE_MODE_IDLE:\n\t\t\t\tthis._nextDecay = Date.now() + this._tickInterval;\n\t\t\t\ttimeout = this._tickInterval;\n\t\t\t\tbreak;\n\t\t\tcase STORAGE_MODE_SYNC:\n\t\t\t\tthis._runDecays();\n\t\t\t\t// _runDecays may change the mode\n\t\t\t\tif (\n\t\t\t\t\t/** @type {STORAGE_MODE_IDLE | STORAGE_MODE_SYNC | STORAGE_MODE_ASYNC}*/\n\t\t\t\t\t(this._mode) === STORAGE_MODE_IDLE\n\t\t\t\t)\n\t\t\t\t\treturn;\n\t\t\t\ttimeout = Math.max(\n\t\t\t\t\t0,\n\t\t\t\t\t/** @type {number} */ (this._nextDecay) - Date.now()\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t}\n\t\tthis._mode = STORAGE_MODE_ASYNC;\n\t\tconst ref = setTimeout(() => {\n\t\t\tthis._mode = STORAGE_MODE_SYNC;\n\t\t\tthis._runDecays();\n\t\t}, timeout);\n\t\tif (ref.unref) ref.unref();\n\t\tthis._timeout = ref;\n\t}\n\n\t_enterSyncModeWhenIdle() {\n\t\tif (this._mode === STORAGE_MODE_IDLE) {\n\t\t\tthis._mode = STORAGE_MODE_SYNC;\n\t\t\tthis._nextDecay = Date.now() + this._tickInterval;\n\t\t}\n\t}\n\n\t_enterIdleMode() {\n\t\tthis._mode = STORAGE_MODE_IDLE;\n\t\tthis._nextDecay = undefined;\n\t\tif (this._timeout) clearTimeout(this._timeout);\n\t}\n}\n\n/**\n * @template {function} Provider\n * @template {function} AsyncProvider\n * @template FileSystem\n * @param {number} duration duration in ms files are cached\n * @param {Provider | undefined} provider provider\n * @param {AsyncProvider | undefined} syncProvider sync provider\n * @param {BaseFileSystem} providerContext provider context\n * @returns {OperationMergerBackend | CacheBackend} backend\n */\nconst createBackend = (duration, provider, syncProvider, providerContext) => {\n\tif (duration > 0) {\n\t\treturn new CacheBackend(duration, provider, syncProvider, providerContext);\n\t}\n\treturn new OperationMergerBackend(provider, syncProvider, providerContext);\n};\n\nmodule.exports = class CachedInputFileSystem {\n\t/**\n\t * @param {BaseFileSystem} fileSystem file system\n\t * @param {number} duration duration in ms files are cached\n\t */\n\tconstructor(fileSystem, duration) {\n\t\tthis.fileSystem = fileSystem;\n\n\t\tthis._lstatBackend = createBackend(\n\t\t\tduration,\n\t\t\tthis.fileSystem.lstat,\n\t\t\tthis.fileSystem.lstatSync,\n\t\t\tthis.fileSystem\n\t\t);\n\t\tconst lstat = this._lstatBackend.provide;\n\t\tthis.lstat = /** @type {FileSystem[\"lstat\"]} */ (lstat);\n\t\tconst lstatSync = this._lstatBackend.provideSync;\n\t\tthis.lstatSync = /** @type {SyncFileSystem[\"lstatSync\"]} */ (lstatSync);\n\n\t\tthis._statBackend = createBackend(\n\t\t\tduration,\n\t\t\tthis.fileSystem.stat,\n\t\t\tthis.fileSystem.statSync,\n\t\t\tthis.fileSystem\n\t\t);\n\t\tconst stat = this._statBackend.provide;\n\t\tthis.stat = /** @type {FileSystem[\"stat\"]} */ (stat);\n\t\tconst statSync = this._statBackend.provideSync;\n\t\tthis.statSync = /** @type {SyncFileSystem[\"statSync\"]} */ (statSync);\n\n\t\tthis._readdirBackend = createBackend(\n\t\t\tduration,\n\t\t\tthis.fileSystem.readdir,\n\t\t\tthis.fileSystem.readdirSync,\n\t\t\tthis.fileSystem\n\t\t);\n\t\tconst readdir = this._readdirBackend.provide;\n\t\tthis.readdir = /** @type {FileSystem[\"readdir\"]} */ (readdir);\n\t\tconst readdirSync = this._readdirBackend.provideSync;\n\t\tthis.readdirSync = /** @type {SyncFileSystem[\"readdirSync\"]} */ (\n\t\t\treaddirSync\n\t\t);\n\n\t\tthis._readFileBackend = createBackend(\n\t\t\tduration,\n\t\t\tthis.fileSystem.readFile,\n\t\t\tthis.fileSystem.readFileSync,\n\t\t\tthis.fileSystem\n\t\t);\n\t\tconst readFile = this._readFileBackend.provide;\n\t\tthis.readFile = /** @type {FileSystem[\"readFile\"]} */ (readFile);\n\t\tconst readFileSync = this._readFileBackend.provideSync;\n\t\tthis.readFileSync = /** @type {SyncFileSystem[\"readFileSync\"]} */ (\n\t\t\treadFileSync\n\t\t);\n\n\t\tthis._readJsonBackend = createBackend(\n\t\t\tduration,\n\t\t\t// prettier-ignore\n\t\t\tthis.fileSystem.readJson ||\n\t\t\t\t(this.readFile &&\n\t\t\t\t\t(\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {string} path path\n\t\t\t\t\t\t * @param {FileSystemCallback<any>} callback\n\t\t\t\t\t\t */\n\t\t\t\t\t\t(path, callback) => {\n\t\t\t\t\t\t\tthis.readFile(path, (err, buffer) => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\tif (!buffer || buffer.length === 0)\n\t\t\t\t\t\t\t\t\treturn callback(new Error(\"No file content\"));\n\t\t\t\t\t\t\t\tlet data;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tdata = JSON.parse(buffer.toString(\"utf-8\"));\n\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\treturn callback(/** @type {Error} */ (e));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcallback(null, data);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t})\n\t\t\t\t),\n\t\t\t// prettier-ignore\n\t\t\tthis.fileSystem.readJsonSync ||\n\t\t\t\t(this.readFileSync &&\n\t\t\t\t\t(\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {string} path path\n\t\t\t\t\t\t * @returns {any} result\n\t\t\t\t\t\t */\n\t\t\t\t\t\t(path) => {\n\t\t\t\t\t\t\tconst buffer = this.readFileSync(path);\n\t\t\t\t\t\t\tconst data = JSON.parse(buffer.toString(\"utf-8\"));\n\t\t\t\t\t\t\treturn data;\n\t\t\t\t\t\t}\n\t\t\t\t )),\n\t\t\tthis.fileSystem\n\t\t);\n\t\tconst readJson = this._readJsonBackend.provide;\n\t\tthis.readJson = /** @type {FileSystem[\"readJson\"]} */ (readJson);\n\t\tconst readJsonSync = this._readJsonBackend.provideSync;\n\t\tthis.readJsonSync = /** @type {SyncFileSystem[\"readJsonSync\"]} */ (\n\t\t\treadJsonSync\n\t\t);\n\n\t\tthis._readlinkBackend = createBackend(\n\t\t\tduration,\n\t\t\tthis.fileSystem.readlink,\n\t\t\tthis.fileSystem.readlinkSync,\n\t\t\tthis.fileSystem\n\t\t);\n\t\tconst readlink = this._readlinkBackend.provide;\n\t\tthis.readlink = /** @type {FileSystem[\"readlink\"]} */ (readlink);\n\t\tconst readlinkSync = this._readlinkBackend.provideSync;\n\t\tthis.readlinkSync = /** @type {SyncFileSystem[\"readlinkSync\"]} */ (\n\t\t\treadlinkSync\n\t\t);\n\n\t\tthis._realpathBackend = createBackend(\n\t\t\tduration,\n\t\t\tthis.fileSystem.realpath,\n\t\t\tthis.fileSystem.realpathSync,\n\t\t\tthis.fileSystem\n\t\t);\n\t\tconst realpath = this._realpathBackend.provide;\n\t\tthis.realpath = /** @type {FileSystem[\"realpath\"]} */ (realpath);\n\t\tconst realpathSync = this._realpathBackend.provideSync;\n\t\tthis.realpathSync = /** @type {SyncFileSystem[\"realpathSync\"]} */ (\n\t\t\trealpathSync\n\t\t);\n\t}\n\n\t/**\n\t * @param {string | Buffer | URL | number | (string | URL | Buffer | number)[] | Set<string | URL | Buffer | number>} [what] what to purge\n\t */\n\tpurge(what) {\n\t\tthis._statBackend.purge(what);\n\t\tthis._lstatBackend.purge(what);\n\t\tthis._readdirBackend.purgeParent(what);\n\t\tthis._readFileBackend.purge(what);\n\t\tthis._readlinkBackend.purge(what);\n\t\tthis._readJsonBackend.purge(what);\n\t\tthis._realpathBackend.purge(what);\n\t}\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
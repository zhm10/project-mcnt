{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  parseResource\n} = require(\"../util/identifier\");\n\n/** @typedef {import(\"estree\").Node} EsTreeNode */\n/** @typedef {import(\"../../declarations/WebpackOptions\").JavascriptParserOptions} JavascriptParserOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").ModuleOptionsNormalized} ModuleOptions */\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"../javascript/BasicEvaluatedExpression\")} BasicEvaluatedExpression */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n/** @typedef {import(\"./ContextDependency\")} ContextDependency */\n/** @typedef {import(\"./ContextDependency\").ContextDependencyOptions} ContextDependencyOptions */\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nconst quoteMeta = str => {\n  return str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\n/**\n * @param {string} prefix prefix\n * @returns {{prefix: string, context: string}} result\n */\nconst splitContextFromPrefix = prefix => {\n  const idx = prefix.lastIndexOf(\"/\");\n  let context = \".\";\n  if (idx >= 0) {\n    context = prefix.slice(0, idx);\n    prefix = `.${prefix.slice(idx)}`;\n  }\n  return {\n    context,\n    prefix\n  };\n};\n\n/** @typedef {Partial<Omit<ContextDependencyOptions, \"resource\">>} PartialContextDependencyOptions */\n/** @typedef {{ new(options: ContextDependencyOptions, range: Range, valueRange: [number, number], ...args: any[]): ContextDependency }} ContextDependencyConstructor */\n\n/**\n * @param {ContextDependencyConstructor} Dep the Dependency class\n * @param {Range} range source range\n * @param {BasicEvaluatedExpression} param context param\n * @param {EsTreeNode} expr expr\n * @param {Pick<JavascriptParserOptions, `${\"expr\"|\"wrapped\"}Context${\"Critical\"|\"Recursive\"|\"RegExp\"}` | \"exprContextRequest\">} options options for context creation\n * @param {PartialContextDependencyOptions} contextOptions options for the ContextModule\n * @param {JavascriptParser} parser the parser\n * @param {...any} depArgs depArgs\n * @returns {ContextDependency} the created Dependency\n */\nexports.create = (Dep, range, param, expr, options, contextOptions, parser, ...depArgs) => {\n  if (param.isTemplateString()) {\n    const quasis = /** @type {BasicEvaluatedExpression[]} */param.quasis;\n    let prefixRaw = /** @type {string} */quasis[0].string;\n    let postfixRaw = /** @type {string} */\n    quasis.length > 1 ? quasis[quasis.length - 1].string : \"\";\n    const valueRange = /** @type {Range} */param.range;\n    const {\n      context,\n      prefix\n    } = splitContextFromPrefix(prefixRaw);\n    const {\n      path: postfix,\n      query,\n      fragment\n    } = parseResource(postfixRaw, parser);\n\n    // When there are more than two quasis, the generated RegExp can be more precise\n    // We join the quasis with the expression regexp\n    const innerQuasis = quasis.slice(1, quasis.length - 1);\n    const innerRegExp = /** @type {RegExp} */options.wrappedContextRegExp.source + innerQuasis.map(q => quoteMeta( /** @type {string} */q.string) + /** @type {RegExp} */options.wrappedContextRegExp.source).join(\"\");\n\n    // Example: `./context/pre${e}inner${e}inner2${e}post?query#frag`\n    // context: \"./context\"\n    // prefix: \"./pre\"\n    // innerQuasis: [BEE(\"inner\"), BEE(\"inner2\")]\n    // (BEE = BasicEvaluatedExpression)\n    // postfix: \"post\"\n    // query: \"?query\"\n    // fragment: \"#frag\"\n    // regExp: /^\\.\\/pre.*inner.*inner2.*post$/\n    const regExp = new RegExp(`^${quoteMeta(prefix)}${innerRegExp}${quoteMeta(postfix)}$`);\n    const dep = new Dep({\n      request: context + query + fragment,\n      recursive: ( /** @type {boolean} */options.wrappedContextRecursive),\n      regExp,\n      mode: \"sync\",\n      ...contextOptions\n    }, range, valueRange, ...depArgs);\n    dep.loc = /** @type {DependencyLocation} */expr.loc;\n\n    /** @type {{ value: string, range: Range }[]} */\n    const replaces = [];\n    const parts = /** @type {BasicEvaluatedExpression[]} */param.parts;\n    parts.forEach((part, i) => {\n      if (i % 2 === 0) {\n        // Quasis or merged quasi\n        let range = /** @type {Range} */part.range;\n        let value = /** @type {string} */part.string;\n        if (param.templateStringKind === \"cooked\") {\n          value = JSON.stringify(value);\n          value = value.slice(1, value.length - 1);\n        }\n        if (i === 0) {\n          // prefix\n          value = prefix;\n          range = [/** @type {Range} */param.range[0], /** @type {Range} */part.range[1]];\n          value = (param.templateStringKind === \"cooked\" ? \"`\" : \"String.raw`\") + value;\n        } else if (i === parts.length - 1) {\n          // postfix\n          value = postfix;\n          range = [/** @type {Range} */part.range[0], /** @type {Range} */param.range[1]];\n          value = value + \"`\";\n        } else if (part.expression && part.expression.type === \"TemplateElement\" && part.expression.value.raw === value) {\n          // Shortcut when it's a single quasi and doesn't need to be replaced\n          return;\n        }\n        replaces.push({\n          range,\n          value\n        });\n      } else {\n        // Expression\n        parser.walkExpression(part.expression);\n      }\n    });\n    dep.replaces = replaces;\n    dep.critical = options.wrappedContextCritical && \"a part of the request of a dependency is an expression\";\n    return dep;\n  } else if (param.isWrapped() && (param.prefix && param.prefix.isString() || param.postfix && param.postfix.isString())) {\n    let prefixRaw = /** @type {string} */\n    param.prefix && param.prefix.isString() ? param.prefix.string : \"\";\n    let postfixRaw = /** @type {string} */\n    param.postfix && param.postfix.isString() ? param.postfix.string : \"\";\n    const prefixRange = param.prefix && param.prefix.isString() ? param.prefix.range : null;\n    const postfixRange = param.postfix && param.postfix.isString() ? param.postfix.range : null;\n    const valueRange = /** @type {Range} */param.range;\n    const {\n      context,\n      prefix\n    } = splitContextFromPrefix(prefixRaw);\n    const {\n      path: postfix,\n      query,\n      fragment\n    } = parseResource(postfixRaw, parser);\n    const regExp = new RegExp(`^${quoteMeta(prefix)}${/** @type {RegExp} */options.wrappedContextRegExp.source}${quoteMeta(postfix)}$`);\n    const dep = new Dep({\n      request: context + query + fragment,\n      recursive: ( /** @type {boolean} */options.wrappedContextRecursive),\n      regExp,\n      mode: \"sync\",\n      ...contextOptions\n    }, range, valueRange, ...depArgs);\n    dep.loc = /** @type {DependencyLocation} */expr.loc;\n    const replaces = [];\n    if (prefixRange) {\n      replaces.push({\n        range: prefixRange,\n        value: JSON.stringify(prefix)\n      });\n    }\n    if (postfixRange) {\n      replaces.push({\n        range: postfixRange,\n        value: JSON.stringify(postfix)\n      });\n    }\n    dep.replaces = replaces;\n    dep.critical = options.wrappedContextCritical && \"a part of the request of a dependency is an expression\";\n    if (parser && param.wrappedInnerExpressions) {\n      for (const part of param.wrappedInnerExpressions) {\n        if (part.expression) parser.walkExpression(part.expression);\n      }\n    }\n    return dep;\n  } else {\n    const dep = new Dep({\n      request: ( /** @type {string} */options.exprContextRequest),\n      recursive: ( /** @type {boolean} */options.exprContextRecursive),\n      regExp: ( /** @type {RegExp} */options.exprContextRegExp),\n      mode: \"sync\",\n      ...contextOptions\n    }, range, /** @type {Range} */param.range, ...depArgs);\n    dep.loc = /** @type {DependencyLocation} */expr.loc;\n    dep.critical = options.exprContextCritical && \"the request of a dependency is an expression\";\n    parser.walkExpression(param.expression);\n    return dep;\n  }\n};","map":{"version":3,"names":["parseResource","require","quoteMeta","str","replace","splitContextFromPrefix","prefix","idx","lastIndexOf","context","slice","exports","create","Dep","range","param","expr","options","contextOptions","parser","depArgs","isTemplateString","quasis","prefixRaw","string","postfixRaw","length","valueRange","path","postfix","query","fragment","innerQuasis","innerRegExp","wrappedContextRegExp","source","map","q","join","regExp","RegExp","dep","request","recursive","wrappedContextRecursive","mode","loc","replaces","parts","forEach","part","i","value","templateStringKind","JSON","stringify","expression","type","raw","push","walkExpression","critical","wrappedContextCritical","isWrapped","isString","prefixRange","postfixRange","wrappedInnerExpressions","exprContextRequest","exprContextRecursive","exprContextRegExp","exprContextCritical"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/dependencies/ContextDependencyHelpers.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { parseResource } = require(\"../util/identifier\");\n\n/** @typedef {import(\"estree\").Node} EsTreeNode */\n/** @typedef {import(\"../../declarations/WebpackOptions\").JavascriptParserOptions} JavascriptParserOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").ModuleOptionsNormalized} ModuleOptions */\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"../javascript/BasicEvaluatedExpression\")} BasicEvaluatedExpression */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n/** @typedef {import(\"./ContextDependency\")} ContextDependency */\n/** @typedef {import(\"./ContextDependency\").ContextDependencyOptions} ContextDependencyOptions */\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nconst quoteMeta = str => {\n\treturn str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\n/**\n * @param {string} prefix prefix\n * @returns {{prefix: string, context: string}} result\n */\nconst splitContextFromPrefix = prefix => {\n\tconst idx = prefix.lastIndexOf(\"/\");\n\tlet context = \".\";\n\tif (idx >= 0) {\n\t\tcontext = prefix.slice(0, idx);\n\t\tprefix = `.${prefix.slice(idx)}`;\n\t}\n\treturn {\n\t\tcontext,\n\t\tprefix\n\t};\n};\n\n/** @typedef {Partial<Omit<ContextDependencyOptions, \"resource\">>} PartialContextDependencyOptions */\n/** @typedef {{ new(options: ContextDependencyOptions, range: Range, valueRange: [number, number], ...args: any[]): ContextDependency }} ContextDependencyConstructor */\n\n/**\n * @param {ContextDependencyConstructor} Dep the Dependency class\n * @param {Range} range source range\n * @param {BasicEvaluatedExpression} param context param\n * @param {EsTreeNode} expr expr\n * @param {Pick<JavascriptParserOptions, `${\"expr\"|\"wrapped\"}Context${\"Critical\"|\"Recursive\"|\"RegExp\"}` | \"exprContextRequest\">} options options for context creation\n * @param {PartialContextDependencyOptions} contextOptions options for the ContextModule\n * @param {JavascriptParser} parser the parser\n * @param {...any} depArgs depArgs\n * @returns {ContextDependency} the created Dependency\n */\nexports.create = (\n\tDep,\n\trange,\n\tparam,\n\texpr,\n\toptions,\n\tcontextOptions,\n\tparser,\n\t...depArgs\n) => {\n\tif (param.isTemplateString()) {\n\t\tconst quasis = /** @type {BasicEvaluatedExpression[]} */ (param.quasis);\n\t\tlet prefixRaw = /** @type {string} */ (quasis[0].string);\n\t\tlet postfixRaw =\n\t\t\t/** @type {string} */\n\t\t\t(quasis.length > 1 ? quasis[quasis.length - 1].string : \"\");\n\n\t\tconst valueRange = /** @type {Range} */ (param.range);\n\t\tconst { context, prefix } = splitContextFromPrefix(prefixRaw);\n\t\tconst {\n\t\t\tpath: postfix,\n\t\t\tquery,\n\t\t\tfragment\n\t\t} = parseResource(postfixRaw, parser);\n\n\t\t// When there are more than two quasis, the generated RegExp can be more precise\n\t\t// We join the quasis with the expression regexp\n\t\tconst innerQuasis = quasis.slice(1, quasis.length - 1);\n\t\tconst innerRegExp =\n\t\t\t/** @type {RegExp} */ (options.wrappedContextRegExp).source +\n\t\t\tinnerQuasis\n\t\t\t\t.map(\n\t\t\t\t\tq =>\n\t\t\t\t\t\tquoteMeta(/** @type {string} */ (q.string)) +\n\t\t\t\t\t\t/** @type {RegExp} */ (options.wrappedContextRegExp).source\n\t\t\t\t)\n\t\t\t\t.join(\"\");\n\n\t\t// Example: `./context/pre${e}inner${e}inner2${e}post?query#frag`\n\t\t// context: \"./context\"\n\t\t// prefix: \"./pre\"\n\t\t// innerQuasis: [BEE(\"inner\"), BEE(\"inner2\")]\n\t\t// (BEE = BasicEvaluatedExpression)\n\t\t// postfix: \"post\"\n\t\t// query: \"?query\"\n\t\t// fragment: \"#frag\"\n\t\t// regExp: /^\\.\\/pre.*inner.*inner2.*post$/\n\t\tconst regExp = new RegExp(\n\t\t\t`^${quoteMeta(prefix)}${innerRegExp}${quoteMeta(postfix)}$`\n\t\t);\n\t\tconst dep = new Dep(\n\t\t\t{\n\t\t\t\trequest: context + query + fragment,\n\t\t\t\trecursive: /** @type {boolean} */ (options.wrappedContextRecursive),\n\t\t\t\tregExp,\n\t\t\t\tmode: \"sync\",\n\t\t\t\t...contextOptions\n\t\t\t},\n\t\t\trange,\n\t\t\tvalueRange,\n\t\t\t...depArgs\n\t\t);\n\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\n\t\t/** @type {{ value: string, range: Range }[]} */\n\t\tconst replaces = [];\n\t\tconst parts = /** @type {BasicEvaluatedExpression[]} */ (param.parts);\n\n\t\tparts.forEach((part, i) => {\n\t\t\tif (i % 2 === 0) {\n\t\t\t\t// Quasis or merged quasi\n\t\t\t\tlet range = /** @type {Range} */ (part.range);\n\t\t\t\tlet value = /** @type {string} */ (part.string);\n\t\t\t\tif (param.templateStringKind === \"cooked\") {\n\t\t\t\t\tvalue = JSON.stringify(value);\n\t\t\t\t\tvalue = value.slice(1, value.length - 1);\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\t// prefix\n\t\t\t\t\tvalue = prefix;\n\t\t\t\t\trange = [\n\t\t\t\t\t\t/** @type {Range} */ (param.range)[0],\n\t\t\t\t\t\t/** @type {Range} */ (part.range)[1]\n\t\t\t\t\t];\n\t\t\t\t\tvalue =\n\t\t\t\t\t\t(param.templateStringKind === \"cooked\" ? \"`\" : \"String.raw`\") +\n\t\t\t\t\t\tvalue;\n\t\t\t\t} else if (i === parts.length - 1) {\n\t\t\t\t\t// postfix\n\t\t\t\t\tvalue = postfix;\n\t\t\t\t\trange = [\n\t\t\t\t\t\t/** @type {Range} */ (part.range)[0],\n\t\t\t\t\t\t/** @type {Range} */ (param.range)[1]\n\t\t\t\t\t];\n\t\t\t\t\tvalue = value + \"`\";\n\t\t\t\t} else if (\n\t\t\t\t\tpart.expression &&\n\t\t\t\t\tpart.expression.type === \"TemplateElement\" &&\n\t\t\t\t\tpart.expression.value.raw === value\n\t\t\t\t) {\n\t\t\t\t\t// Shortcut when it's a single quasi and doesn't need to be replaced\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treplaces.push({\n\t\t\t\t\trange,\n\t\t\t\t\tvalue\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Expression\n\t\t\t\tparser.walkExpression(part.expression);\n\t\t\t}\n\t\t});\n\n\t\tdep.replaces = replaces;\n\t\tdep.critical =\n\t\t\toptions.wrappedContextCritical &&\n\t\t\t\"a part of the request of a dependency is an expression\";\n\t\treturn dep;\n\t} else if (\n\t\tparam.isWrapped() &&\n\t\t((param.prefix && param.prefix.isString()) ||\n\t\t\t(param.postfix && param.postfix.isString()))\n\t) {\n\t\tlet prefixRaw =\n\t\t\t/** @type {string} */\n\t\t\t(param.prefix && param.prefix.isString() ? param.prefix.string : \"\");\n\t\tlet postfixRaw =\n\t\t\t/** @type {string} */\n\t\t\t(param.postfix && param.postfix.isString() ? param.postfix.string : \"\");\n\t\tconst prefixRange =\n\t\t\tparam.prefix && param.prefix.isString() ? param.prefix.range : null;\n\t\tconst postfixRange =\n\t\t\tparam.postfix && param.postfix.isString() ? param.postfix.range : null;\n\t\tconst valueRange = /** @type {Range} */ (param.range);\n\t\tconst { context, prefix } = splitContextFromPrefix(prefixRaw);\n\t\tconst {\n\t\t\tpath: postfix,\n\t\t\tquery,\n\t\t\tfragment\n\t\t} = parseResource(postfixRaw, parser);\n\t\tconst regExp = new RegExp(\n\t\t\t`^${quoteMeta(prefix)}${\n\t\t\t\t/** @type {RegExp} */ (options.wrappedContextRegExp).source\n\t\t\t}${quoteMeta(postfix)}$`\n\t\t);\n\t\tconst dep = new Dep(\n\t\t\t{\n\t\t\t\trequest: context + query + fragment,\n\t\t\t\trecursive: /** @type {boolean} */ (options.wrappedContextRecursive),\n\t\t\t\tregExp,\n\t\t\t\tmode: \"sync\",\n\t\t\t\t...contextOptions\n\t\t\t},\n\t\t\trange,\n\t\t\tvalueRange,\n\t\t\t...depArgs\n\t\t);\n\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\tconst replaces = [];\n\t\tif (prefixRange) {\n\t\t\treplaces.push({\n\t\t\t\trange: prefixRange,\n\t\t\t\tvalue: JSON.stringify(prefix)\n\t\t\t});\n\t\t}\n\t\tif (postfixRange) {\n\t\t\treplaces.push({\n\t\t\t\trange: postfixRange,\n\t\t\t\tvalue: JSON.stringify(postfix)\n\t\t\t});\n\t\t}\n\t\tdep.replaces = replaces;\n\t\tdep.critical =\n\t\t\toptions.wrappedContextCritical &&\n\t\t\t\"a part of the request of a dependency is an expression\";\n\n\t\tif (parser && param.wrappedInnerExpressions) {\n\t\t\tfor (const part of param.wrappedInnerExpressions) {\n\t\t\t\tif (part.expression) parser.walkExpression(part.expression);\n\t\t\t}\n\t\t}\n\n\t\treturn dep;\n\t} else {\n\t\tconst dep = new Dep(\n\t\t\t{\n\t\t\t\trequest: /** @type {string} */ (options.exprContextRequest),\n\t\t\t\trecursive: /** @type {boolean} */ (options.exprContextRecursive),\n\t\t\t\tregExp: /** @type {RegExp} */ (options.exprContextRegExp),\n\t\t\t\tmode: \"sync\",\n\t\t\t\t...contextOptions\n\t\t\t},\n\t\t\trange,\n\t\t\t/** @type {Range} */ (param.range),\n\t\t\t...depArgs\n\t\t);\n\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\tdep.critical =\n\t\t\toptions.exprContextCritical &&\n\t\t\t\"the request of a dependency is an expression\";\n\n\t\tparser.walkExpression(param.expression);\n\n\t\treturn dep;\n\t}\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAM;EAAEA;AAAc,CAAC,GAAGC,OAAO,CAAC,oBAAoB,CAAC;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMC,SAAS,GAAGC,GAAG,IAAI;EACxB,OAAOA,GAAG,CAACC,OAAO,CAAC,uBAAuB,EAAE,MAAM,CAAC;AACpD,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMC,sBAAsB,GAAGC,MAAM,IAAI;EACxC,MAAMC,GAAG,GAAGD,MAAM,CAACE,WAAW,CAAC,GAAG,CAAC;EACnC,IAAIC,OAAO,GAAG,GAAG;EACjB,IAAIF,GAAG,IAAI,CAAC,EAAE;IACbE,OAAO,GAAGH,MAAM,CAACI,KAAK,CAAC,CAAC,EAAEH,GAAG,CAAC;IAC9BD,MAAM,GAAG,IAAIA,MAAM,CAACI,KAAK,CAACH,GAAG,CAAC,EAAE;EACjC;EACA,OAAO;IACNE,OAAO;IACPH;EACD,CAAC;AACF,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAK,OAAO,CAACC,MAAM,GAAG,CAChBC,GAAG,EACHC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,OAAO,EACPC,cAAc,EACdC,MAAM,EACN,GAAGC,OAAO,KACN;EACJ,IAAIL,KAAK,CAACM,gBAAgB,CAAC,CAAC,EAAE;IAC7B,MAAMC,MAAM,GAAG,yCAA2CP,KAAK,CAACO,MAAO;IACvE,IAAIC,SAAS,GAAG,qBAAuBD,MAAM,CAAC,CAAC,CAAC,CAACE,MAAO;IACxD,IAAIC,UAAU,GACb;IACCH,MAAM,CAACI,MAAM,GAAG,CAAC,GAAGJ,MAAM,CAACA,MAAM,CAACI,MAAM,GAAG,CAAC,CAAC,CAACF,MAAM,GAAG,EAAG;IAE5D,MAAMG,UAAU,GAAG,oBAAsBZ,KAAK,CAACD,KAAM;IACrD,MAAM;MAAEL,OAAO;MAAEH;IAAO,CAAC,GAAGD,sBAAsB,CAACkB,SAAS,CAAC;IAC7D,MAAM;MACLK,IAAI,EAAEC,OAAO;MACbC,KAAK;MACLC;IACD,CAAC,GAAG/B,aAAa,CAACyB,UAAU,EAAEN,MAAM,CAAC;;IAErC;IACA;IACA,MAAMa,WAAW,GAAGV,MAAM,CAACZ,KAAK,CAAC,CAAC,EAAEY,MAAM,CAACI,MAAM,GAAG,CAAC,CAAC;IACtD,MAAMO,WAAW,GAChB,qBAAuBhB,OAAO,CAACiB,oBAAoB,CAAEC,MAAM,GAC3DH,WAAW,CACTI,GAAG,CACHC,CAAC,IACAnC,SAAS,EAAC,qBAAuBmC,CAAC,CAACb,MAAO,CAAC,GAC3C,qBAAuBP,OAAO,CAACiB,oBAAoB,CAAEC,MACvD,CAAC,CACAG,IAAI,CAAC,EAAE,CAAC;;IAEX;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,MAAMC,MAAM,GAAG,IAAIC,MAAM,CACxB,IAAItC,SAAS,CAACI,MAAM,CAAC,GAAG2B,WAAW,GAAG/B,SAAS,CAAC2B,OAAO,CAAC,GACzD,CAAC;IACD,MAAMY,GAAG,GAAG,IAAI5B,GAAG,CAClB;MACC6B,OAAO,EAAEjC,OAAO,GAAGqB,KAAK,GAAGC,QAAQ;MACnCY,SAAS,IAAE,sBAAwB1B,OAAO,CAAC2B,uBAAuB,CAAC;MACnEL,MAAM;MACNM,IAAI,EAAE,MAAM;MACZ,GAAG3B;IACJ,CAAC,EACDJ,KAAK,EACLa,UAAU,EACV,GAAGP,OACJ,CAAC;IACDqB,GAAG,CAACK,GAAG,GAAG,iCAAmC9B,IAAI,CAAC8B,GAAI;;IAEtD;IACA,MAAMC,QAAQ,GAAG,EAAE;IACnB,MAAMC,KAAK,GAAG,yCAA2CjC,KAAK,CAACiC,KAAM;IAErEA,KAAK,CAACC,OAAO,CAAC,CAACC,IAAI,EAAEC,CAAC,KAAK;MAC1B,IAAIA,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;QAChB;QACA,IAAIrC,KAAK,GAAG,oBAAsBoC,IAAI,CAACpC,KAAM;QAC7C,IAAIsC,KAAK,GAAG,qBAAuBF,IAAI,CAAC1B,MAAO;QAC/C,IAAIT,KAAK,CAACsC,kBAAkB,KAAK,QAAQ,EAAE;UAC1CD,KAAK,GAAGE,IAAI,CAACC,SAAS,CAACH,KAAK,CAAC;UAC7BA,KAAK,GAAGA,KAAK,CAAC1C,KAAK,CAAC,CAAC,EAAE0C,KAAK,CAAC1B,MAAM,GAAG,CAAC,CAAC;QACzC;QACA,IAAIyB,CAAC,KAAK,CAAC,EAAE;UACZ;UACAC,KAAK,GAAG9C,MAAM;UACdQ,KAAK,GAAG,CACP,oBAAsBC,KAAK,CAACD,KAAK,CAAE,CAAC,CAAC,EACrC,oBAAsBoC,IAAI,CAACpC,KAAK,CAAE,CAAC,CAAC,CACpC;UACDsC,KAAK,GACJ,CAACrC,KAAK,CAACsC,kBAAkB,KAAK,QAAQ,GAAG,GAAG,GAAG,aAAa,IAC5DD,KAAK;QACP,CAAC,MAAM,IAAID,CAAC,KAAKH,KAAK,CAACtB,MAAM,GAAG,CAAC,EAAE;UAClC;UACA0B,KAAK,GAAGvB,OAAO;UACff,KAAK,GAAG,CACP,oBAAsBoC,IAAI,CAACpC,KAAK,CAAE,CAAC,CAAC,EACpC,oBAAsBC,KAAK,CAACD,KAAK,CAAE,CAAC,CAAC,CACrC;UACDsC,KAAK,GAAGA,KAAK,GAAG,GAAG;QACpB,CAAC,MAAM,IACNF,IAAI,CAACM,UAAU,IACfN,IAAI,CAACM,UAAU,CAACC,IAAI,KAAK,iBAAiB,IAC1CP,IAAI,CAACM,UAAU,CAACJ,KAAK,CAACM,GAAG,KAAKN,KAAK,EAClC;UACD;UACA;QACD;QACAL,QAAQ,CAACY,IAAI,CAAC;UACb7C,KAAK;UACLsC;QACD,CAAC,CAAC;MACH,CAAC,MAAM;QACN;QACAjC,MAAM,CAACyC,cAAc,CAACV,IAAI,CAACM,UAAU,CAAC;MACvC;IACD,CAAC,CAAC;IAEFf,GAAG,CAACM,QAAQ,GAAGA,QAAQ;IACvBN,GAAG,CAACoB,QAAQ,GACX5C,OAAO,CAAC6C,sBAAsB,IAC9B,wDAAwD;IACzD,OAAOrB,GAAG;EACX,CAAC,MAAM,IACN1B,KAAK,CAACgD,SAAS,CAAC,CAAC,KACfhD,KAAK,CAACT,MAAM,IAAIS,KAAK,CAACT,MAAM,CAAC0D,QAAQ,CAAC,CAAC,IACvCjD,KAAK,CAACc,OAAO,IAAId,KAAK,CAACc,OAAO,CAACmC,QAAQ,CAAC,CAAE,CAAC,EAC5C;IACD,IAAIzC,SAAS,GACZ;IACCR,KAAK,CAACT,MAAM,IAAIS,KAAK,CAACT,MAAM,CAAC0D,QAAQ,CAAC,CAAC,GAAGjD,KAAK,CAACT,MAAM,CAACkB,MAAM,GAAG,EAAG;IACrE,IAAIC,UAAU,GACb;IACCV,KAAK,CAACc,OAAO,IAAId,KAAK,CAACc,OAAO,CAACmC,QAAQ,CAAC,CAAC,GAAGjD,KAAK,CAACc,OAAO,CAACL,MAAM,GAAG,EAAG;IACxE,MAAMyC,WAAW,GAChBlD,KAAK,CAACT,MAAM,IAAIS,KAAK,CAACT,MAAM,CAAC0D,QAAQ,CAAC,CAAC,GAAGjD,KAAK,CAACT,MAAM,CAACQ,KAAK,GAAG,IAAI;IACpE,MAAMoD,YAAY,GACjBnD,KAAK,CAACc,OAAO,IAAId,KAAK,CAACc,OAAO,CAACmC,QAAQ,CAAC,CAAC,GAAGjD,KAAK,CAACc,OAAO,CAACf,KAAK,GAAG,IAAI;IACvE,MAAMa,UAAU,GAAG,oBAAsBZ,KAAK,CAACD,KAAM;IACrD,MAAM;MAAEL,OAAO;MAAEH;IAAO,CAAC,GAAGD,sBAAsB,CAACkB,SAAS,CAAC;IAC7D,MAAM;MACLK,IAAI,EAAEC,OAAO;MACbC,KAAK;MACLC;IACD,CAAC,GAAG/B,aAAa,CAACyB,UAAU,EAAEN,MAAM,CAAC;IACrC,MAAMoB,MAAM,GAAG,IAAIC,MAAM,CACxB,IAAItC,SAAS,CAACI,MAAM,CAAC,GACpB,qBAAuBW,OAAO,CAACiB,oBAAoB,CAAEC,MAAM,GACzDjC,SAAS,CAAC2B,OAAO,CAAC,GACtB,CAAC;IACD,MAAMY,GAAG,GAAG,IAAI5B,GAAG,CAClB;MACC6B,OAAO,EAAEjC,OAAO,GAAGqB,KAAK,GAAGC,QAAQ;MACnCY,SAAS,IAAE,sBAAwB1B,OAAO,CAAC2B,uBAAuB,CAAC;MACnEL,MAAM;MACNM,IAAI,EAAE,MAAM;MACZ,GAAG3B;IACJ,CAAC,EACDJ,KAAK,EACLa,UAAU,EACV,GAAGP,OACJ,CAAC;IACDqB,GAAG,CAACK,GAAG,GAAG,iCAAmC9B,IAAI,CAAC8B,GAAI;IACtD,MAAMC,QAAQ,GAAG,EAAE;IACnB,IAAIkB,WAAW,EAAE;MAChBlB,QAAQ,CAACY,IAAI,CAAC;QACb7C,KAAK,EAAEmD,WAAW;QAClBb,KAAK,EAAEE,IAAI,CAACC,SAAS,CAACjD,MAAM;MAC7B,CAAC,CAAC;IACH;IACA,IAAI4D,YAAY,EAAE;MACjBnB,QAAQ,CAACY,IAAI,CAAC;QACb7C,KAAK,EAAEoD,YAAY;QACnBd,KAAK,EAAEE,IAAI,CAACC,SAAS,CAAC1B,OAAO;MAC9B,CAAC,CAAC;IACH;IACAY,GAAG,CAACM,QAAQ,GAAGA,QAAQ;IACvBN,GAAG,CAACoB,QAAQ,GACX5C,OAAO,CAAC6C,sBAAsB,IAC9B,wDAAwD;IAEzD,IAAI3C,MAAM,IAAIJ,KAAK,CAACoD,uBAAuB,EAAE;MAC5C,KAAK,MAAMjB,IAAI,IAAInC,KAAK,CAACoD,uBAAuB,EAAE;QACjD,IAAIjB,IAAI,CAACM,UAAU,EAAErC,MAAM,CAACyC,cAAc,CAACV,IAAI,CAACM,UAAU,CAAC;MAC5D;IACD;IAEA,OAAOf,GAAG;EACX,CAAC,MAAM;IACN,MAAMA,GAAG,GAAG,IAAI5B,GAAG,CAClB;MACC6B,OAAO,IAAE,qBAAuBzB,OAAO,CAACmD,kBAAkB,CAAC;MAC3DzB,SAAS,IAAE,sBAAwB1B,OAAO,CAACoD,oBAAoB,CAAC;MAChE9B,MAAM,IAAE,qBAAuBtB,OAAO,CAACqD,iBAAiB,CAAC;MACzDzB,IAAI,EAAE,MAAM;MACZ,GAAG3B;IACJ,CAAC,EACDJ,KAAK,EACL,oBAAsBC,KAAK,CAACD,KAAK,EACjC,GAAGM,OACJ,CAAC;IACDqB,GAAG,CAACK,GAAG,GAAG,iCAAmC9B,IAAI,CAAC8B,GAAI;IACtDL,GAAG,CAACoB,QAAQ,GACX5C,OAAO,CAACsD,mBAAmB,IAC3B,8CAA8C;IAE/CpD,MAAM,CAACyC,cAAc,CAAC7C,KAAK,CAACyC,UAAU,CAAC;IAEvC,OAAOf,GAAG;EACX;AACD,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  getOrInsert\n} = require(\"./util/MapHelpers\");\nconst {\n  first\n} = require(\"./util/SetHelpers\");\nconst createHash = require(\"./util/createHash\");\nconst {\n  runtimeToString,\n  RuntimeSpecMap\n} = require(\"./util/runtime\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./Module\").CodeGenerationResult} CodeGenerationResult */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nclass CodeGenerationResults {\n  /**\n   * @param {string | Hash} hashFunction the hash function to use\n   */\n  constructor(hashFunction = \"md4\") {\n    /** @type {Map<Module, RuntimeSpecMap<CodeGenerationResult>>} */\n    this.map = new Map();\n    this._hashFunction = hashFunction;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @returns {CodeGenerationResult} the CodeGenerationResult\n   */\n  get(module, runtime) {\n    const entry = this.map.get(module);\n    if (entry === undefined) {\n      throw new Error(`No code generation entry for ${module.identifier()} (existing entries: ${Array.from(this.map.keys(), m => m.identifier()).join(\", \")})`);\n    }\n    if (runtime === undefined) {\n      if (entry.size > 1) {\n        const results = new Set(entry.values());\n        if (results.size !== 1) {\n          throw new Error(`No unique code generation entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(entry.keys(), r => runtimeToString(r)).join(\", \")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \"global\").`);\n        }\n        return first(results);\n      }\n      return entry.values().next().value;\n    }\n    const result = entry.get(runtime);\n    if (result === undefined) {\n      throw new Error(`No code generation entry for runtime ${runtimeToString(runtime)} for ${module.identifier()} (existing runtimes: ${Array.from(entry.keys(), r => runtimeToString(r)).join(\", \")})`);\n    }\n    return result;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @returns {boolean} true, when we have data for this\n   */\n  has(module, runtime) {\n    const entry = this.map.get(module);\n    if (entry === undefined) {\n      return false;\n    }\n    if (runtime !== undefined) {\n      return entry.has(runtime);\n    } else if (entry.size > 1) {\n      const results = new Set(entry.values());\n      return results.size === 1;\n    } else {\n      return entry.size === 1;\n    }\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @param {string} sourceType the source type\n   * @returns {Source} a source\n   */\n  getSource(module, runtime, sourceType) {\n    return this.get(module, runtime).sources.get(sourceType);\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @returns {ReadonlySet<string>} runtime requirements\n   */\n  getRuntimeRequirements(module, runtime) {\n    return this.get(module, runtime).runtimeRequirements;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @param {string} key data key\n   * @returns {any} data generated by code generation\n   */\n  getData(module, runtime, key) {\n    const data = this.get(module, runtime).data;\n    return data === undefined ? undefined : data.get(key);\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @returns {any} hash of the code generation\n   */\n  getHash(module, runtime) {\n    const info = this.get(module, runtime);\n    if (info.hash !== undefined) return info.hash;\n    const hash = createHash(this._hashFunction);\n    for (const [type, source] of info.sources) {\n      hash.update(type);\n      source.updateHash(hash);\n    }\n    if (info.runtimeRequirements) {\n      for (const rr of info.runtimeRequirements) hash.update(rr);\n    }\n    return info.hash = /** @type {string} */hash.digest(\"hex\");\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @param {CodeGenerationResult} result result from module\n   * @returns {void}\n   */\n  add(module, runtime, result) {\n    const map = getOrInsert(this.map, module, () => new RuntimeSpecMap());\n    map.set(runtime, result);\n  }\n}\nmodule.exports = CodeGenerationResults;","map":{"version":3,"names":["getOrInsert","require","first","createHash","runtimeToString","RuntimeSpecMap","CodeGenerationResults","constructor","hashFunction","map","Map","_hashFunction","get","module","runtime","entry","undefined","Error","identifier","Array","from","keys","m","join","size","results","Set","values","r","next","value","result","has","getSource","sourceType","sources","getRuntimeRequirements","runtimeRequirements","getData","key","data","getHash","info","hash","type","source","update","updateHash","rr","digest","add","set","exports"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/CodeGenerationResults.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { getOrInsert } = require(\"./util/MapHelpers\");\nconst { first } = require(\"./util/SetHelpers\");\nconst createHash = require(\"./util/createHash\");\nconst { runtimeToString, RuntimeSpecMap } = require(\"./util/runtime\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./Module\").CodeGenerationResult} CodeGenerationResult */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nclass CodeGenerationResults {\n\t/**\n\t * @param {string | Hash} hashFunction the hash function to use\n\t */\n\tconstructor(hashFunction = \"md4\") {\n\t\t/** @type {Map<Module, RuntimeSpecMap<CodeGenerationResult>>} */\n\t\tthis.map = new Map();\n\t\tthis._hashFunction = hashFunction;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @returns {CodeGenerationResult} the CodeGenerationResult\n\t */\n\tget(module, runtime) {\n\t\tconst entry = this.map.get(module);\n\t\tif (entry === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t`No code generation entry for ${module.identifier()} (existing entries: ${Array.from(\n\t\t\t\t\tthis.map.keys(),\n\t\t\t\t\tm => m.identifier()\n\t\t\t\t).join(\", \")})`\n\t\t\t);\n\t\t}\n\t\tif (runtime === undefined) {\n\t\t\tif (entry.size > 1) {\n\t\t\t\tconst results = new Set(entry.values());\n\t\t\t\tif (results.size !== 1) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`No unique code generation entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(\n\t\t\t\t\t\t\tentry.keys(),\n\t\t\t\t\t\t\tr => runtimeToString(r)\n\t\t\t\t\t\t).join(\", \")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \"global\").`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn first(results);\n\t\t\t}\n\t\t\treturn entry.values().next().value;\n\t\t}\n\t\tconst result = entry.get(runtime);\n\t\tif (result === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t`No code generation entry for runtime ${runtimeToString(\n\t\t\t\t\truntime\n\t\t\t\t)} for ${module.identifier()} (existing runtimes: ${Array.from(\n\t\t\t\t\tentry.keys(),\n\t\t\t\t\tr => runtimeToString(r)\n\t\t\t\t).join(\", \")})`\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @returns {boolean} true, when we have data for this\n\t */\n\thas(module, runtime) {\n\t\tconst entry = this.map.get(module);\n\t\tif (entry === undefined) {\n\t\t\treturn false;\n\t\t}\n\t\tif (runtime !== undefined) {\n\t\t\treturn entry.has(runtime);\n\t\t} else if (entry.size > 1) {\n\t\t\tconst results = new Set(entry.values());\n\t\t\treturn results.size === 1;\n\t\t} else {\n\t\t\treturn entry.size === 1;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @param {string} sourceType the source type\n\t * @returns {Source} a source\n\t */\n\tgetSource(module, runtime, sourceType) {\n\t\treturn this.get(module, runtime).sources.get(sourceType);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetRuntimeRequirements(module, runtime) {\n\t\treturn this.get(module, runtime).runtimeRequirements;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @param {string} key data key\n\t * @returns {any} data generated by code generation\n\t */\n\tgetData(module, runtime, key) {\n\t\tconst data = this.get(module, runtime).data;\n\t\treturn data === undefined ? undefined : data.get(key);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @returns {any} hash of the code generation\n\t */\n\tgetHash(module, runtime) {\n\t\tconst info = this.get(module, runtime);\n\t\tif (info.hash !== undefined) return info.hash;\n\t\tconst hash = createHash(this._hashFunction);\n\t\tfor (const [type, source] of info.sources) {\n\t\t\thash.update(type);\n\t\t\tsource.updateHash(hash);\n\t\t}\n\t\tif (info.runtimeRequirements) {\n\t\t\tfor (const rr of info.runtimeRequirements) hash.update(rr);\n\t\t}\n\t\treturn (info.hash = /** @type {string} */ (hash.digest(\"hex\")));\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @param {CodeGenerationResult} result result from module\n\t * @returns {void}\n\t */\n\tadd(module, runtime, result) {\n\t\tconst map = getOrInsert(this.map, module, () => new RuntimeSpecMap());\n\t\tmap.set(runtime, result);\n\t}\n}\n\nmodule.exports = CodeGenerationResults;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
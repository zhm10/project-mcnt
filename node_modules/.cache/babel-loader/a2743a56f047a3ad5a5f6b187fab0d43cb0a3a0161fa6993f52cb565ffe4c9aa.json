{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst createHash = require(\"../util/createHash\");\nconst ArraySerializer = require(\"./ArraySerializer\");\nconst DateObjectSerializer = require(\"./DateObjectSerializer\");\nconst ErrorObjectSerializer = require(\"./ErrorObjectSerializer\");\nconst MapObjectSerializer = require(\"./MapObjectSerializer\");\nconst NullPrototypeObjectSerializer = require(\"./NullPrototypeObjectSerializer\");\nconst PlainObjectSerializer = require(\"./PlainObjectSerializer\");\nconst RegExpObjectSerializer = require(\"./RegExpObjectSerializer\");\nconst SerializerMiddleware = require(\"./SerializerMiddleware\");\nconst SetObjectSerializer = require(\"./SetObjectSerializer\");\n\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n/** @typedef {import(\"./types\").ComplexSerializableType} ComplexSerializableType */\n/** @typedef {import(\"./types\").PrimitiveSerializableType} PrimitiveSerializableType */\n\n/** @typedef {new (...params: any[]) => any} Constructor */\n\n/*\n\nFormat:\n\nFile -> Section*\nSection -> ObjectSection | ReferenceSection | EscapeSection | OtherSection\n\nObjectSection -> ESCAPE (\n\tnumber:relativeOffset (number > 0) |\n\tstring:request (string|null):export\n) Section:value* ESCAPE ESCAPE_END_OBJECT\nReferenceSection -> ESCAPE number:relativeOffset (number < 0)\nEscapeSection -> ESCAPE ESCAPE_ESCAPE_VALUE (escaped value ESCAPE)\nEscapeSection -> ESCAPE ESCAPE_UNDEFINED (escaped value ESCAPE)\nOtherSection -> any (except ESCAPE)\n\nWhy using null as escape value?\nMultiple null values can merged by the BinaryMiddleware, which makes it very efficient\nTechnically any value can be used.\n\n*/\n\n/**\n * @typedef {Object} ObjectSerializerContext\n * @property {function(any): void} write\n * @property {(function(any): void)=} writeLazy\n * @property {(function(any, object=): (() => Promise<any> | any))=} writeSeparate\n * @property {function(any): void} setCircularReference\n */\n\n/**\n * @typedef {Object} ObjectDeserializerContext\n * @property {function(): any} read\n * @property {function(any): void} setCircularReference\n */\n\n/**\n * @typedef {Object} ObjectSerializer\n * @property {function(any, ObjectSerializerContext): void} serialize\n * @property {function(ObjectDeserializerContext): any} deserialize\n */\n\n/**\n * @template T\n * @param {Set<T>} set set\n * @param {number} size count of items to keep\n */\nconst setSetSize = (set, size) => {\n  let i = 0;\n  for (const item of set) {\n    if (i++ >= size) {\n      set.delete(item);\n    }\n  }\n};\n\n/**\n * @template K, X\n * @param {Map<K, X>} map map\n * @param {number} size count of items to keep\n */\nconst setMapSize = (map, size) => {\n  let i = 0;\n  for (const item of map.keys()) {\n    if (i++ >= size) {\n      map.delete(item);\n    }\n  }\n};\n\n/**\n * @param {Buffer} buffer buffer\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\nconst toHash = (buffer, hashFunction) => {\n  const hash = createHash(hashFunction);\n  hash.update(buffer);\n  return /** @type {string} */hash.digest(\"latin1\");\n};\nconst ESCAPE = null;\nconst ESCAPE_ESCAPE_VALUE = null;\nconst ESCAPE_END_OBJECT = true;\nconst ESCAPE_UNDEFINED = false;\nconst CURRENT_VERSION = 2;\n\n/** @type {Map<Constructor, { request?: string, name?: string | number | null, serializer?: ObjectSerializer }>} */\nconst serializers = new Map();\n/** @type {Map<string | number, ObjectSerializer>} */\nconst serializerInversed = new Map();\n\n/** @type {Set<string>} */\nconst loadedRequests = new Set();\nconst NOT_SERIALIZABLE = {};\nconst jsTypes = new Map();\njsTypes.set(Object, new PlainObjectSerializer());\njsTypes.set(Array, new ArraySerializer());\njsTypes.set(null, new NullPrototypeObjectSerializer());\njsTypes.set(Map, new MapObjectSerializer());\njsTypes.set(Set, new SetObjectSerializer());\njsTypes.set(Date, new DateObjectSerializer());\njsTypes.set(RegExp, new RegExpObjectSerializer());\njsTypes.set(Error, new ErrorObjectSerializer(Error));\njsTypes.set(EvalError, new ErrorObjectSerializer(EvalError));\njsTypes.set(RangeError, new ErrorObjectSerializer(RangeError));\njsTypes.set(ReferenceError, new ErrorObjectSerializer(ReferenceError));\njsTypes.set(SyntaxError, new ErrorObjectSerializer(SyntaxError));\njsTypes.set(TypeError, new ErrorObjectSerializer(TypeError));\n\n// If in a sandboxed environment (e. g. jest), this escapes the sandbox and registers\n// real Object and Array types to. These types may occur in the wild too, e. g. when\n// using Structured Clone in postMessage.\nif (exports.constructor !== Object) {\n  const Obj = /** @type {typeof Object} */exports.constructor;\n  const Fn = /** @type {typeof Function} */Obj.constructor;\n  for (const [type, config] of Array.from(jsTypes)) {\n    if (type) {\n      const Type = new Fn(`return ${type.name};`)();\n      jsTypes.set(Type, config);\n    }\n  }\n}\n{\n  let i = 1;\n  for (const [type, serializer] of jsTypes) {\n    serializers.set(type, {\n      request: \"\",\n      name: i++,\n      serializer\n    });\n  }\n}\nfor (const {\n  request,\n  name,\n  serializer\n} of serializers.values()) {\n  serializerInversed.set(`${request}/${name}`, /** @type {ObjectSerializer} */serializer);\n}\n\n/** @type {Map<RegExp, (request: string) => boolean>} */\nconst loaders = new Map();\n\n/**\n * @typedef {ComplexSerializableType[]} DeserializedType\n * @typedef {PrimitiveSerializableType[]} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\nclass ObjectMiddleware extends SerializerMiddleware {\n  /**\n   * @param {function(any): void} extendContext context extensions\n   * @param {string | Hash} hashFunction hash function to use\n   */\n  constructor(extendContext, hashFunction = \"md4\") {\n    super();\n    this.extendContext = extendContext;\n    this._hashFunction = hashFunction;\n  }\n  /**\n   * @param {RegExp} regExp RegExp for which the request is tested\n   * @param {function(string): boolean} loader loader to load the request, returns true when successful\n   * @returns {void}\n   */\n  static registerLoader(regExp, loader) {\n    loaders.set(regExp, loader);\n  }\n\n  /**\n   * @param {Constructor} Constructor the constructor\n   * @param {string} request the request which will be required when deserializing\n   * @param {string | null} name the name to make multiple serializer unique when sharing a request\n   * @param {ObjectSerializer} serializer the serializer\n   * @returns {void}\n   */\n  static register(Constructor, request, name, serializer) {\n    const key = request + \"/\" + name;\n    if (serializers.has(Constructor)) {\n      throw new Error(`ObjectMiddleware.register: serializer for ${Constructor.name} is already registered`);\n    }\n    if (serializerInversed.has(key)) {\n      throw new Error(`ObjectMiddleware.register: serializer for ${key} is already registered`);\n    }\n    serializers.set(Constructor, {\n      request,\n      name,\n      serializer\n    });\n    serializerInversed.set(key, serializer);\n  }\n\n  /**\n   * @param {Constructor} Constructor the constructor\n   * @returns {void}\n   */\n  static registerNotSerializable(Constructor) {\n    if (serializers.has(Constructor)) {\n      throw new Error(`ObjectMiddleware.registerNotSerializable: serializer for ${Constructor.name} is already registered`);\n    }\n    serializers.set(Constructor, NOT_SERIALIZABLE);\n  }\n  static getSerializerFor(object) {\n    const proto = Object.getPrototypeOf(object);\n    let c;\n    if (proto === null) {\n      // Object created with Object.create(null)\n      c = null;\n    } else {\n      c = proto.constructor;\n      if (!c) {\n        throw new Error(\"Serialization of objects with prototype without valid constructor property not possible\");\n      }\n    }\n    const config = serializers.get(c);\n    if (!config) throw new Error(`No serializer registered for ${c.name}`);\n    if (config === NOT_SERIALIZABLE) throw NOT_SERIALIZABLE;\n    return config;\n  }\n\n  /**\n   * @param {string} request request\n   * @param {TODO} name name\n   * @returns {ObjectSerializer} serializer\n   */\n  static getDeserializerFor(request, name) {\n    const key = request + \"/\" + name;\n    const serializer = serializerInversed.get(key);\n    if (serializer === undefined) {\n      throw new Error(`No deserializer registered for ${key}`);\n    }\n    return serializer;\n  }\n\n  /**\n   * @param {string} request request\n   * @param {TODO} name name\n   * @returns {ObjectSerializer} serializer\n   */\n  static _getDeserializerForWithoutError(request, name) {\n    const key = request + \"/\" + name;\n    const serializer = serializerInversed.get(key);\n    return serializer;\n  }\n\n  /**\n   * @param {DeserializedType} data data\n   * @param {Object} context context object\n   * @returns {SerializedType|Promise<SerializedType>} serialized data\n   */\n  serialize(data, context) {\n    /** @type {any[]} */\n    let result = [CURRENT_VERSION];\n    let currentPos = 0;\n    let referenceable = new Map();\n    const addReferenceable = item => {\n      referenceable.set(item, currentPos++);\n    };\n    let bufferDedupeMap = new Map();\n    const dedupeBuffer = buf => {\n      const len = buf.length;\n      const entry = bufferDedupeMap.get(len);\n      if (entry === undefined) {\n        bufferDedupeMap.set(len, buf);\n        return buf;\n      }\n      if (Buffer.isBuffer(entry)) {\n        if (len < 32) {\n          if (buf.equals(entry)) {\n            return entry;\n          }\n          bufferDedupeMap.set(len, [entry, buf]);\n          return buf;\n        } else {\n          const hash = toHash(entry, this._hashFunction);\n          const newMap = new Map();\n          newMap.set(hash, entry);\n          bufferDedupeMap.set(len, newMap);\n          const hashBuf = toHash(buf, this._hashFunction);\n          if (hash === hashBuf) {\n            return entry;\n          }\n          return buf;\n        }\n      } else if (Array.isArray(entry)) {\n        if (entry.length < 16) {\n          for (const item of entry) {\n            if (buf.equals(item)) {\n              return item;\n            }\n          }\n          entry.push(buf);\n          return buf;\n        } else {\n          const newMap = new Map();\n          const hash = toHash(buf, this._hashFunction);\n          let found;\n          for (const item of entry) {\n            const itemHash = toHash(item, this._hashFunction);\n            newMap.set(itemHash, item);\n            if (found === undefined && itemHash === hash) found = item;\n          }\n          bufferDedupeMap.set(len, newMap);\n          if (found === undefined) {\n            newMap.set(hash, buf);\n            return buf;\n          } else {\n            return found;\n          }\n        }\n      } else {\n        const hash = toHash(buf, this._hashFunction);\n        const item = entry.get(hash);\n        if (item !== undefined) {\n          return item;\n        }\n        entry.set(hash, buf);\n        return buf;\n      }\n    };\n    let currentPosTypeLookup = 0;\n    let objectTypeLookup = new Map();\n    const cycleStack = new Set();\n    const stackToString = item => {\n      const arr = Array.from(cycleStack);\n      arr.push(item);\n      return arr.map(item => {\n        if (typeof item === \"string\") {\n          if (item.length > 100) {\n            return `String ${JSON.stringify(item.slice(0, 100)).slice(0, -1)}...\"`;\n          }\n          return `String ${JSON.stringify(item)}`;\n        }\n        try {\n          const {\n            request,\n            name\n          } = ObjectMiddleware.getSerializerFor(item);\n          if (request) {\n            return `${request}${name ? `.${name}` : \"\"}`;\n          }\n        } catch (e) {\n          // ignore -> fallback\n        }\n        if (typeof item === \"object\" && item !== null) {\n          if (item.constructor) {\n            if (item.constructor === Object) return `Object { ${Object.keys(item).join(\", \")} }`;\n            if (item.constructor === Map) return `Map { ${item.size} items }`;\n            if (item.constructor === Array) return `Array { ${item.length} items }`;\n            if (item.constructor === Set) return `Set { ${item.size} items }`;\n            if (item.constructor === RegExp) return item.toString();\n            return `${item.constructor.name}`;\n          }\n          return `Object [null prototype] { ${Object.keys(item).join(\", \")} }`;\n        }\n        if (typeof item === \"bigint\") {\n          return `BigInt ${item}n`;\n        }\n        try {\n          return `${item}`;\n        } catch (e) {\n          return `(${e.message})`;\n        }\n      }).join(\" -> \");\n    };\n    let hasDebugInfoAttached;\n    let ctx = {\n      write(value, key) {\n        try {\n          process(value);\n        } catch (e) {\n          if (e !== NOT_SERIALIZABLE) {\n            if (hasDebugInfoAttached === undefined) hasDebugInfoAttached = new WeakSet();\n            if (!hasDebugInfoAttached.has(e)) {\n              e.message += `\\nwhile serializing ${stackToString(value)}`;\n              hasDebugInfoAttached.add(e);\n            }\n          }\n          throw e;\n        }\n      },\n      setCircularReference(ref) {\n        addReferenceable(ref);\n      },\n      snapshot() {\n        return {\n          length: result.length,\n          cycleStackSize: cycleStack.size,\n          referenceableSize: referenceable.size,\n          currentPos,\n          objectTypeLookupSize: objectTypeLookup.size,\n          currentPosTypeLookup\n        };\n      },\n      rollback(snapshot) {\n        result.length = snapshot.length;\n        setSetSize(cycleStack, snapshot.cycleStackSize);\n        setMapSize(referenceable, snapshot.referenceableSize);\n        currentPos = snapshot.currentPos;\n        setMapSize(objectTypeLookup, snapshot.objectTypeLookupSize);\n        currentPosTypeLookup = snapshot.currentPosTypeLookup;\n      },\n      ...context\n    };\n    this.extendContext(ctx);\n    const process = item => {\n      if (Buffer.isBuffer(item)) {\n        // check if we can emit a reference\n        const ref = referenceable.get(item);\n        if (ref !== undefined) {\n          result.push(ESCAPE, ref - currentPos);\n          return;\n        }\n        const alreadyUsedBuffer = dedupeBuffer(item);\n        if (alreadyUsedBuffer !== item) {\n          const ref = referenceable.get(alreadyUsedBuffer);\n          if (ref !== undefined) {\n            referenceable.set(item, ref);\n            result.push(ESCAPE, ref - currentPos);\n            return;\n          }\n          item = alreadyUsedBuffer;\n        }\n        addReferenceable(item);\n        result.push(item);\n      } else if (item === ESCAPE) {\n        result.push(ESCAPE, ESCAPE_ESCAPE_VALUE);\n      } else if (typeof item === \"object\"\n      // We don't have to check for null as ESCAPE is null and this has been checked before\n      ) {\n        // check if we can emit a reference\n        const ref = referenceable.get(item);\n        if (ref !== undefined) {\n          result.push(ESCAPE, ref - currentPos);\n          return;\n        }\n        if (cycleStack.has(item)) {\n          throw new Error(`This is a circular references. To serialize circular references use 'setCircularReference' somewhere in the circle during serialize and deserialize.`);\n        }\n        const {\n          request,\n          name,\n          serializer\n        } = ObjectMiddleware.getSerializerFor(item);\n        const key = `${request}/${name}`;\n        const lastIndex = objectTypeLookup.get(key);\n        if (lastIndex === undefined) {\n          objectTypeLookup.set(key, currentPosTypeLookup++);\n          result.push(ESCAPE, request, name);\n        } else {\n          result.push(ESCAPE, currentPosTypeLookup - lastIndex);\n        }\n        cycleStack.add(item);\n        try {\n          serializer.serialize(item, ctx);\n        } finally {\n          cycleStack.delete(item);\n        }\n        result.push(ESCAPE, ESCAPE_END_OBJECT);\n        addReferenceable(item);\n      } else if (typeof item === \"string\") {\n        if (item.length > 1) {\n          // short strings are shorter when not emitting a reference (this saves 1 byte per empty string)\n          // check if we can emit a reference\n          const ref = referenceable.get(item);\n          if (ref !== undefined) {\n            result.push(ESCAPE, ref - currentPos);\n            return;\n          }\n          addReferenceable(item);\n        }\n        if (item.length > 102400 && context.logger) {\n          context.logger.warn(`Serializing big strings (${Math.round(item.length / 1024)}kiB) impacts deserialization performance (consider using Buffer instead and decode when needed)`);\n        }\n        result.push(item);\n      } else if (typeof item === \"function\") {\n        if (!SerializerMiddleware.isLazy(item)) throw new Error(\"Unexpected function \" + item);\n        /** @type {SerializedType} */\n        const serializedData = SerializerMiddleware.getLazySerializedValue(item);\n        if (serializedData !== undefined) {\n          if (typeof serializedData === \"function\") {\n            result.push(serializedData);\n          } else {\n            throw new Error(\"Not implemented\");\n          }\n        } else if (SerializerMiddleware.isLazy(item, this)) {\n          throw new Error(\"Not implemented\");\n        } else {\n          const data = SerializerMiddleware.serializeLazy(item, data => this.serialize([data], context));\n          SerializerMiddleware.setLazySerializedValue(item, data);\n          result.push(data);\n        }\n      } else if (item === undefined) {\n        result.push(ESCAPE, ESCAPE_UNDEFINED);\n      } else {\n        result.push(item);\n      }\n    };\n    try {\n      for (const item of data) {\n        process(item);\n      }\n      return result;\n    } catch (e) {\n      if (e === NOT_SERIALIZABLE) return null;\n      throw e;\n    } finally {\n      // Get rid of these references to avoid leaking memory\n      // This happens because the optimized code v8 generates\n      // is optimized for our \"ctx.write\" method so it will reference\n      // it from e. g. Dependency.prototype.serialize -(IC)-> ctx.write\n      data = result = referenceable = bufferDedupeMap = objectTypeLookup = ctx = undefined;\n    }\n  }\n\n  /**\n   * @param {SerializedType} data data\n   * @param {Object} context context object\n   * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n   */\n  deserialize(data, context) {\n    let currentDataPos = 0;\n    const read = () => {\n      if (currentDataPos >= data.length) throw new Error(\"Unexpected end of stream\");\n      return data[currentDataPos++];\n    };\n    if (read() !== CURRENT_VERSION) throw new Error(\"Version mismatch, serializer changed\");\n    let currentPos = 0;\n    let referenceable = [];\n    const addReferenceable = item => {\n      referenceable.push(item);\n      currentPos++;\n    };\n    let currentPosTypeLookup = 0;\n    let objectTypeLookup = [];\n    let result = [];\n    let ctx = {\n      read() {\n        return decodeValue();\n      },\n      setCircularReference(ref) {\n        addReferenceable(ref);\n      },\n      ...context\n    };\n    this.extendContext(ctx);\n    const decodeValue = () => {\n      const item = read();\n      if (item === ESCAPE) {\n        const nextItem = read();\n        if (nextItem === ESCAPE_ESCAPE_VALUE) {\n          return ESCAPE;\n        } else if (nextItem === ESCAPE_UNDEFINED) {\n          return undefined;\n        } else if (nextItem === ESCAPE_END_OBJECT) {\n          throw new Error(`Unexpected end of object at position ${currentDataPos - 1}`);\n        } else {\n          const request = nextItem;\n          let serializer;\n          if (typeof request === \"number\") {\n            if (request < 0) {\n              // relative reference\n              return referenceable[currentPos + request];\n            }\n            serializer = objectTypeLookup[currentPosTypeLookup - request];\n          } else {\n            if (typeof request !== \"string\") {\n              throw new Error(`Unexpected type (${typeof request}) of request ` + `at position ${currentDataPos - 1}`);\n            }\n            const name = read();\n            serializer = ObjectMiddleware._getDeserializerForWithoutError(request, name);\n            if (serializer === undefined) {\n              if (request && !loadedRequests.has(request)) {\n                let loaded = false;\n                for (const [regExp, loader] of loaders) {\n                  if (regExp.test(request)) {\n                    if (loader(request)) {\n                      loaded = true;\n                      break;\n                    }\n                  }\n                }\n                if (!loaded) {\n                  require(request);\n                }\n                loadedRequests.add(request);\n              }\n              serializer = ObjectMiddleware.getDeserializerFor(request, name);\n            }\n            objectTypeLookup.push(serializer);\n            currentPosTypeLookup++;\n          }\n          try {\n            const item = serializer.deserialize(ctx);\n            const end1 = read();\n            if (end1 !== ESCAPE) {\n              throw new Error(\"Expected end of object\");\n            }\n            const end2 = read();\n            if (end2 !== ESCAPE_END_OBJECT) {\n              throw new Error(\"Expected end of object\");\n            }\n            addReferenceable(item);\n            return item;\n          } catch (err) {\n            // As this is only for error handling, we omit creating a Map for\n            // faster access to this information, as this would affect performance\n            // in the good case\n            let serializerEntry;\n            for (const entry of serializers) {\n              if (entry[1].serializer === serializer) {\n                serializerEntry = entry;\n                break;\n              }\n            }\n            const name = !serializerEntry ? \"unknown\" : !serializerEntry[1].request ? serializerEntry[0].name : serializerEntry[1].name ? `${serializerEntry[1].request} ${serializerEntry[1].name}` : serializerEntry[1].request;\n            err.message += `\\n(during deserialization of ${name})`;\n            throw err;\n          }\n        }\n      } else if (typeof item === \"string\") {\n        if (item.length > 1) {\n          addReferenceable(item);\n        }\n        return item;\n      } else if (Buffer.isBuffer(item)) {\n        addReferenceable(item);\n        return item;\n      } else if (typeof item === \"function\") {\n        return SerializerMiddleware.deserializeLazy(item, data => this.deserialize(data, context)[0]);\n      } else {\n        return item;\n      }\n    };\n    try {\n      while (currentDataPos < data.length) {\n        result.push(decodeValue());\n      }\n      return result;\n    } finally {\n      // Get rid of these references to avoid leaking memory\n      // This happens because the optimized code v8 generates\n      // is optimized for our \"ctx.read\" method so it will reference\n      // it from e. g. Dependency.prototype.deserialize -(IC)-> ctx.read\n      result = referenceable = data = objectTypeLookup = ctx = undefined;\n    }\n  }\n}\nmodule.exports = ObjectMiddleware;\nmodule.exports.NOT_SERIALIZABLE = NOT_SERIALIZABLE;","map":{"version":3,"names":["createHash","require","ArraySerializer","DateObjectSerializer","ErrorObjectSerializer","MapObjectSerializer","NullPrototypeObjectSerializer","PlainObjectSerializer","RegExpObjectSerializer","SerializerMiddleware","SetObjectSerializer","setSetSize","set","size","i","item","delete","setMapSize","map","keys","toHash","buffer","hashFunction","hash","update","digest","ESCAPE","ESCAPE_ESCAPE_VALUE","ESCAPE_END_OBJECT","ESCAPE_UNDEFINED","CURRENT_VERSION","serializers","Map","serializerInversed","loadedRequests","Set","NOT_SERIALIZABLE","jsTypes","Object","Array","Date","RegExp","Error","EvalError","RangeError","ReferenceError","SyntaxError","TypeError","exports","constructor","Obj","Fn","type","config","from","Type","name","serializer","request","values","loaders","ObjectMiddleware","extendContext","_hashFunction","registerLoader","regExp","loader","register","Constructor","key","has","registerNotSerializable","getSerializerFor","object","proto","getPrototypeOf","c","get","getDeserializerFor","undefined","_getDeserializerForWithoutError","serialize","data","context","result","currentPos","referenceable","addReferenceable","bufferDedupeMap","dedupeBuffer","buf","len","length","entry","Buffer","isBuffer","equals","newMap","hashBuf","isArray","push","found","itemHash","currentPosTypeLookup","objectTypeLookup","cycleStack","stackToString","arr","JSON","stringify","slice","e","join","toString","message","hasDebugInfoAttached","ctx","write","value","process","WeakSet","add","setCircularReference","ref","snapshot","cycleStackSize","referenceableSize","objectTypeLookupSize","rollback","alreadyUsedBuffer","lastIndex","logger","warn","Math","round","isLazy","serializedData","getLazySerializedValue","serializeLazy","setLazySerializedValue","deserialize","currentDataPos","read","decodeValue","nextItem","loaded","test","end1","end2","err","serializerEntry","deserializeLazy","module"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/serialization/ObjectMiddleware.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst createHash = require(\"../util/createHash\");\nconst ArraySerializer = require(\"./ArraySerializer\");\nconst DateObjectSerializer = require(\"./DateObjectSerializer\");\nconst ErrorObjectSerializer = require(\"./ErrorObjectSerializer\");\nconst MapObjectSerializer = require(\"./MapObjectSerializer\");\nconst NullPrototypeObjectSerializer = require(\"./NullPrototypeObjectSerializer\");\nconst PlainObjectSerializer = require(\"./PlainObjectSerializer\");\nconst RegExpObjectSerializer = require(\"./RegExpObjectSerializer\");\nconst SerializerMiddleware = require(\"./SerializerMiddleware\");\nconst SetObjectSerializer = require(\"./SetObjectSerializer\");\n\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n/** @typedef {import(\"./types\").ComplexSerializableType} ComplexSerializableType */\n/** @typedef {import(\"./types\").PrimitiveSerializableType} PrimitiveSerializableType */\n\n/** @typedef {new (...params: any[]) => any} Constructor */\n\n/*\n\nFormat:\n\nFile -> Section*\nSection -> ObjectSection | ReferenceSection | EscapeSection | OtherSection\n\nObjectSection -> ESCAPE (\n\tnumber:relativeOffset (number > 0) |\n\tstring:request (string|null):export\n) Section:value* ESCAPE ESCAPE_END_OBJECT\nReferenceSection -> ESCAPE number:relativeOffset (number < 0)\nEscapeSection -> ESCAPE ESCAPE_ESCAPE_VALUE (escaped value ESCAPE)\nEscapeSection -> ESCAPE ESCAPE_UNDEFINED (escaped value ESCAPE)\nOtherSection -> any (except ESCAPE)\n\nWhy using null as escape value?\nMultiple null values can merged by the BinaryMiddleware, which makes it very efficient\nTechnically any value can be used.\n\n*/\n\n/**\n * @typedef {Object} ObjectSerializerContext\n * @property {function(any): void} write\n * @property {(function(any): void)=} writeLazy\n * @property {(function(any, object=): (() => Promise<any> | any))=} writeSeparate\n * @property {function(any): void} setCircularReference\n */\n\n/**\n * @typedef {Object} ObjectDeserializerContext\n * @property {function(): any} read\n * @property {function(any): void} setCircularReference\n */\n\n/**\n * @typedef {Object} ObjectSerializer\n * @property {function(any, ObjectSerializerContext): void} serialize\n * @property {function(ObjectDeserializerContext): any} deserialize\n */\n\n/**\n * @template T\n * @param {Set<T>} set set\n * @param {number} size count of items to keep\n */\nconst setSetSize = (set, size) => {\n\tlet i = 0;\n\tfor (const item of set) {\n\t\tif (i++ >= size) {\n\t\t\tset.delete(item);\n\t\t}\n\t}\n};\n\n/**\n * @template K, X\n * @param {Map<K, X>} map map\n * @param {number} size count of items to keep\n */\nconst setMapSize = (map, size) => {\n\tlet i = 0;\n\tfor (const item of map.keys()) {\n\t\tif (i++ >= size) {\n\t\t\tmap.delete(item);\n\t\t}\n\t}\n};\n\n/**\n * @param {Buffer} buffer buffer\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\nconst toHash = (buffer, hashFunction) => {\n\tconst hash = createHash(hashFunction);\n\thash.update(buffer);\n\treturn /** @type {string} */ (hash.digest(\"latin1\"));\n};\n\nconst ESCAPE = null;\nconst ESCAPE_ESCAPE_VALUE = null;\nconst ESCAPE_END_OBJECT = true;\nconst ESCAPE_UNDEFINED = false;\n\nconst CURRENT_VERSION = 2;\n\n/** @type {Map<Constructor, { request?: string, name?: string | number | null, serializer?: ObjectSerializer }>} */\nconst serializers = new Map();\n/** @type {Map<string | number, ObjectSerializer>} */\nconst serializerInversed = new Map();\n\n/** @type {Set<string>} */\nconst loadedRequests = new Set();\n\nconst NOT_SERIALIZABLE = {};\n\nconst jsTypes = new Map();\njsTypes.set(Object, new PlainObjectSerializer());\njsTypes.set(Array, new ArraySerializer());\njsTypes.set(null, new NullPrototypeObjectSerializer());\njsTypes.set(Map, new MapObjectSerializer());\njsTypes.set(Set, new SetObjectSerializer());\njsTypes.set(Date, new DateObjectSerializer());\njsTypes.set(RegExp, new RegExpObjectSerializer());\njsTypes.set(Error, new ErrorObjectSerializer(Error));\njsTypes.set(EvalError, new ErrorObjectSerializer(EvalError));\njsTypes.set(RangeError, new ErrorObjectSerializer(RangeError));\njsTypes.set(ReferenceError, new ErrorObjectSerializer(ReferenceError));\njsTypes.set(SyntaxError, new ErrorObjectSerializer(SyntaxError));\njsTypes.set(TypeError, new ErrorObjectSerializer(TypeError));\n\n// If in a sandboxed environment (e. g. jest), this escapes the sandbox and registers\n// real Object and Array types to. These types may occur in the wild too, e. g. when\n// using Structured Clone in postMessage.\nif (exports.constructor !== Object) {\n\tconst Obj = /** @type {typeof Object} */ (exports.constructor);\n\tconst Fn = /** @type {typeof Function} */ (Obj.constructor);\n\tfor (const [type, config] of Array.from(jsTypes)) {\n\t\tif (type) {\n\t\t\tconst Type = new Fn(`return ${type.name};`)();\n\t\t\tjsTypes.set(Type, config);\n\t\t}\n\t}\n}\n\n{\n\tlet i = 1;\n\tfor (const [type, serializer] of jsTypes) {\n\t\tserializers.set(type, {\n\t\t\trequest: \"\",\n\t\t\tname: i++,\n\t\t\tserializer\n\t\t});\n\t}\n}\n\nfor (const { request, name, serializer } of serializers.values()) {\n\tserializerInversed.set(\n\t\t`${request}/${name}`,\n\t\t/** @type {ObjectSerializer} */ (serializer)\n\t);\n}\n\n/** @type {Map<RegExp, (request: string) => boolean>} */\nconst loaders = new Map();\n\n/**\n * @typedef {ComplexSerializableType[]} DeserializedType\n * @typedef {PrimitiveSerializableType[]} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\nclass ObjectMiddleware extends SerializerMiddleware {\n\t/**\n\t * @param {function(any): void} extendContext context extensions\n\t * @param {string | Hash} hashFunction hash function to use\n\t */\n\tconstructor(extendContext, hashFunction = \"md4\") {\n\t\tsuper();\n\t\tthis.extendContext = extendContext;\n\t\tthis._hashFunction = hashFunction;\n\t}\n\t/**\n\t * @param {RegExp} regExp RegExp for which the request is tested\n\t * @param {function(string): boolean} loader loader to load the request, returns true when successful\n\t * @returns {void}\n\t */\n\tstatic registerLoader(regExp, loader) {\n\t\tloaders.set(regExp, loader);\n\t}\n\n\t/**\n\t * @param {Constructor} Constructor the constructor\n\t * @param {string} request the request which will be required when deserializing\n\t * @param {string | null} name the name to make multiple serializer unique when sharing a request\n\t * @param {ObjectSerializer} serializer the serializer\n\t * @returns {void}\n\t */\n\tstatic register(Constructor, request, name, serializer) {\n\t\tconst key = request + \"/\" + name;\n\n\t\tif (serializers.has(Constructor)) {\n\t\t\tthrow new Error(\n\t\t\t\t`ObjectMiddleware.register: serializer for ${Constructor.name} is already registered`\n\t\t\t);\n\t\t}\n\n\t\tif (serializerInversed.has(key)) {\n\t\t\tthrow new Error(\n\t\t\t\t`ObjectMiddleware.register: serializer for ${key} is already registered`\n\t\t\t);\n\t\t}\n\n\t\tserializers.set(Constructor, {\n\t\t\trequest,\n\t\t\tname,\n\t\t\tserializer\n\t\t});\n\n\t\tserializerInversed.set(key, serializer);\n\t}\n\n\t/**\n\t * @param {Constructor} Constructor the constructor\n\t * @returns {void}\n\t */\n\tstatic registerNotSerializable(Constructor) {\n\t\tif (serializers.has(Constructor)) {\n\t\t\tthrow new Error(\n\t\t\t\t`ObjectMiddleware.registerNotSerializable: serializer for ${Constructor.name} is already registered`\n\t\t\t);\n\t\t}\n\n\t\tserializers.set(Constructor, NOT_SERIALIZABLE);\n\t}\n\n\tstatic getSerializerFor(object) {\n\t\tconst proto = Object.getPrototypeOf(object);\n\t\tlet c;\n\t\tif (proto === null) {\n\t\t\t// Object created with Object.create(null)\n\t\t\tc = null;\n\t\t} else {\n\t\t\tc = proto.constructor;\n\t\t\tif (!c) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Serialization of objects with prototype without valid constructor property not possible\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tconst config = serializers.get(c);\n\n\t\tif (!config) throw new Error(`No serializer registered for ${c.name}`);\n\t\tif (config === NOT_SERIALIZABLE) throw NOT_SERIALIZABLE;\n\n\t\treturn config;\n\t}\n\n\t/**\n\t * @param {string} request request\n\t * @param {TODO} name name\n\t * @returns {ObjectSerializer} serializer\n\t */\n\tstatic getDeserializerFor(request, name) {\n\t\tconst key = request + \"/\" + name;\n\t\tconst serializer = serializerInversed.get(key);\n\n\t\tif (serializer === undefined) {\n\t\t\tthrow new Error(`No deserializer registered for ${key}`);\n\t\t}\n\n\t\treturn serializer;\n\t}\n\n\t/**\n\t * @param {string} request request\n\t * @param {TODO} name name\n\t * @returns {ObjectSerializer} serializer\n\t */\n\tstatic _getDeserializerForWithoutError(request, name) {\n\t\tconst key = request + \"/\" + name;\n\t\tconst serializer = serializerInversed.get(key);\n\t\treturn serializer;\n\t}\n\n\t/**\n\t * @param {DeserializedType} data data\n\t * @param {Object} context context object\n\t * @returns {SerializedType|Promise<SerializedType>} serialized data\n\t */\n\tserialize(data, context) {\n\t\t/** @type {any[]} */\n\t\tlet result = [CURRENT_VERSION];\n\t\tlet currentPos = 0;\n\t\tlet referenceable = new Map();\n\t\tconst addReferenceable = item => {\n\t\t\treferenceable.set(item, currentPos++);\n\t\t};\n\t\tlet bufferDedupeMap = new Map();\n\t\tconst dedupeBuffer = buf => {\n\t\t\tconst len = buf.length;\n\t\t\tconst entry = bufferDedupeMap.get(len);\n\t\t\tif (entry === undefined) {\n\t\t\t\tbufferDedupeMap.set(len, buf);\n\t\t\t\treturn buf;\n\t\t\t}\n\t\t\tif (Buffer.isBuffer(entry)) {\n\t\t\t\tif (len < 32) {\n\t\t\t\t\tif (buf.equals(entry)) {\n\t\t\t\t\t\treturn entry;\n\t\t\t\t\t}\n\t\t\t\t\tbufferDedupeMap.set(len, [entry, buf]);\n\t\t\t\t\treturn buf;\n\t\t\t\t} else {\n\t\t\t\t\tconst hash = toHash(entry, this._hashFunction);\n\t\t\t\t\tconst newMap = new Map();\n\t\t\t\t\tnewMap.set(hash, entry);\n\t\t\t\t\tbufferDedupeMap.set(len, newMap);\n\t\t\t\t\tconst hashBuf = toHash(buf, this._hashFunction);\n\t\t\t\t\tif (hash === hashBuf) {\n\t\t\t\t\t\treturn entry;\n\t\t\t\t\t}\n\t\t\t\t\treturn buf;\n\t\t\t\t}\n\t\t\t} else if (Array.isArray(entry)) {\n\t\t\t\tif (entry.length < 16) {\n\t\t\t\t\tfor (const item of entry) {\n\t\t\t\t\t\tif (buf.equals(item)) {\n\t\t\t\t\t\t\treturn item;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tentry.push(buf);\n\t\t\t\t\treturn buf;\n\t\t\t\t} else {\n\t\t\t\t\tconst newMap = new Map();\n\t\t\t\t\tconst hash = toHash(buf, this._hashFunction);\n\t\t\t\t\tlet found;\n\t\t\t\t\tfor (const item of entry) {\n\t\t\t\t\t\tconst itemHash = toHash(item, this._hashFunction);\n\t\t\t\t\t\tnewMap.set(itemHash, item);\n\t\t\t\t\t\tif (found === undefined && itemHash === hash) found = item;\n\t\t\t\t\t}\n\t\t\t\t\tbufferDedupeMap.set(len, newMap);\n\t\t\t\t\tif (found === undefined) {\n\t\t\t\t\t\tnewMap.set(hash, buf);\n\t\t\t\t\t\treturn buf;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn found;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst hash = toHash(buf, this._hashFunction);\n\t\t\t\tconst item = entry.get(hash);\n\t\t\t\tif (item !== undefined) {\n\t\t\t\t\treturn item;\n\t\t\t\t}\n\t\t\t\tentry.set(hash, buf);\n\t\t\t\treturn buf;\n\t\t\t}\n\t\t};\n\t\tlet currentPosTypeLookup = 0;\n\t\tlet objectTypeLookup = new Map();\n\t\tconst cycleStack = new Set();\n\t\tconst stackToString = item => {\n\t\t\tconst arr = Array.from(cycleStack);\n\t\t\tarr.push(item);\n\t\t\treturn arr\n\t\t\t\t.map(item => {\n\t\t\t\t\tif (typeof item === \"string\") {\n\t\t\t\t\t\tif (item.length > 100) {\n\t\t\t\t\t\t\treturn `String ${JSON.stringify(item.slice(0, 100)).slice(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t-1\n\t\t\t\t\t\t\t)}...\"`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn `String ${JSON.stringify(item)}`;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst { request, name } = ObjectMiddleware.getSerializerFor(item);\n\t\t\t\t\t\tif (request) {\n\t\t\t\t\t\t\treturn `${request}${name ? `.${name}` : \"\"}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// ignore -> fallback\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof item === \"object\" && item !== null) {\n\t\t\t\t\t\tif (item.constructor) {\n\t\t\t\t\t\t\tif (item.constructor === Object)\n\t\t\t\t\t\t\t\treturn `Object { ${Object.keys(item).join(\", \")} }`;\n\t\t\t\t\t\t\tif (item.constructor === Map) return `Map { ${item.size} items }`;\n\t\t\t\t\t\t\tif (item.constructor === Array)\n\t\t\t\t\t\t\t\treturn `Array { ${item.length} items }`;\n\t\t\t\t\t\t\tif (item.constructor === Set) return `Set { ${item.size} items }`;\n\t\t\t\t\t\t\tif (item.constructor === RegExp) return item.toString();\n\t\t\t\t\t\t\treturn `${item.constructor.name}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn `Object [null prototype] { ${Object.keys(item).join(\n\t\t\t\t\t\t\t\", \"\n\t\t\t\t\t\t)} }`;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof item === \"bigint\") {\n\t\t\t\t\t\treturn `BigInt ${item}n`;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn `${item}`;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn `(${e.message})`;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.join(\" -> \");\n\t\t};\n\t\tlet hasDebugInfoAttached;\n\t\tlet ctx = {\n\t\t\twrite(value, key) {\n\t\t\t\ttry {\n\t\t\t\t\tprocess(value);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e !== NOT_SERIALIZABLE) {\n\t\t\t\t\t\tif (hasDebugInfoAttached === undefined)\n\t\t\t\t\t\t\thasDebugInfoAttached = new WeakSet();\n\t\t\t\t\t\tif (!hasDebugInfoAttached.has(e)) {\n\t\t\t\t\t\t\te.message += `\\nwhile serializing ${stackToString(value)}`;\n\t\t\t\t\t\t\thasDebugInfoAttached.add(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t},\n\t\t\tsetCircularReference(ref) {\n\t\t\t\taddReferenceable(ref);\n\t\t\t},\n\t\t\tsnapshot() {\n\t\t\t\treturn {\n\t\t\t\t\tlength: result.length,\n\t\t\t\t\tcycleStackSize: cycleStack.size,\n\t\t\t\t\treferenceableSize: referenceable.size,\n\t\t\t\t\tcurrentPos,\n\t\t\t\t\tobjectTypeLookupSize: objectTypeLookup.size,\n\t\t\t\t\tcurrentPosTypeLookup\n\t\t\t\t};\n\t\t\t},\n\t\t\trollback(snapshot) {\n\t\t\t\tresult.length = snapshot.length;\n\t\t\t\tsetSetSize(cycleStack, snapshot.cycleStackSize);\n\t\t\t\tsetMapSize(referenceable, snapshot.referenceableSize);\n\t\t\t\tcurrentPos = snapshot.currentPos;\n\t\t\t\tsetMapSize(objectTypeLookup, snapshot.objectTypeLookupSize);\n\t\t\t\tcurrentPosTypeLookup = snapshot.currentPosTypeLookup;\n\t\t\t},\n\t\t\t...context\n\t\t};\n\t\tthis.extendContext(ctx);\n\t\tconst process = item => {\n\t\t\tif (Buffer.isBuffer(item)) {\n\t\t\t\t// check if we can emit a reference\n\t\t\t\tconst ref = referenceable.get(item);\n\t\t\t\tif (ref !== undefined) {\n\t\t\t\t\tresult.push(ESCAPE, ref - currentPos);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst alreadyUsedBuffer = dedupeBuffer(item);\n\t\t\t\tif (alreadyUsedBuffer !== item) {\n\t\t\t\t\tconst ref = referenceable.get(alreadyUsedBuffer);\n\t\t\t\t\tif (ref !== undefined) {\n\t\t\t\t\t\treferenceable.set(item, ref);\n\t\t\t\t\t\tresult.push(ESCAPE, ref - currentPos);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\titem = alreadyUsedBuffer;\n\t\t\t\t}\n\t\t\t\taddReferenceable(item);\n\n\t\t\t\tresult.push(item);\n\t\t\t} else if (item === ESCAPE) {\n\t\t\t\tresult.push(ESCAPE, ESCAPE_ESCAPE_VALUE);\n\t\t\t} else if (\n\t\t\t\ttypeof item === \"object\"\n\t\t\t\t// We don't have to check for null as ESCAPE is null and this has been checked before\n\t\t\t) {\n\t\t\t\t// check if we can emit a reference\n\t\t\t\tconst ref = referenceable.get(item);\n\t\t\t\tif (ref !== undefined) {\n\t\t\t\t\tresult.push(ESCAPE, ref - currentPos);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (cycleStack.has(item)) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`This is a circular references. To serialize circular references use 'setCircularReference' somewhere in the circle during serialize and deserialize.`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst { request, name, serializer } =\n\t\t\t\t\tObjectMiddleware.getSerializerFor(item);\n\t\t\t\tconst key = `${request}/${name}`;\n\t\t\t\tconst lastIndex = objectTypeLookup.get(key);\n\n\t\t\t\tif (lastIndex === undefined) {\n\t\t\t\t\tobjectTypeLookup.set(key, currentPosTypeLookup++);\n\n\t\t\t\t\tresult.push(ESCAPE, request, name);\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(ESCAPE, currentPosTypeLookup - lastIndex);\n\t\t\t\t}\n\n\t\t\t\tcycleStack.add(item);\n\n\t\t\t\ttry {\n\t\t\t\t\tserializer.serialize(item, ctx);\n\t\t\t\t} finally {\n\t\t\t\t\tcycleStack.delete(item);\n\t\t\t\t}\n\n\t\t\t\tresult.push(ESCAPE, ESCAPE_END_OBJECT);\n\n\t\t\t\taddReferenceable(item);\n\t\t\t} else if (typeof item === \"string\") {\n\t\t\t\tif (item.length > 1) {\n\t\t\t\t\t// short strings are shorter when not emitting a reference (this saves 1 byte per empty string)\n\t\t\t\t\t// check if we can emit a reference\n\t\t\t\t\tconst ref = referenceable.get(item);\n\t\t\t\t\tif (ref !== undefined) {\n\t\t\t\t\t\tresult.push(ESCAPE, ref - currentPos);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\taddReferenceable(item);\n\t\t\t\t}\n\n\t\t\t\tif (item.length > 102400 && context.logger) {\n\t\t\t\t\tcontext.logger.warn(\n\t\t\t\t\t\t`Serializing big strings (${Math.round(\n\t\t\t\t\t\t\titem.length / 1024\n\t\t\t\t\t\t)}kiB) impacts deserialization performance (consider using Buffer instead and decode when needed)`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tresult.push(item);\n\t\t\t} else if (typeof item === \"function\") {\n\t\t\t\tif (!SerializerMiddleware.isLazy(item))\n\t\t\t\t\tthrow new Error(\"Unexpected function \" + item);\n\t\t\t\t/** @type {SerializedType} */\n\t\t\t\tconst serializedData =\n\t\t\t\t\tSerializerMiddleware.getLazySerializedValue(item);\n\t\t\t\tif (serializedData !== undefined) {\n\t\t\t\t\tif (typeof serializedData === \"function\") {\n\t\t\t\t\t\tresult.push(serializedData);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\"Not implemented\");\n\t\t\t\t\t}\n\t\t\t\t} else if (SerializerMiddleware.isLazy(item, this)) {\n\t\t\t\t\tthrow new Error(\"Not implemented\");\n\t\t\t\t} else {\n\t\t\t\t\tconst data = SerializerMiddleware.serializeLazy(item, data =>\n\t\t\t\t\t\tthis.serialize([data], context)\n\t\t\t\t\t);\n\t\t\t\t\tSerializerMiddleware.setLazySerializedValue(item, data);\n\t\t\t\t\tresult.push(data);\n\t\t\t\t}\n\t\t\t} else if (item === undefined) {\n\t\t\t\tresult.push(ESCAPE, ESCAPE_UNDEFINED);\n\t\t\t} else {\n\t\t\t\tresult.push(item);\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\t\t\tfor (const item of data) {\n\t\t\t\tprocess(item);\n\t\t\t}\n\t\t\treturn result;\n\t\t} catch (e) {\n\t\t\tif (e === NOT_SERIALIZABLE) return null;\n\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\t// Get rid of these references to avoid leaking memory\n\t\t\t// This happens because the optimized code v8 generates\n\t\t\t// is optimized for our \"ctx.write\" method so it will reference\n\t\t\t// it from e. g. Dependency.prototype.serialize -(IC)-> ctx.write\n\t\t\tdata =\n\t\t\t\tresult =\n\t\t\t\treferenceable =\n\t\t\t\tbufferDedupeMap =\n\t\t\t\tobjectTypeLookup =\n\t\t\t\tctx =\n\t\t\t\t\tundefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {SerializedType} data data\n\t * @param {Object} context context object\n\t * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n\t */\n\tdeserialize(data, context) {\n\t\tlet currentDataPos = 0;\n\t\tconst read = () => {\n\t\t\tif (currentDataPos >= data.length)\n\t\t\t\tthrow new Error(\"Unexpected end of stream\");\n\n\t\t\treturn data[currentDataPos++];\n\t\t};\n\n\t\tif (read() !== CURRENT_VERSION)\n\t\t\tthrow new Error(\"Version mismatch, serializer changed\");\n\n\t\tlet currentPos = 0;\n\t\tlet referenceable = [];\n\t\tconst addReferenceable = item => {\n\t\t\treferenceable.push(item);\n\t\t\tcurrentPos++;\n\t\t};\n\t\tlet currentPosTypeLookup = 0;\n\t\tlet objectTypeLookup = [];\n\t\tlet result = [];\n\t\tlet ctx = {\n\t\t\tread() {\n\t\t\t\treturn decodeValue();\n\t\t\t},\n\t\t\tsetCircularReference(ref) {\n\t\t\t\taddReferenceable(ref);\n\t\t\t},\n\t\t\t...context\n\t\t};\n\t\tthis.extendContext(ctx);\n\t\tconst decodeValue = () => {\n\t\t\tconst item = read();\n\n\t\t\tif (item === ESCAPE) {\n\t\t\t\tconst nextItem = read();\n\n\t\t\t\tif (nextItem === ESCAPE_ESCAPE_VALUE) {\n\t\t\t\t\treturn ESCAPE;\n\t\t\t\t} else if (nextItem === ESCAPE_UNDEFINED) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else if (nextItem === ESCAPE_END_OBJECT) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Unexpected end of object at position ${currentDataPos - 1}`\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tconst request = nextItem;\n\t\t\t\t\tlet serializer;\n\n\t\t\t\t\tif (typeof request === \"number\") {\n\t\t\t\t\t\tif (request < 0) {\n\t\t\t\t\t\t\t// relative reference\n\t\t\t\t\t\t\treturn referenceable[currentPos + request];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tserializer = objectTypeLookup[currentPosTypeLookup - request];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (typeof request !== \"string\") {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Unexpected type (${typeof request}) of request ` +\n\t\t\t\t\t\t\t\t\t`at position ${currentDataPos - 1}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst name = read();\n\n\t\t\t\t\t\tserializer = ObjectMiddleware._getDeserializerForWithoutError(\n\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (serializer === undefined) {\n\t\t\t\t\t\t\tif (request && !loadedRequests.has(request)) {\n\t\t\t\t\t\t\t\tlet loaded = false;\n\t\t\t\t\t\t\t\tfor (const [regExp, loader] of loaders) {\n\t\t\t\t\t\t\t\t\tif (regExp.test(request)) {\n\t\t\t\t\t\t\t\t\t\tif (loader(request)) {\n\t\t\t\t\t\t\t\t\t\t\tloaded = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!loaded) {\n\t\t\t\t\t\t\t\t\trequire(request);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tloadedRequests.add(request);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tserializer = ObjectMiddleware.getDeserializerFor(request, name);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobjectTypeLookup.push(serializer);\n\t\t\t\t\t\tcurrentPosTypeLookup++;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst item = serializer.deserialize(ctx);\n\t\t\t\t\t\tconst end1 = read();\n\n\t\t\t\t\t\tif (end1 !== ESCAPE) {\n\t\t\t\t\t\t\tthrow new Error(\"Expected end of object\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst end2 = read();\n\n\t\t\t\t\t\tif (end2 !== ESCAPE_END_OBJECT) {\n\t\t\t\t\t\t\tthrow new Error(\"Expected end of object\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\taddReferenceable(item);\n\n\t\t\t\t\t\treturn item;\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t// As this is only for error handling, we omit creating a Map for\n\t\t\t\t\t\t// faster access to this information, as this would affect performance\n\t\t\t\t\t\t// in the good case\n\t\t\t\t\t\tlet serializerEntry;\n\t\t\t\t\t\tfor (const entry of serializers) {\n\t\t\t\t\t\t\tif (entry[1].serializer === serializer) {\n\t\t\t\t\t\t\t\tserializerEntry = entry;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst name = !serializerEntry\n\t\t\t\t\t\t\t? \"unknown\"\n\t\t\t\t\t\t\t: !serializerEntry[1].request\n\t\t\t\t\t\t\t\t? serializerEntry[0].name\n\t\t\t\t\t\t\t\t: serializerEntry[1].name\n\t\t\t\t\t\t\t\t\t? `${serializerEntry[1].request} ${serializerEntry[1].name}`\n\t\t\t\t\t\t\t\t\t: serializerEntry[1].request;\n\t\t\t\t\t\terr.message += `\\n(during deserialization of ${name})`;\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (typeof item === \"string\") {\n\t\t\t\tif (item.length > 1) {\n\t\t\t\t\taddReferenceable(item);\n\t\t\t\t}\n\n\t\t\t\treturn item;\n\t\t\t} else if (Buffer.isBuffer(item)) {\n\t\t\t\taddReferenceable(item);\n\n\t\t\t\treturn item;\n\t\t\t} else if (typeof item === \"function\") {\n\t\t\t\treturn SerializerMiddleware.deserializeLazy(\n\t\t\t\t\titem,\n\t\t\t\t\tdata => this.deserialize(data, context)[0]\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\t\t\twhile (currentDataPos < data.length) {\n\t\t\t\tresult.push(decodeValue());\n\t\t\t}\n\t\t\treturn result;\n\t\t} finally {\n\t\t\t// Get rid of these references to avoid leaking memory\n\t\t\t// This happens because the optimized code v8 generates\n\t\t\t// is optimized for our \"ctx.read\" method so it will reference\n\t\t\t// it from e. g. Dependency.prototype.deserialize -(IC)-> ctx.read\n\t\t\tresult = referenceable = data = objectTypeLookup = ctx = undefined;\n\t\t}\n\t}\n}\n\nmodule.exports = ObjectMiddleware;\nmodule.exports.NOT_SERIALIZABLE = NOT_SERIALIZABLE;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
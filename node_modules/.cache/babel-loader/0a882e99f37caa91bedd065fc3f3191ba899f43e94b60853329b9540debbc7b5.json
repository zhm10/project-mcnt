{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  JAVASCRIPT_MODULE_TYPE_AUTO,\n  JAVASCRIPT_MODULE_TYPE_ESM\n} = require(\"../ModuleTypeConstants\");\nconst PureExpressionDependency = require(\"../dependencies/PureExpressionDependency\");\nconst InnerGraph = require(\"./InnerGraph\");\n\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclarationNode */\n/** @typedef {import(\"estree\").ClassExpression} ClassExpressionNode */\n/** @typedef {import(\"estree\").Node} Node */\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclaratorNode */\n/** @typedef {import(\"../../declarations/WebpackOptions\").JavascriptParserOptions} JavascriptParserOptions */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"../dependencies/HarmonyImportSpecifierDependency\")} HarmonyImportSpecifierDependency */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n/** @typedef {import(\"./InnerGraph\").InnerGraph} InnerGraph */\n/** @typedef {import(\"./InnerGraph\").TopLevelSymbol} TopLevelSymbol */\n\nconst {\n  topLevelSymbolTag\n} = InnerGraph;\nconst PLUGIN_NAME = \"InnerGraphPlugin\";\nclass InnerGraphPlugin {\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation, {\n      normalModuleFactory\n    }) => {\n      const logger = compilation.getLogger(\"webpack.InnerGraphPlugin\");\n      compilation.dependencyTemplates.set(PureExpressionDependency, new PureExpressionDependency.Template());\n\n      /**\n       * @param {JavascriptParser} parser the parser\n       * @param {JavascriptParserOptions} parserOptions options\n       * @returns {void}\n       */\n      const handler = (parser, parserOptions) => {\n        const onUsageSuper = sup => {\n          InnerGraph.onUsage(parser.state, usedByExports => {\n            switch (usedByExports) {\n              case undefined:\n              case true:\n                return;\n              default:\n                {\n                  const dep = new PureExpressionDependency(sup.range);\n                  dep.loc = sup.loc;\n                  dep.usedByExports = usedByExports;\n                  parser.state.module.addDependency(dep);\n                  break;\n                }\n            }\n          });\n        };\n        parser.hooks.program.tap(PLUGIN_NAME, () => {\n          InnerGraph.enable(parser.state);\n        });\n        parser.hooks.finish.tap(PLUGIN_NAME, () => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          logger.time(\"infer dependency usage\");\n          InnerGraph.inferDependencyUsage(parser.state);\n          logger.timeAggregate(\"infer dependency usage\");\n        });\n\n        // During prewalking the following datastructures are filled with\n        // nodes that have a TopLevelSymbol assigned and\n        // variables are tagged with the assigned TopLevelSymbol\n\n        // We differ 3 types of nodes:\n        // 1. full statements (export default, function declaration)\n        // 2. classes (class declaration, class expression)\n        // 3. variable declarators (const x = ...)\n\n        /** @type {WeakMap<Node, TopLevelSymbol>} */\n        const statementWithTopLevelSymbol = new WeakMap();\n        /** @type {WeakMap<Node, Node>} */\n        const statementPurePart = new WeakMap();\n\n        /** @type {WeakMap<ClassExpressionNode | ClassDeclarationNode, TopLevelSymbol>} */\n        const classWithTopLevelSymbol = new WeakMap();\n\n        /** @type {WeakMap<VariableDeclaratorNode, TopLevelSymbol>} */\n        const declWithTopLevelSymbol = new WeakMap();\n        /** @type {WeakSet<VariableDeclaratorNode>} */\n        const pureDeclarators = new WeakSet();\n\n        // The following hooks are used during prewalking:\n\n        parser.hooks.preStatement.tap(PLUGIN_NAME, statement => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (parser.scope.topLevelScope === true) {\n            if (statement.type === \"FunctionDeclaration\") {\n              const name = statement.id ? statement.id.name : \"*default*\";\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              statementWithTopLevelSymbol.set(statement, fn);\n              return true;\n            }\n          }\n        });\n        parser.hooks.blockPreStatement.tap(PLUGIN_NAME, statement => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (parser.scope.topLevelScope === true) {\n            if (statement.type === \"ClassDeclaration\" && parser.isPure(statement, /** @type {Range} */statement.range[0])) {\n              const name = statement.id ? statement.id.name : \"*default*\";\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              classWithTopLevelSymbol.set(statement, fn);\n              return true;\n            }\n            if (statement.type === \"ExportDefaultDeclaration\") {\n              const name = \"*default*\";\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              const decl = statement.declaration;\n              if ((decl.type === \"ClassExpression\" || decl.type === \"ClassDeclaration\") && parser.isPure(decl, /** @type {Range} */decl.range[0])) {\n                classWithTopLevelSymbol.set(decl, fn);\n              } else if (parser.isPure(decl, /** @type {Range} */statement.range[0])) {\n                statementWithTopLevelSymbol.set(statement, fn);\n                if (!decl.type.endsWith(\"FunctionExpression\") && !decl.type.endsWith(\"Declaration\") && decl.type !== \"Literal\") {\n                  statementPurePart.set(statement, decl);\n                }\n              }\n            }\n          }\n        });\n        parser.hooks.preDeclarator.tap(PLUGIN_NAME, (decl, statement) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (parser.scope.topLevelScope === true && decl.init && decl.id.type === \"Identifier\") {\n            const name = decl.id.name;\n            if (decl.init.type === \"ClassExpression\" && parser.isPure(decl.init, /** @type {Range} */decl.id.range[1])) {\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              classWithTopLevelSymbol.set(decl.init, fn);\n            } else if (parser.isPure(decl.init, /** @type {Range} */decl.id.range[1])) {\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              declWithTopLevelSymbol.set(decl, fn);\n              if (!decl.init.type.endsWith(\"FunctionExpression\") && decl.init.type !== \"Literal\") {\n                pureDeclarators.add(decl);\n              }\n            }\n          }\n        });\n\n        // During real walking we set the TopLevelSymbol state to the assigned\n        // TopLevelSymbol by using the fill datastructures.\n\n        // In addition to tracking TopLevelSymbols, we sometimes need to\n        // add a PureExpressionDependency. This is needed to skip execution\n        // of pure expressions, even when they are not dropped due to\n        // minimizing. Otherwise symbols used there might not exist anymore\n        // as they are removed as unused by this optimization\n\n        // When we find a reference to a TopLevelSymbol, we register a\n        // TopLevelSymbol dependency from TopLevelSymbol in state to the\n        // referenced TopLevelSymbol. This way we get a graph of all\n        // TopLevelSymbols.\n\n        // The following hooks are called during walking:\n\n        parser.hooks.statement.tap(PLUGIN_NAME, statement => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (parser.scope.topLevelScope === true) {\n            InnerGraph.setTopLevelSymbol(parser.state, undefined);\n            const fn = statementWithTopLevelSymbol.get(statement);\n            if (fn) {\n              InnerGraph.setTopLevelSymbol(parser.state, fn);\n              const purePart = statementPurePart.get(statement);\n              if (purePart) {\n                InnerGraph.onUsage(parser.state, usedByExports => {\n                  switch (usedByExports) {\n                    case undefined:\n                    case true:\n                      return;\n                    default:\n                      {\n                        const dep = new PureExpressionDependency( /** @type {Range} */purePart.range);\n                        dep.loc = /** @type {DependencyLocation} */\n                        statement.loc;\n                        dep.usedByExports = usedByExports;\n                        parser.state.module.addDependency(dep);\n                        break;\n                      }\n                  }\n                });\n              }\n            }\n          }\n        });\n        parser.hooks.classExtendsExpression.tap(PLUGIN_NAME, (expr, statement) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (parser.scope.topLevelScope === true) {\n            const fn = classWithTopLevelSymbol.get(statement);\n            if (fn && parser.isPure(expr, statement.id ? /** @type {Range} */statement.id.range[1] : /** @type {Range} */statement.range[0])) {\n              InnerGraph.setTopLevelSymbol(parser.state, fn);\n              onUsageSuper(expr);\n            }\n          }\n        });\n        parser.hooks.classBodyElement.tap(PLUGIN_NAME, (element, classDefinition) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (parser.scope.topLevelScope === true) {\n            const fn = classWithTopLevelSymbol.get(classDefinition);\n            if (fn) {\n              InnerGraph.setTopLevelSymbol(parser.state, undefined);\n            }\n          }\n        });\n        parser.hooks.classBodyValue.tap(PLUGIN_NAME, (expression, element, classDefinition) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (parser.scope.topLevelScope === true) {\n            const fn = classWithTopLevelSymbol.get(classDefinition);\n            if (fn) {\n              if (!element.static || parser.isPure(expression, element.key ? /** @type {Range} */element.key.range[1] : /** @type {Range} */element.range[0])) {\n                InnerGraph.setTopLevelSymbol(parser.state, fn);\n                if (element.type !== \"MethodDefinition\" && element.static) {\n                  InnerGraph.onUsage(parser.state, usedByExports => {\n                    switch (usedByExports) {\n                      case undefined:\n                      case true:\n                        return;\n                      default:\n                        {\n                          const dep = new PureExpressionDependency( /** @type {Range} */expression.range);\n                          dep.loc = /** @type {DependencyLocation} */\n                          expression.loc;\n                          dep.usedByExports = usedByExports;\n                          parser.state.module.addDependency(dep);\n                          break;\n                        }\n                    }\n                  });\n                }\n              } else {\n                InnerGraph.setTopLevelSymbol(parser.state, undefined);\n              }\n            }\n          }\n        });\n        parser.hooks.declarator.tap(PLUGIN_NAME, (decl, statement) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          const fn = declWithTopLevelSymbol.get(decl);\n          if (fn) {\n            InnerGraph.setTopLevelSymbol(parser.state, fn);\n            if (pureDeclarators.has(decl)) {\n              if (decl.init.type === \"ClassExpression\") {\n                if (decl.init.superClass) {\n                  onUsageSuper(decl.init.superClass);\n                }\n              } else {\n                InnerGraph.onUsage(parser.state, usedByExports => {\n                  switch (usedByExports) {\n                    case undefined:\n                    case true:\n                      return;\n                    default:\n                      {\n                        const dep = new PureExpressionDependency( /** @type {Range} */decl.init.range);\n                        dep.loc = /** @type {DependencyLocation} */decl.loc;\n                        dep.usedByExports = usedByExports;\n                        parser.state.module.addDependency(dep);\n                        break;\n                      }\n                  }\n                });\n              }\n            }\n            parser.walkExpression(decl.init);\n            InnerGraph.setTopLevelSymbol(parser.state, undefined);\n            return true;\n          } else if (decl.id.type === \"Identifier\" && decl.init && decl.init.type === \"ClassExpression\" && classWithTopLevelSymbol.has(decl.init)) {\n            parser.walkExpression(decl.init);\n            InnerGraph.setTopLevelSymbol(parser.state, undefined);\n            return true;\n          }\n        });\n        parser.hooks.expression.for(topLevelSymbolTag).tap(PLUGIN_NAME, () => {\n          const topLevelSymbol = /** @type {TopLevelSymbol} */\n          parser.currentTagData;\n          const currentTopLevelSymbol = InnerGraph.getTopLevelSymbol(parser.state);\n          InnerGraph.addUsage(parser.state, topLevelSymbol, currentTopLevelSymbol || true);\n        });\n        parser.hooks.assign.for(topLevelSymbolTag).tap(PLUGIN_NAME, expr => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (expr.operator === \"=\") return true;\n        });\n      };\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_AUTO).tap(PLUGIN_NAME, handler);\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_ESM).tap(PLUGIN_NAME, handler);\n      compilation.hooks.finishModules.tap(PLUGIN_NAME, () => {\n        logger.timeAggregateEnd(\"infer dependency usage\");\n      });\n    });\n  }\n}\nmodule.exports = InnerGraphPlugin;","map":{"version":3,"names":["JAVASCRIPT_MODULE_TYPE_AUTO","JAVASCRIPT_MODULE_TYPE_ESM","require","PureExpressionDependency","InnerGraph","topLevelSymbolTag","PLUGIN_NAME","InnerGraphPlugin","apply","compiler","hooks","compilation","tap","normalModuleFactory","logger","getLogger","dependencyTemplates","set","Template","handler","parser","parserOptions","onUsageSuper","sup","onUsage","state","usedByExports","undefined","dep","range","loc","module","addDependency","program","enable","finish","isEnabled","time","inferDependencyUsage","timeAggregate","statementWithTopLevelSymbol","WeakMap","statementPurePart","classWithTopLevelSymbol","declWithTopLevelSymbol","pureDeclarators","WeakSet","preStatement","statement","scope","topLevelScope","type","name","id","fn","tagTopLevelSymbol","blockPreStatement","isPure","decl","declaration","endsWith","preDeclarator","init","add","setTopLevelSymbol","get","purePart","classExtendsExpression","expr","classBodyElement","element","classDefinition","classBodyValue","expression","static","key","declarator","has","superClass","walkExpression","for","topLevelSymbol","currentTagData","currentTopLevelSymbol","getTopLevelSymbol","addUsage","assign","operator","finishModules","timeAggregateEnd","exports"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/optimize/InnerGraphPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n\tJAVASCRIPT_MODULE_TYPE_AUTO,\n\tJAVASCRIPT_MODULE_TYPE_ESM\n} = require(\"../ModuleTypeConstants\");\nconst PureExpressionDependency = require(\"../dependencies/PureExpressionDependency\");\nconst InnerGraph = require(\"./InnerGraph\");\n\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclarationNode */\n/** @typedef {import(\"estree\").ClassExpression} ClassExpressionNode */\n/** @typedef {import(\"estree\").Node} Node */\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclaratorNode */\n/** @typedef {import(\"../../declarations/WebpackOptions\").JavascriptParserOptions} JavascriptParserOptions */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"../dependencies/HarmonyImportSpecifierDependency\")} HarmonyImportSpecifierDependency */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n/** @typedef {import(\"./InnerGraph\").InnerGraph} InnerGraph */\n/** @typedef {import(\"./InnerGraph\").TopLevelSymbol} TopLevelSymbol */\n\nconst { topLevelSymbolTag } = InnerGraph;\n\nconst PLUGIN_NAME = \"InnerGraphPlugin\";\n\nclass InnerGraphPlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\n\t\t\tPLUGIN_NAME,\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tconst logger = compilation.getLogger(\"webpack.InnerGraphPlugin\");\n\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tPureExpressionDependency,\n\t\t\t\t\tnew PureExpressionDependency.Template()\n\t\t\t\t);\n\n\t\t\t\t/**\n\t\t\t\t * @param {JavascriptParser} parser the parser\n\t\t\t\t * @param {JavascriptParserOptions} parserOptions options\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst handler = (parser, parserOptions) => {\n\t\t\t\t\tconst onUsageSuper = sup => {\n\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\n\t\t\t\t\t\t\tswitch (usedByExports) {\n\t\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\t\tcase true:\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(sup.range);\n\t\t\t\t\t\t\t\t\tdep.loc = sup.loc;\n\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\n\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\tparser.hooks.program.tap(PLUGIN_NAME, () => {\n\t\t\t\t\t\tInnerGraph.enable(parser.state);\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.finish.tap(PLUGIN_NAME, () => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\n\t\t\t\t\t\tlogger.time(\"infer dependency usage\");\n\t\t\t\t\t\tInnerGraph.inferDependencyUsage(parser.state);\n\t\t\t\t\t\tlogger.timeAggregate(\"infer dependency usage\");\n\t\t\t\t\t});\n\n\t\t\t\t\t// During prewalking the following datastructures are filled with\n\t\t\t\t\t// nodes that have a TopLevelSymbol assigned and\n\t\t\t\t\t// variables are tagged with the assigned TopLevelSymbol\n\n\t\t\t\t\t// We differ 3 types of nodes:\n\t\t\t\t\t// 1. full statements (export default, function declaration)\n\t\t\t\t\t// 2. classes (class declaration, class expression)\n\t\t\t\t\t// 3. variable declarators (const x = ...)\n\n\t\t\t\t\t/** @type {WeakMap<Node, TopLevelSymbol>} */\n\t\t\t\t\tconst statementWithTopLevelSymbol = new WeakMap();\n\t\t\t\t\t/** @type {WeakMap<Node, Node>} */\n\t\t\t\t\tconst statementPurePart = new WeakMap();\n\n\t\t\t\t\t/** @type {WeakMap<ClassExpressionNode | ClassDeclarationNode, TopLevelSymbol>} */\n\t\t\t\t\tconst classWithTopLevelSymbol = new WeakMap();\n\n\t\t\t\t\t/** @type {WeakMap<VariableDeclaratorNode, TopLevelSymbol>} */\n\t\t\t\t\tconst declWithTopLevelSymbol = new WeakMap();\n\t\t\t\t\t/** @type {WeakSet<VariableDeclaratorNode>} */\n\t\t\t\t\tconst pureDeclarators = new WeakSet();\n\n\t\t\t\t\t// The following hooks are used during prewalking:\n\n\t\t\t\t\tparser.hooks.preStatement.tap(PLUGIN_NAME, statement => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\n\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\tif (statement.type === \"FunctionDeclaration\") {\n\t\t\t\t\t\t\t\tconst name = statement.id ? statement.id.name : \"*default*\";\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\tstatementWithTopLevelSymbol.set(statement, fn);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.blockPreStatement.tap(PLUGIN_NAME, statement => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\n\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tstatement.type === \"ClassDeclaration\" &&\n\t\t\t\t\t\t\t\tparser.isPure(\n\t\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\t\t/** @type {Range} */ (statement.range)[0]\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst name = statement.id ? statement.id.name : \"*default*\";\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\tclassWithTopLevelSymbol.set(statement, fn);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (statement.type === \"ExportDefaultDeclaration\") {\n\t\t\t\t\t\t\t\tconst name = \"*default*\";\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\tconst decl = statement.declaration;\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t(decl.type === \"ClassExpression\" ||\n\t\t\t\t\t\t\t\t\t\tdecl.type === \"ClassDeclaration\") &&\n\t\t\t\t\t\t\t\t\tparser.isPure(decl, /** @type {Range} */ (decl.range)[0])\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tclassWithTopLevelSymbol.set(decl, fn);\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tparser.isPure(decl, /** @type {Range} */ (statement.range)[0])\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tstatementWithTopLevelSymbol.set(statement, fn);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!decl.type.endsWith(\"FunctionExpression\") &&\n\t\t\t\t\t\t\t\t\t\t!decl.type.endsWith(\"Declaration\") &&\n\t\t\t\t\t\t\t\t\t\tdecl.type !== \"Literal\"\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tstatementPurePart.set(statement, decl);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.preDeclarator.tap(PLUGIN_NAME, (decl, statement) => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tparser.scope.topLevelScope === true &&\n\t\t\t\t\t\t\tdecl.init &&\n\t\t\t\t\t\t\tdecl.id.type === \"Identifier\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst name = decl.id.name;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tdecl.init.type === \"ClassExpression\" &&\n\t\t\t\t\t\t\t\tparser.isPure(\n\t\t\t\t\t\t\t\t\tdecl.init,\n\t\t\t\t\t\t\t\t\t/** @type {Range} */ (decl.id.range)[1]\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\tclassWithTopLevelSymbol.set(decl.init, fn);\n\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\tparser.isPure(\n\t\t\t\t\t\t\t\t\tdecl.init,\n\t\t\t\t\t\t\t\t\t/** @type {Range} */ (decl.id.range)[1]\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\tdeclWithTopLevelSymbol.set(decl, fn);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t!decl.init.type.endsWith(\"FunctionExpression\") &&\n\t\t\t\t\t\t\t\t\tdecl.init.type !== \"Literal\"\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tpureDeclarators.add(decl);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t// During real walking we set the TopLevelSymbol state to the assigned\n\t\t\t\t\t// TopLevelSymbol by using the fill datastructures.\n\n\t\t\t\t\t// In addition to tracking TopLevelSymbols, we sometimes need to\n\t\t\t\t\t// add a PureExpressionDependency. This is needed to skip execution\n\t\t\t\t\t// of pure expressions, even when they are not dropped due to\n\t\t\t\t\t// minimizing. Otherwise symbols used there might not exist anymore\n\t\t\t\t\t// as they are removed as unused by this optimization\n\n\t\t\t\t\t// When we find a reference to a TopLevelSymbol, we register a\n\t\t\t\t\t// TopLevelSymbol dependency from TopLevelSymbol in state to the\n\t\t\t\t\t// referenced TopLevelSymbol. This way we get a graph of all\n\t\t\t\t\t// TopLevelSymbols.\n\n\t\t\t\t\t// The following hooks are called during walking:\n\n\t\t\t\t\tparser.hooks.statement.tap(PLUGIN_NAME, statement => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\n\n\t\t\t\t\t\t\tconst fn = statementWithTopLevelSymbol.get(statement);\n\t\t\t\t\t\t\tif (fn) {\n\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\n\t\t\t\t\t\t\t\tconst purePart = statementPurePart.get(statement);\n\t\t\t\t\t\t\t\tif (purePart) {\n\t\t\t\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\n\t\t\t\t\t\t\t\t\t\tswitch (usedByExports) {\n\t\t\t\t\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\t\t\t\t\tcase true:\n\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (purePart.range)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tdep.loc =\n\t\t\t\t\t\t\t\t\t\t\t\t\t/** @type {DependencyLocation} */\n\t\t\t\t\t\t\t\t\t\t\t\t\t(statement.loc);\n\t\t\t\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\n\t\t\t\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.classExtendsExpression.tap(\n\t\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\t\t(expr, statement) => {\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\t\tconst fn = classWithTopLevelSymbol.get(statement);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tfn &&\n\t\t\t\t\t\t\t\t\tparser.isPure(\n\t\t\t\t\t\t\t\t\t\texpr,\n\t\t\t\t\t\t\t\t\t\tstatement.id\n\t\t\t\t\t\t\t\t\t\t\t? /** @type {Range} */ (statement.id.range)[1]\n\t\t\t\t\t\t\t\t\t\t\t: /** @type {Range} */ (statement.range)[0]\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\n\t\t\t\t\t\t\t\t\tonUsageSuper(expr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tparser.hooks.classBodyElement.tap(\n\t\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\t\t(element, classDefinition) => {\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\t\tconst fn = classWithTopLevelSymbol.get(classDefinition);\n\t\t\t\t\t\t\t\tif (fn) {\n\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tparser.hooks.classBodyValue.tap(\n\t\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\t\t(expression, element, classDefinition) => {\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\t\tconst fn = classWithTopLevelSymbol.get(classDefinition);\n\t\t\t\t\t\t\t\tif (fn) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!element.static ||\n\t\t\t\t\t\t\t\t\t\tparser.isPure(\n\t\t\t\t\t\t\t\t\t\t\texpression,\n\t\t\t\t\t\t\t\t\t\t\telement.key\n\t\t\t\t\t\t\t\t\t\t\t\t? /** @type {Range} */ (element.key.range)[1]\n\t\t\t\t\t\t\t\t\t\t\t\t: /** @type {Range} */ (element.range)[0]\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\n\t\t\t\t\t\t\t\t\t\tif (element.type !== \"MethodDefinition\" && element.static) {\n\t\t\t\t\t\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\n\t\t\t\t\t\t\t\t\t\t\t\tswitch (usedByExports) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase true:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (expression.range)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdep.loc =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/** @type {DependencyLocation} */\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expression.loc);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tparser.hooks.declarator.tap(PLUGIN_NAME, (decl, statement) => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\tconst fn = declWithTopLevelSymbol.get(decl);\n\n\t\t\t\t\t\tif (fn) {\n\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\n\t\t\t\t\t\t\tif (pureDeclarators.has(decl)) {\n\t\t\t\t\t\t\t\tif (decl.init.type === \"ClassExpression\") {\n\t\t\t\t\t\t\t\t\tif (decl.init.superClass) {\n\t\t\t\t\t\t\t\t\t\tonUsageSuper(decl.init.superClass);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\n\t\t\t\t\t\t\t\t\t\tswitch (usedByExports) {\n\t\t\t\t\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\t\t\t\t\tcase true:\n\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\t/** @type {Range} */ (decl.init.range)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (decl.loc);\n\t\t\t\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\n\t\t\t\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tparser.walkExpression(decl.init);\n\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tdecl.id.type === \"Identifier\" &&\n\t\t\t\t\t\t\tdecl.init &&\n\t\t\t\t\t\t\tdecl.init.type === \"ClassExpression\" &&\n\t\t\t\t\t\t\tclassWithTopLevelSymbol.has(decl.init)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tparser.walkExpression(decl.init);\n\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.expression\n\t\t\t\t\t\t.for(topLevelSymbolTag)\n\t\t\t\t\t\t.tap(PLUGIN_NAME, () => {\n\t\t\t\t\t\t\tconst topLevelSymbol = /** @type {TopLevelSymbol} */ (\n\t\t\t\t\t\t\t\tparser.currentTagData\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst currentTopLevelSymbol = InnerGraph.getTopLevelSymbol(\n\t\t\t\t\t\t\t\tparser.state\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tInnerGraph.addUsage(\n\t\t\t\t\t\t\t\tparser.state,\n\t\t\t\t\t\t\t\ttopLevelSymbol,\n\t\t\t\t\t\t\t\tcurrentTopLevelSymbol || true\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\tparser.hooks.assign.for(topLevelSymbolTag).tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\tif (expr.operator === \"=\") return true;\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_AUTO)\n\t\t\t\t\t.tap(PLUGIN_NAME, handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_ESM)\n\t\t\t\t\t.tap(PLUGIN_NAME, handler);\n\n\t\t\t\tcompilation.hooks.finishModules.tap(PLUGIN_NAME, () => {\n\t\t\t\t\tlogger.timeAggregateEnd(\"infer dependency usage\");\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = InnerGraphPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
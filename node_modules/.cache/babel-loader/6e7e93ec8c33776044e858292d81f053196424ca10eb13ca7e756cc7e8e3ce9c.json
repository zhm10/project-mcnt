{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  SyncHook,\n  AsyncSeriesHook\n} = require(\"tapable\");\nconst {\n  makeWebpackError\n} = require(\"../HookWebpackError\");\nconst WebpackError = require(\"../WebpackError\");\nconst ArrayQueue = require(\"./ArrayQueue\");\nconst QUEUED_STATE = 0;\nconst PROCESSING_STATE = 1;\nconst DONE_STATE = 2;\nlet inHandleResult = 0;\n\n/**\n * @template T\n * @callback Callback\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n */\n\n/**\n * @template T\n * @template K\n * @template R\n */\nclass AsyncQueueEntry {\n  /**\n   * @param {T} item the item\n   * @param {Callback<R>} callback the callback\n   */\n  constructor(item, callback) {\n    this.item = item;\n    /** @type {typeof QUEUED_STATE | typeof PROCESSING_STATE | typeof DONE_STATE} */\n    this.state = QUEUED_STATE;\n    this.callback = callback;\n    /** @type {Callback<R>[] | undefined} */\n    this.callbacks = undefined;\n    this.result = undefined;\n    /** @type {WebpackError | undefined} */\n    this.error = undefined;\n  }\n}\n\n/**\n * @template T\n * @template K\n * @template R\n */\nclass AsyncQueue {\n  /**\n   * @param {Object} options options object\n   * @param {string=} options.name name of the queue\n   * @param {number=} options.parallelism how many items should be processed at once\n   * @param {AsyncQueue<any, any, any>=} options.parent parent queue, which will have priority over this queue and with shared parallelism\n   * @param {function(T): K=} options.getKey extract key from item\n   * @param {function(T, Callback<R>): void} options.processor async function to process items\n   */\n  constructor({\n    name,\n    parallelism,\n    parent,\n    processor,\n    getKey\n  }) {\n    this._name = name;\n    this._parallelism = parallelism || 1;\n    this._processor = processor;\n    this._getKey = getKey || ( /** @type {(T) => K} */item => ( /** @type {any} */item));\n    /** @type {Map<K, AsyncQueueEntry<T, K, R>>} */\n    this._entries = new Map();\n    /** @type {ArrayQueue<AsyncQueueEntry<T, K, R>>} */\n    this._queued = new ArrayQueue();\n    /** @type {AsyncQueue<any, any, any>[] | undefined} */\n    this._children = undefined;\n    this._activeTasks = 0;\n    this._willEnsureProcessing = false;\n    this._needProcessing = false;\n    this._stopped = false;\n    this._root = parent ? parent._root : this;\n    if (parent) {\n      if (this._root._children === undefined) {\n        this._root._children = [this];\n      } else {\n        this._root._children.push(this);\n      }\n    }\n    this.hooks = {\n      /** @type {AsyncSeriesHook<[T]>} */\n      beforeAdd: new AsyncSeriesHook([\"item\"]),\n      /** @type {SyncHook<[T]>} */\n      added: new SyncHook([\"item\"]),\n      /** @type {AsyncSeriesHook<[T]>} */\n      beforeStart: new AsyncSeriesHook([\"item\"]),\n      /** @type {SyncHook<[T]>} */\n      started: new SyncHook([\"item\"]),\n      /** @type {SyncHook<[T, Error, R]>} */\n      result: new SyncHook([\"item\", \"error\", \"result\"])\n    };\n    this._ensureProcessing = this._ensureProcessing.bind(this);\n  }\n\n  /**\n   * @param {T} item an item\n   * @param {Callback<R>} callback callback function\n   * @returns {void}\n   */\n  add(item, callback) {\n    if (this._stopped) return callback(new WebpackError(\"Queue was stopped\"));\n    this.hooks.beforeAdd.callAsync(item, err => {\n      if (err) {\n        callback(makeWebpackError(err, `AsyncQueue(${this._name}).hooks.beforeAdd`));\n        return;\n      }\n      const key = this._getKey(item);\n      const entry = this._entries.get(key);\n      if (entry !== undefined) {\n        if (entry.state === DONE_STATE) {\n          if (inHandleResult++ > 3) {\n            process.nextTick(() => callback(entry.error, entry.result));\n          } else {\n            callback(entry.error, entry.result);\n          }\n          inHandleResult--;\n        } else if (entry.callbacks === undefined) {\n          entry.callbacks = [callback];\n        } else {\n          entry.callbacks.push(callback);\n        }\n        return;\n      }\n      const newEntry = new AsyncQueueEntry(item, callback);\n      if (this._stopped) {\n        this.hooks.added.call(item);\n        this._root._activeTasks++;\n        process.nextTick(() => this._handleResult(newEntry, new WebpackError(\"Queue was stopped\")));\n      } else {\n        this._entries.set(key, newEntry);\n        this._queued.enqueue(newEntry);\n        const root = this._root;\n        root._needProcessing = true;\n        if (root._willEnsureProcessing === false) {\n          root._willEnsureProcessing = true;\n          setImmediate(root._ensureProcessing);\n        }\n        this.hooks.added.call(item);\n      }\n    });\n  }\n\n  /**\n   * @param {T} item an item\n   * @returns {void}\n   */\n  invalidate(item) {\n    const key = this._getKey(item);\n    const entry = /** @type {AsyncQueueEntry<T, K, R>} */\n    this._entries.get(key);\n    this._entries.delete(key);\n    if (entry.state === QUEUED_STATE) {\n      this._queued.delete(entry);\n    }\n  }\n\n  /**\n   * Waits for an already started item\n   * @param {T} item an item\n   * @param {Callback<R>} callback callback function\n   * @returns {void}\n   */\n  waitFor(item, callback) {\n    const key = this._getKey(item);\n    const entry = this._entries.get(key);\n    if (entry === undefined) {\n      return callback(new WebpackError(\"waitFor can only be called for an already started item\"));\n    }\n    if (entry.state === DONE_STATE) {\n      process.nextTick(() => callback(entry.error, entry.result));\n    } else if (entry.callbacks === undefined) {\n      entry.callbacks = [callback];\n    } else {\n      entry.callbacks.push(callback);\n    }\n  }\n\n  /**\n   * @returns {void}\n   */\n  stop() {\n    this._stopped = true;\n    const queue = this._queued;\n    this._queued = new ArrayQueue();\n    const root = this._root;\n    for (const entry of queue) {\n      this._entries.delete(this._getKey(entry.item));\n      root._activeTasks++;\n      this._handleResult(entry, new WebpackError(\"Queue was stopped\"));\n    }\n  }\n\n  /**\n   * @returns {void}\n   */\n  increaseParallelism() {\n    const root = this._root;\n    root._parallelism++;\n    /* istanbul ignore next */\n    if (root._willEnsureProcessing === false && root._needProcessing) {\n      root._willEnsureProcessing = true;\n      setImmediate(root._ensureProcessing);\n    }\n  }\n\n  /**\n   * @returns {void}\n   */\n  decreaseParallelism() {\n    const root = this._root;\n    root._parallelism--;\n  }\n\n  /**\n   * @param {T} item an item\n   * @returns {boolean} true, if the item is currently being processed\n   */\n  isProcessing(item) {\n    const key = this._getKey(item);\n    const entry = this._entries.get(key);\n    return entry !== undefined && entry.state === PROCESSING_STATE;\n  }\n\n  /**\n   * @param {T} item an item\n   * @returns {boolean} true, if the item is currently queued\n   */\n  isQueued(item) {\n    const key = this._getKey(item);\n    const entry = this._entries.get(key);\n    return entry !== undefined && entry.state === QUEUED_STATE;\n  }\n\n  /**\n   * @param {T} item an item\n   * @returns {boolean} true, if the item is currently queued\n   */\n  isDone(item) {\n    const key = this._getKey(item);\n    const entry = this._entries.get(key);\n    return entry !== undefined && entry.state === DONE_STATE;\n  }\n\n  /**\n   * @returns {void}\n   */\n  _ensureProcessing() {\n    while (this._activeTasks < this._parallelism) {\n      const entry = this._queued.dequeue();\n      if (entry === undefined) break;\n      this._activeTasks++;\n      entry.state = PROCESSING_STATE;\n      this._startProcessing(entry);\n    }\n    this._willEnsureProcessing = false;\n    if (this._queued.length > 0) return;\n    if (this._children !== undefined) {\n      for (const child of this._children) {\n        while (this._activeTasks < this._parallelism) {\n          const entry = child._queued.dequeue();\n          if (entry === undefined) break;\n          this._activeTasks++;\n          entry.state = PROCESSING_STATE;\n          child._startProcessing(entry);\n        }\n        if (child._queued.length > 0) return;\n      }\n    }\n    if (!this._willEnsureProcessing) this._needProcessing = false;\n  }\n\n  /**\n   * @param {AsyncQueueEntry<T, K, R>} entry the entry\n   * @returns {void}\n   */\n  _startProcessing(entry) {\n    this.hooks.beforeStart.callAsync(entry.item, err => {\n      if (err) {\n        this._handleResult(entry, makeWebpackError(err, `AsyncQueue(${this._name}).hooks.beforeStart`));\n        return;\n      }\n      let inCallback = false;\n      try {\n        this._processor(entry.item, (e, r) => {\n          inCallback = true;\n          this._handleResult(entry, e, r);\n        });\n      } catch (err) {\n        if (inCallback) throw err;\n        this._handleResult(entry, err, null);\n      }\n      this.hooks.started.call(entry.item);\n    });\n  }\n\n  /**\n   * @param {AsyncQueueEntry<T, K, R>} entry the entry\n   * @param {WebpackError=} err error, if any\n   * @param {R=} result result, if any\n   * @returns {void}\n   */\n  _handleResult(entry, err, result) {\n    this.hooks.result.callAsync(entry.item, err, result, hookError => {\n      const error = hookError ? makeWebpackError(hookError, `AsyncQueue(${this._name}).hooks.result`) : err;\n      const callback = entry.callback;\n      const callbacks = entry.callbacks;\n      entry.state = DONE_STATE;\n      entry.callback = undefined;\n      entry.callbacks = undefined;\n      entry.result = result;\n      entry.error = error;\n      const root = this._root;\n      root._activeTasks--;\n      if (root._willEnsureProcessing === false && root._needProcessing) {\n        root._willEnsureProcessing = true;\n        setImmediate(root._ensureProcessing);\n      }\n      if (inHandleResult++ > 3) {\n        process.nextTick(() => {\n          callback(error, result);\n          if (callbacks !== undefined) {\n            for (const callback of callbacks) {\n              callback(error, result);\n            }\n          }\n        });\n      } else {\n        callback(error, result);\n        if (callbacks !== undefined) {\n          for (const callback of callbacks) {\n            callback(error, result);\n          }\n        }\n      }\n      inHandleResult--;\n    });\n  }\n  clear() {\n    this._entries.clear();\n    this._queued.clear();\n    this._activeTasks = 0;\n    this._willEnsureProcessing = false;\n    this._needProcessing = false;\n    this._stopped = false;\n  }\n}\nmodule.exports = AsyncQueue;","map":{"version":3,"names":["SyncHook","AsyncSeriesHook","require","makeWebpackError","WebpackError","ArrayQueue","QUEUED_STATE","PROCESSING_STATE","DONE_STATE","inHandleResult","AsyncQueueEntry","constructor","item","callback","state","callbacks","undefined","result","error","AsyncQueue","name","parallelism","parent","processor","getKey","_name","_parallelism","_processor","_getKey","_entries","Map","_queued","_children","_activeTasks","_willEnsureProcessing","_needProcessing","_stopped","_root","push","hooks","beforeAdd","added","beforeStart","started","_ensureProcessing","bind","add","callAsync","err","key","entry","get","process","nextTick","newEntry","call","_handleResult","set","enqueue","root","setImmediate","invalidate","delete","waitFor","stop","queue","increaseParallelism","decreaseParallelism","isProcessing","isQueued","isDone","dequeue","_startProcessing","length","child","inCallback","e","r","hookError","clear","module","exports"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/util/AsyncQueue.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { SyncHook, AsyncSeriesHook } = require(\"tapable\");\nconst { makeWebpackError } = require(\"../HookWebpackError\");\nconst WebpackError = require(\"../WebpackError\");\nconst ArrayQueue = require(\"./ArrayQueue\");\n\nconst QUEUED_STATE = 0;\nconst PROCESSING_STATE = 1;\nconst DONE_STATE = 2;\n\nlet inHandleResult = 0;\n\n/**\n * @template T\n * @callback Callback\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n */\n\n/**\n * @template T\n * @template K\n * @template R\n */\nclass AsyncQueueEntry {\n\t/**\n\t * @param {T} item the item\n\t * @param {Callback<R>} callback the callback\n\t */\n\tconstructor(item, callback) {\n\t\tthis.item = item;\n\t\t/** @type {typeof QUEUED_STATE | typeof PROCESSING_STATE | typeof DONE_STATE} */\n\t\tthis.state = QUEUED_STATE;\n\t\tthis.callback = callback;\n\t\t/** @type {Callback<R>[] | undefined} */\n\t\tthis.callbacks = undefined;\n\t\tthis.result = undefined;\n\t\t/** @type {WebpackError | undefined} */\n\t\tthis.error = undefined;\n\t}\n}\n\n/**\n * @template T\n * @template K\n * @template R\n */\nclass AsyncQueue {\n\t/**\n\t * @param {Object} options options object\n\t * @param {string=} options.name name of the queue\n\t * @param {number=} options.parallelism how many items should be processed at once\n\t * @param {AsyncQueue<any, any, any>=} options.parent parent queue, which will have priority over this queue and with shared parallelism\n\t * @param {function(T): K=} options.getKey extract key from item\n\t * @param {function(T, Callback<R>): void} options.processor async function to process items\n\t */\n\tconstructor({ name, parallelism, parent, processor, getKey }) {\n\t\tthis._name = name;\n\t\tthis._parallelism = parallelism || 1;\n\t\tthis._processor = processor;\n\t\tthis._getKey =\n\t\t\tgetKey || /** @type {(T) => K} */ (item => /** @type {any} */ (item));\n\t\t/** @type {Map<K, AsyncQueueEntry<T, K, R>>} */\n\t\tthis._entries = new Map();\n\t\t/** @type {ArrayQueue<AsyncQueueEntry<T, K, R>>} */\n\t\tthis._queued = new ArrayQueue();\n\t\t/** @type {AsyncQueue<any, any, any>[] | undefined} */\n\t\tthis._children = undefined;\n\t\tthis._activeTasks = 0;\n\t\tthis._willEnsureProcessing = false;\n\t\tthis._needProcessing = false;\n\t\tthis._stopped = false;\n\t\tthis._root = parent ? parent._root : this;\n\t\tif (parent) {\n\t\t\tif (this._root._children === undefined) {\n\t\t\t\tthis._root._children = [this];\n\t\t\t} else {\n\t\t\t\tthis._root._children.push(this);\n\t\t\t}\n\t\t}\n\n\t\tthis.hooks = {\n\t\t\t/** @type {AsyncSeriesHook<[T]>} */\n\t\t\tbeforeAdd: new AsyncSeriesHook([\"item\"]),\n\t\t\t/** @type {SyncHook<[T]>} */\n\t\t\tadded: new SyncHook([\"item\"]),\n\t\t\t/** @type {AsyncSeriesHook<[T]>} */\n\t\t\tbeforeStart: new AsyncSeriesHook([\"item\"]),\n\t\t\t/** @type {SyncHook<[T]>} */\n\t\t\tstarted: new SyncHook([\"item\"]),\n\t\t\t/** @type {SyncHook<[T, Error, R]>} */\n\t\t\tresult: new SyncHook([\"item\", \"error\", \"result\"])\n\t\t};\n\n\t\tthis._ensureProcessing = this._ensureProcessing.bind(this);\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @param {Callback<R>} callback callback function\n\t * @returns {void}\n\t */\n\tadd(item, callback) {\n\t\tif (this._stopped) return callback(new WebpackError(\"Queue was stopped\"));\n\t\tthis.hooks.beforeAdd.callAsync(item, err => {\n\t\t\tif (err) {\n\t\t\t\tcallback(\n\t\t\t\t\tmakeWebpackError(err, `AsyncQueue(${this._name}).hooks.beforeAdd`)\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst key = this._getKey(item);\n\t\t\tconst entry = this._entries.get(key);\n\t\t\tif (entry !== undefined) {\n\t\t\t\tif (entry.state === DONE_STATE) {\n\t\t\t\t\tif (inHandleResult++ > 3) {\n\t\t\t\t\t\tprocess.nextTick(() => callback(entry.error, entry.result));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcallback(entry.error, entry.result);\n\t\t\t\t\t}\n\t\t\t\t\tinHandleResult--;\n\t\t\t\t} else if (entry.callbacks === undefined) {\n\t\t\t\t\tentry.callbacks = [callback];\n\t\t\t\t} else {\n\t\t\t\t\tentry.callbacks.push(callback);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst newEntry = new AsyncQueueEntry(item, callback);\n\t\t\tif (this._stopped) {\n\t\t\t\tthis.hooks.added.call(item);\n\t\t\t\tthis._root._activeTasks++;\n\t\t\t\tprocess.nextTick(() =>\n\t\t\t\t\tthis._handleResult(newEntry, new WebpackError(\"Queue was stopped\"))\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis._entries.set(key, newEntry);\n\t\t\t\tthis._queued.enqueue(newEntry);\n\t\t\t\tconst root = this._root;\n\t\t\t\troot._needProcessing = true;\n\t\t\t\tif (root._willEnsureProcessing === false) {\n\t\t\t\t\troot._willEnsureProcessing = true;\n\t\t\t\t\tsetImmediate(root._ensureProcessing);\n\t\t\t\t}\n\t\t\t\tthis.hooks.added.call(item);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {void}\n\t */\n\tinvalidate(item) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry =\n\t\t\t/** @type {AsyncQueueEntry<T, K, R>} */\n\t\t\t(this._entries.get(key));\n\t\tthis._entries.delete(key);\n\t\tif (entry.state === QUEUED_STATE) {\n\t\t\tthis._queued.delete(entry);\n\t\t}\n\t}\n\n\t/**\n\t * Waits for an already started item\n\t * @param {T} item an item\n\t * @param {Callback<R>} callback callback function\n\t * @returns {void}\n\t */\n\twaitFor(item, callback) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\tif (entry === undefined) {\n\t\t\treturn callback(\n\t\t\t\tnew WebpackError(\n\t\t\t\t\t\"waitFor can only be called for an already started item\"\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\tif (entry.state === DONE_STATE) {\n\t\t\tprocess.nextTick(() => callback(entry.error, entry.result));\n\t\t} else if (entry.callbacks === undefined) {\n\t\t\tentry.callbacks = [callback];\n\t\t} else {\n\t\t\tentry.callbacks.push(callback);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tstop() {\n\t\tthis._stopped = true;\n\t\tconst queue = this._queued;\n\t\tthis._queued = new ArrayQueue();\n\t\tconst root = this._root;\n\t\tfor (const entry of queue) {\n\t\t\tthis._entries.delete(this._getKey(entry.item));\n\t\t\troot._activeTasks++;\n\t\t\tthis._handleResult(entry, new WebpackError(\"Queue was stopped\"));\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tincreaseParallelism() {\n\t\tconst root = this._root;\n\t\troot._parallelism++;\n\t\t/* istanbul ignore next */\n\t\tif (root._willEnsureProcessing === false && root._needProcessing) {\n\t\t\troot._willEnsureProcessing = true;\n\t\t\tsetImmediate(root._ensureProcessing);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tdecreaseParallelism() {\n\t\tconst root = this._root;\n\t\troot._parallelism--;\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {boolean} true, if the item is currently being processed\n\t */\n\tisProcessing(item) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\treturn entry !== undefined && entry.state === PROCESSING_STATE;\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {boolean} true, if the item is currently queued\n\t */\n\tisQueued(item) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\treturn entry !== undefined && entry.state === QUEUED_STATE;\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {boolean} true, if the item is currently queued\n\t */\n\tisDone(item) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\treturn entry !== undefined && entry.state === DONE_STATE;\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\t_ensureProcessing() {\n\t\twhile (this._activeTasks < this._parallelism) {\n\t\t\tconst entry = this._queued.dequeue();\n\t\t\tif (entry === undefined) break;\n\t\t\tthis._activeTasks++;\n\t\t\tentry.state = PROCESSING_STATE;\n\t\t\tthis._startProcessing(entry);\n\t\t}\n\t\tthis._willEnsureProcessing = false;\n\t\tif (this._queued.length > 0) return;\n\t\tif (this._children !== undefined) {\n\t\t\tfor (const child of this._children) {\n\t\t\t\twhile (this._activeTasks < this._parallelism) {\n\t\t\t\t\tconst entry = child._queued.dequeue();\n\t\t\t\t\tif (entry === undefined) break;\n\t\t\t\t\tthis._activeTasks++;\n\t\t\t\t\tentry.state = PROCESSING_STATE;\n\t\t\t\t\tchild._startProcessing(entry);\n\t\t\t\t}\n\t\t\t\tif (child._queued.length > 0) return;\n\t\t\t}\n\t\t}\n\t\tif (!this._willEnsureProcessing) this._needProcessing = false;\n\t}\n\n\t/**\n\t * @param {AsyncQueueEntry<T, K, R>} entry the entry\n\t * @returns {void}\n\t */\n\t_startProcessing(entry) {\n\t\tthis.hooks.beforeStart.callAsync(entry.item, err => {\n\t\t\tif (err) {\n\t\t\t\tthis._handleResult(\n\t\t\t\t\tentry,\n\t\t\t\t\tmakeWebpackError(err, `AsyncQueue(${this._name}).hooks.beforeStart`)\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet inCallback = false;\n\t\t\ttry {\n\t\t\t\tthis._processor(entry.item, (e, r) => {\n\t\t\t\t\tinCallback = true;\n\t\t\t\t\tthis._handleResult(entry, e, r);\n\t\t\t\t});\n\t\t\t} catch (err) {\n\t\t\t\tif (inCallback) throw err;\n\t\t\t\tthis._handleResult(entry, err, null);\n\t\t\t}\n\t\t\tthis.hooks.started.call(entry.item);\n\t\t});\n\t}\n\n\t/**\n\t * @param {AsyncQueueEntry<T, K, R>} entry the entry\n\t * @param {WebpackError=} err error, if any\n\t * @param {R=} result result, if any\n\t * @returns {void}\n\t */\n\t_handleResult(entry, err, result) {\n\t\tthis.hooks.result.callAsync(entry.item, err, result, hookError => {\n\t\t\tconst error = hookError\n\t\t\t\t? makeWebpackError(hookError, `AsyncQueue(${this._name}).hooks.result`)\n\t\t\t\t: err;\n\n\t\t\tconst callback = entry.callback;\n\t\t\tconst callbacks = entry.callbacks;\n\t\t\tentry.state = DONE_STATE;\n\t\t\tentry.callback = undefined;\n\t\t\tentry.callbacks = undefined;\n\t\t\tentry.result = result;\n\t\t\tentry.error = error;\n\n\t\t\tconst root = this._root;\n\t\t\troot._activeTasks--;\n\t\t\tif (root._willEnsureProcessing === false && root._needProcessing) {\n\t\t\t\troot._willEnsureProcessing = true;\n\t\t\t\tsetImmediate(root._ensureProcessing);\n\t\t\t}\n\n\t\t\tif (inHandleResult++ > 3) {\n\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\tcallback(error, result);\n\t\t\t\t\tif (callbacks !== undefined) {\n\t\t\t\t\t\tfor (const callback of callbacks) {\n\t\t\t\t\t\t\tcallback(error, result);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcallback(error, result);\n\t\t\t\tif (callbacks !== undefined) {\n\t\t\t\t\tfor (const callback of callbacks) {\n\t\t\t\t\t\tcallback(error, result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tinHandleResult--;\n\t\t});\n\t}\n\n\tclear() {\n\t\tthis._entries.clear();\n\t\tthis._queued.clear();\n\t\tthis._activeTasks = 0;\n\t\tthis._willEnsureProcessing = false;\n\t\tthis._needProcessing = false;\n\t\tthis._stopped = false;\n\t}\n}\n\nmodule.exports = AsyncQueue;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
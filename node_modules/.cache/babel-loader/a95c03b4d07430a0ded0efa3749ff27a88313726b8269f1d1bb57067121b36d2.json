{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef } from 'react';\nconst useIntersectionObserver = (options, attribute) => {\n  _s();\n  const [activeIndex, setActiveIndex] = useState(null);\n  const containerRef = useRef(null);\n  const observer = useRef(null);\n  useEffect(() => {\n    const callback = entries => {\n      entries.forEach(entry => {\n        if (entry.intersectionRatio > 0) {\n          const index = entry.target.getAttribute(attribute);\n          setActiveIndex(index);\n        }\n      });\n    };\n    observer.current = new IntersectionObserver(callback, options);\n    const elements = containerRef.current.querySelectorAll(`[${attribute}]`);\n    elements.forEach(el => observer.current.observe(el));\n    return () => {\n      if (observer.current) {\n        observer.current.disconnect();\n      }\n    };\n  }, [options, attribute]);\n  return [containerRef, activeIndex];\n};\n_s(useIntersectionObserver, \"jK7trhOSXF5OSordHfYrAYTuVXs=\");\nexport default useIntersectionObserver;","map":{"version":3,"names":["useState","useEffect","useRef","useIntersectionObserver","options","attribute","_s","activeIndex","setActiveIndex","containerRef","observer","callback","entries","forEach","entry","intersectionRatio","index","target","getAttribute","current","IntersectionObserver","elements","querySelectorAll","el","observe","disconnect"],"sources":["/Volumes/storage/projects/project-mcnt/src/components/Services/useIntersectionObserver.js"],"sourcesContent":["import { useState, useEffect, useRef } from 'react';\n\nconst useIntersectionObserver = (options, attribute) => {\n    const [activeIndex, setActiveIndex] = useState(null);\n    const containerRef = useRef(null);\n    const observer = useRef(null);\n\n    useEffect(() => {\n        const callback = (entries) => {\n            entries.forEach(entry => {\n                if (entry.intersectionRatio > 0) {\n                    const index = entry.target.getAttribute(attribute);\n                    setActiveIndex(index);\n                }\n            });\n        };\n\n        observer.current = new IntersectionObserver(callback, options);\n\n        const elements = containerRef.current.querySelectorAll(`[${attribute}]`);\n        elements.forEach(el => observer.current.observe(el));\n\n        return () => {\n            if (observer.current) {\n                observer.current.disconnect();\n            }\n        };\n    }, [options, attribute]);\n\n    return [containerRef, activeIndex];\n};\n\nexport default useIntersectionObserver;\n"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAEnD,MAAMC,uBAAuB,GAAGA,CAACC,OAAO,EAAEC,SAAS,KAAK;EAAAC,EAAA;EACpD,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGR,QAAQ,CAAC,IAAI,CAAC;EACpD,MAAMS,YAAY,GAAGP,MAAM,CAAC,IAAI,CAAC;EACjC,MAAMQ,QAAQ,GAAGR,MAAM,CAAC,IAAI,CAAC;EAE7BD,SAAS,CAAC,MAAM;IACZ,MAAMU,QAAQ,GAAIC,OAAO,IAAK;MAC1BA,OAAO,CAACC,OAAO,CAACC,KAAK,IAAI;QACrB,IAAIA,KAAK,CAACC,iBAAiB,GAAG,CAAC,EAAE;UAC7B,MAAMC,KAAK,GAAGF,KAAK,CAACG,MAAM,CAACC,YAAY,CAACb,SAAS,CAAC;UAClDG,cAAc,CAACQ,KAAK,CAAC;QACzB;MACJ,CAAC,CAAC;IACN,CAAC;IAEDN,QAAQ,CAACS,OAAO,GAAG,IAAIC,oBAAoB,CAACT,QAAQ,EAAEP,OAAO,CAAC;IAE9D,MAAMiB,QAAQ,GAAGZ,YAAY,CAACU,OAAO,CAACG,gBAAgB,CAAC,IAAIjB,SAAS,GAAG,CAAC;IACxEgB,QAAQ,CAACR,OAAO,CAACU,EAAE,IAAIb,QAAQ,CAACS,OAAO,CAACK,OAAO,CAACD,EAAE,CAAC,CAAC;IAEpD,OAAO,MAAM;MACT,IAAIb,QAAQ,CAACS,OAAO,EAAE;QAClBT,QAAQ,CAACS,OAAO,CAACM,UAAU,CAAC,CAAC;MACjC;IACJ,CAAC;EACL,CAAC,EAAE,CAACrB,OAAO,EAAEC,SAAS,CAAC,CAAC;EAExB,OAAO,CAACI,YAAY,EAAEF,WAAW,CAAC;AACtC,CAAC;AAACD,EAAA,CA5BIH,uBAAuB;AA8B7B,eAAeA,uBAAuB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
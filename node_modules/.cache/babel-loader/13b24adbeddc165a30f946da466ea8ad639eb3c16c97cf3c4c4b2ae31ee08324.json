{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\nconst {\n  connectChunkGroupParentAndChild\n} = require(\"./GraphHelpers\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst {\n  getEntryRuntime,\n  mergeRuntime\n} = require(\"./util/runtime\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./ModuleGraphConnection\").ConnectionState} ConnectionState */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {Object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n * @property {ChunkGroupInfo} chunkGroupInfo\n */\n\n/**\n * @typedef {Object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {RuntimeSpec} runtime the runtimes\n * @property {bigint | undefined} minAvailableModules current minimal set of modules available at this point\n * @property {bigint[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {Set<Module>=} skippedItems modules that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<[Module, ModuleGraphConnection[]]>=} skippedModuleConnections referenced modules that where skipped because they were not active in this runtime\n * @property {bigint | undefined} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroupInfo> | undefined} children set of children chunk groups, that will be revisited when availableModules shrink\n * @property {Set<ChunkGroupInfo> | undefined} availableSources set of chunk groups that are the source for minAvailableModules\n * @property {Set<ChunkGroupInfo> | undefined} availableChildren set of chunk groups which depend on the this chunk group as availableSource\n * @property {number} preOrderIndex next pre order index\n * @property {number} postOrderIndex next post order index\n * @property {boolean} chunkLoading has a chunk loading mechanism\n * @property {boolean} asyncChunks create async chunks\n */\n\n/**\n * @typedef {Object} BlockChunkGroupConnection\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\n/** @typedef {(Module | ConnectionState | ModuleGraphConnection)[]} BlockModulesInTuples */\n/** @typedef {(Module | ConnectionState | ModuleGraphConnection[])[]} BlockModulesInFlattenTuples */\n/** @typedef {Map<DependenciesBlock, BlockModulesInFlattenTuples>} BlockModulesMap */\n/** @typedef {Map<Chunk, bigint>} MaskByChunk */\n/** @typedef {Set<DependenciesBlock>} BlocksWithNestedBlocks */\n/** @typedef {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} BlockConnections */\n/** @typedef {Map<ChunkGroup, ChunkGroupInfo>} ChunkGroupInfoMap */\n/** @typedef {Set<ChunkGroup>} AllCreatedChunkGroups */\n/** @typedef {Map<Entrypoint, Module[]>} InputEntrypointsAndModules */\n\nconst ZERO_BIGINT = BigInt(0);\nconst ONE_BIGINT = BigInt(1);\n\n/**\n * @param {bigint} mask The mask to test\n * @param {number} ordinal The ordinal of the bit to test\n * @returns {boolean} If the ordinal-th bit is set in the mask\n */\nconst isOrdinalSetInMask = (mask, ordinal) => BigInt.asUintN(1, mask >> BigInt(ordinal)) !== ZERO_BIGINT;\n\n/**\n * @param {ModuleGraphConnection[]} connections list of connections\n * @param {RuntimeSpec} runtime for which runtime\n * @returns {ConnectionState} connection state\n */\nconst getActiveStateOfConnections = (connections, runtime) => {\n  let merged = connections[0].getActiveState(runtime);\n  if (merged === true) return true;\n  for (let i = 1; i < connections.length; i++) {\n    const c = connections[i];\n    merged = ModuleGraphConnection.addConnectionStates(merged, c.getActiveState(runtime));\n    if (merged === true) return true;\n  }\n  return merged;\n};\n\n/**\n * @param {Module} module module\n * @param {ModuleGraph} moduleGraph module graph\n * @param {RuntimeSpec} runtime runtime\n * @param {BlockModulesMap} blockModulesMap block modules map\n */\nconst extractBlockModules = (module, moduleGraph, runtime, blockModulesMap) => {\n  /** @type {DependenciesBlock | undefined} */\n  let blockCache;\n  /** @type {BlockModulesInTuples | undefined} */\n  let modules;\n\n  /** @type {BlockModulesInTuples[]} */\n  const arrays = [];\n\n  /** @type {DependenciesBlock[]} */\n  const queue = [module];\n  while (queue.length > 0) {\n    const block = /** @type {DependenciesBlock} */queue.pop();\n    /** @type {Module[]} */\n    const arr = [];\n    arrays.push(arr);\n    blockModulesMap.set(block, arr);\n    for (const b of block.blocks) {\n      queue.push(b);\n    }\n  }\n  for (const connection of moduleGraph.getOutgoingConnections(module)) {\n    const d = connection.dependency;\n    // We skip connections without dependency\n    if (!d) continue;\n    const m = connection.module;\n    // We skip connections without Module pointer\n    if (!m) continue;\n    // We skip weak connections\n    if (connection.weak) continue;\n    const block = moduleGraph.getParentBlock(d);\n    let index = moduleGraph.getParentBlockIndex(d);\n\n    // deprecated fallback\n    if (index < 0) {\n      index = /** @type {DependenciesBlock} */block.dependencies.indexOf(d);\n    }\n    if (blockCache !== block) {\n      modules = /** @type {BlockModulesInTuples} */\n\n      blockModulesMap.get(blockCache = /** @type {DependenciesBlock} */block);\n    }\n    const i = index * 3;\n    /** @type {BlockModulesInTuples} */\n    modules[i] = m;\n    /** @type {BlockModulesInTuples} */\n    modules[i + 1] = connection.getActiveState(runtime);\n    /** @type {BlockModulesInTuples} */\n    modules[i + 2] = connection;\n  }\n  for (const modules of arrays) {\n    if (modules.length === 0) continue;\n    let indexMap;\n    let length = 0;\n    outer: for (let j = 0; j < modules.length; j += 3) {\n      const m = modules[j];\n      if (m === undefined) continue;\n      const state = /** @type {ConnectionState} */modules[j + 1];\n      const connection = /** @type {ModuleGraphConnection} */modules[j + 2];\n      if (indexMap === undefined) {\n        let i = 0;\n        for (; i < length; i += 3) {\n          if (modules[i] === m) {\n            const merged = /** @type {ConnectionState} */modules[i + 1];\n            /** @type {ModuleGraphConnection[]} */\n            ( /** @type {unknown} */modules[i + 2]).push(connection);\n            if (merged === true) continue outer;\n            modules[i + 1] = ModuleGraphConnection.addConnectionStates(merged, state);\n            continue outer;\n          }\n        }\n        modules[length] = m;\n        length++;\n        modules[length] = state;\n        length++;\n        /** @type {ModuleGraphConnection[]} */\n        /** @type {unknown} */modules[length] = [connection];\n        length++;\n        if (length > 30) {\n          // To avoid worse case performance, we will use an index map for\n          // linear cost access, which allows to maintain O(n) complexity\n          // while keeping allocations down to a minimum\n          indexMap = new Map();\n          for (let i = 0; i < length; i += 3) {\n            indexMap.set(modules[i], i + 1);\n          }\n        }\n      } else {\n        const idx = indexMap.get(m);\n        if (idx !== undefined) {\n          const merged = /** @type {ConnectionState} */modules[idx];\n          /** @type {ModuleGraphConnection[]} */\n          ( /** @type {unknown} */modules[idx + 1]).push(connection);\n          if (merged === true) continue outer;\n          modules[idx] = ModuleGraphConnection.addConnectionStates(merged, state);\n        } else {\n          modules[length] = m;\n          length++;\n          modules[length] = state;\n          indexMap.set(m, length);\n          length++;\n          /** @type {ModuleGraphConnection[]} */\n          /** @type {unknown} */\n          modules[length] = [connection];\n          length++;\n        }\n      }\n    }\n    modules.length = length;\n  }\n};\n\n/**\n *\n * @param {Logger} logger a logger\n * @param {Compilation} compilation the compilation\n * @param {InputEntrypointsAndModules} inputEntrypointsAndModules chunk groups which are processed with the modules\n * @param {ChunkGroupInfoMap} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {BlockConnections} blockConnections connection for blocks\n * @param {BlocksWithNestedBlocks} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {AllCreatedChunkGroups} allCreatedChunkGroups filled with all chunk groups that are created here\n * @param {MaskByChunk} maskByChunk module content mask by chunk\n */\nconst visitModules = (logger, compilation, inputEntrypointsAndModules, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups, maskByChunk) => {\n  const {\n    moduleGraph,\n    chunkGraph,\n    moduleMemCaches\n  } = compilation;\n  const blockModulesRuntimeMap = new Map();\n\n  /** @type {BlockModulesMap | undefined} */\n  let blockModulesMap;\n\n  /** @type {Map<Module, number>} */\n  const ordinalByModule = new Map();\n\n  /**\n   * @param {Module} module The module to look up\n   * @returns {number} The ordinal of the module in masks\n   */\n  const getModuleOrdinal = module => {\n    let ordinal = ordinalByModule.get(module);\n    if (ordinal === undefined) {\n      ordinal = ordinalByModule.size;\n      ordinalByModule.set(module, ordinal);\n    }\n    return ordinal;\n  };\n  for (const chunk of compilation.chunks) {\n    let mask = ZERO_BIGINT;\n    for (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n      mask |= ONE_BIGINT << BigInt(getModuleOrdinal(m));\n    }\n    maskByChunk.set(chunk, mask);\n  }\n\n  /**\n   *\n   * @param {DependenciesBlock} block block\n   * @param {RuntimeSpec} runtime runtime\n   * @returns {BlockModulesInFlattenTuples} block modules in flatten tuples\n   */\n  const getBlockModules = (block, runtime) => {\n    blockModulesMap = blockModulesRuntimeMap.get(runtime);\n    if (blockModulesMap === undefined) {\n      blockModulesMap = new Map();\n      blockModulesRuntimeMap.set(runtime, blockModulesMap);\n    }\n    let blockModules = blockModulesMap.get(block);\n    if (blockModules !== undefined) return blockModules;\n    const module = /** @type {Module} */block.getRootBlock();\n    const memCache = moduleMemCaches && moduleMemCaches.get(module);\n    if (memCache !== undefined) {\n      const map = memCache.provide(\"bundleChunkGraph.blockModules\", runtime, () => {\n        logger.time(\"visitModules: prepare\");\n        const map = new Map();\n        extractBlockModules(module, moduleGraph, runtime, map);\n        logger.timeAggregate(\"visitModules: prepare\");\n        return map;\n      });\n      for (const [block, blockModules] of map) blockModulesMap.set(block, blockModules);\n      return map.get(block);\n    } else {\n      logger.time(\"visitModules: prepare\");\n      extractBlockModules(module, moduleGraph, runtime, blockModulesMap);\n      blockModules = /** @type {BlockModulesInFlattenTuples} */\n      blockModulesMap.get(block);\n      logger.timeAggregate(\"visitModules: prepare\");\n      return blockModules;\n    }\n  };\n  let statProcessedQueueItems = 0;\n  let statProcessedBlocks = 0;\n  let statConnectedChunkGroups = 0;\n  let statProcessedChunkGroupsForMerging = 0;\n  let statMergedAvailableModuleSets = 0;\n  let statForkedAvailableModules = 0;\n  let statForkedAvailableModulesCount = 0;\n  let statForkedAvailableModulesCountPlus = 0;\n  let statForkedMergedModulesCount = 0;\n  let statForkedMergedModulesCountPlus = 0;\n  let statForkedResultModulesCount = 0;\n  let statChunkGroupInfoUpdated = 0;\n  let statChildChunkGroupsReconnected = 0;\n  let nextChunkGroupIndex = 0;\n  let nextFreeModulePreOrderIndex = 0;\n  let nextFreeModulePostOrderIndex = 0;\n\n  /** @type {Map<DependenciesBlock, ChunkGroupInfo>} */\n  const blockChunkGroups = new Map();\n\n  /** @type {Map<ChunkGroupInfo, DependenciesBlock>} */\n  const blockByChunkGroups = new Map();\n\n  /** @type {Map<string, ChunkGroupInfo>} */\n  const namedChunkGroups = new Map();\n\n  /** @type {Map<string, ChunkGroupInfo>} */\n  const namedAsyncEntrypoints = new Map();\n\n  /** @type {Set<ChunkGroupInfo>} */\n  const outdatedOrderIndexChunkGroups = new Set();\n  const ADD_AND_ENTER_ENTRY_MODULE = 0;\n  const ADD_AND_ENTER_MODULE = 1;\n  const ENTER_MODULE = 2;\n  const PROCESS_BLOCK = 3;\n  const PROCESS_ENTRY_BLOCK = 4;\n  const LEAVE_MODULE = 5;\n\n  /** @type {QueueItem[]} */\n  let queue = [];\n\n  /** @type {Map<ChunkGroupInfo, Set<ChunkGroupInfo>>} */\n  const queueConnect = new Map();\n  /** @type {Set<ChunkGroupInfo>} */\n  const chunkGroupsForCombining = new Set();\n\n  // Fill queue with entrypoint modules\n  // Create ChunkGroupInfo for entrypoints\n  for (const [chunkGroup, modules] of inputEntrypointsAndModules) {\n    const runtime = getEntryRuntime(compilation, /** @type {string} */chunkGroup.name, chunkGroup.options);\n    /** @type {ChunkGroupInfo} */\n    const chunkGroupInfo = {\n      chunkGroup,\n      runtime,\n      minAvailableModules: undefined,\n      availableModulesToBeMerged: [],\n      skippedItems: undefined,\n      resultingAvailableModules: undefined,\n      children: undefined,\n      availableSources: undefined,\n      availableChildren: undefined,\n      preOrderIndex: 0,\n      postOrderIndex: 0,\n      chunkLoading: chunkGroup.options.chunkLoading !== undefined ? chunkGroup.options.chunkLoading !== false : compilation.outputOptions.chunkLoading !== false,\n      asyncChunks: chunkGroup.options.asyncChunks !== undefined ? chunkGroup.options.asyncChunks : compilation.outputOptions.asyncChunks !== false\n    };\n    chunkGroup.index = nextChunkGroupIndex++;\n    if (chunkGroup.getNumberOfParents() > 0) {\n      // minAvailableModules for child entrypoints are unknown yet, set to undefined.\n      // This means no module is added until other sets are merged into\n      // this minAvailableModules (by the parent entrypoints)\n      const skippedItems = new Set(modules);\n      chunkGroupInfo.skippedItems = skippedItems;\n      chunkGroupsForCombining.add(chunkGroupInfo);\n    } else {\n      // The application may start here: We start with an empty list of available modules\n      chunkGroupInfo.minAvailableModules = ZERO_BIGINT;\n      const chunk = chunkGroup.getEntrypointChunk();\n      for (const module of modules) {\n        queue.push({\n          action: ADD_AND_ENTER_MODULE,\n          block: module,\n          module,\n          chunk,\n          chunkGroup,\n          chunkGroupInfo\n        });\n      }\n    }\n    chunkGroupInfoMap.set(chunkGroup, chunkGroupInfo);\n    if (chunkGroup.name) {\n      namedChunkGroups.set(chunkGroup.name, chunkGroupInfo);\n    }\n  }\n  // Fill availableSources with parent-child dependencies between entrypoints\n  for (const chunkGroupInfo of chunkGroupsForCombining) {\n    const {\n      chunkGroup\n    } = chunkGroupInfo;\n    chunkGroupInfo.availableSources = new Set();\n    for (const parent of chunkGroup.parentsIterable) {\n      const parentChunkGroupInfo = /** @type {ChunkGroupInfo} */\n      chunkGroupInfoMap.get(parent);\n      chunkGroupInfo.availableSources.add(parentChunkGroupInfo);\n      if (parentChunkGroupInfo.availableChildren === undefined) {\n        parentChunkGroupInfo.availableChildren = new Set();\n      }\n      parentChunkGroupInfo.availableChildren.add(chunkGroupInfo);\n    }\n  }\n  // pop() is used to read from the queue\n  // so it need to be reversed to be iterated in\n  // correct order\n  queue.reverse();\n\n  /** @type {Set<ChunkGroupInfo>} */\n  const outdatedChunkGroupInfo = new Set();\n  /** @type {Set<ChunkGroupInfo>} */\n  const chunkGroupsForMerging = new Set();\n  /** @type {QueueItem[]} */\n  let queueDelayed = [];\n\n  /** @type {[Module, ModuleGraphConnection[]][]} */\n  const skipConnectionBuffer = [];\n  /** @type {Module[]} */\n  const skipBuffer = [];\n  /** @type {QueueItem[]} */\n  const queueBuffer = [];\n\n  /** @type {Module} */\n  let module;\n  /** @type {Chunk} */\n  let chunk;\n  /** @type {ChunkGroup} */\n  let chunkGroup;\n  /** @type {DependenciesBlock} */\n  let block;\n  /** @type {ChunkGroupInfo} */\n  let chunkGroupInfo;\n\n  // For each async Block in graph\n  /**\n   * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n   * @returns {void}\n   */\n  const iteratorBlock = b => {\n    // 1. We create a chunk group with single chunk in it for this Block\n    // but only once (blockChunkGroups map)\n    /** @type {ChunkGroupInfo | undefined} */\n    let cgi = blockChunkGroups.get(b);\n    /** @type {ChunkGroup | undefined} */\n    let c;\n    /** @type {Entrypoint | undefined} */\n    let entrypoint;\n    const entryOptions = b.groupOptions && b.groupOptions.entryOptions;\n    if (cgi === undefined) {\n      const chunkName = b.groupOptions && b.groupOptions.name || b.chunkName;\n      if (entryOptions) {\n        cgi = namedAsyncEntrypoints.get( /** @type {string} */chunkName);\n        if (!cgi) {\n          entrypoint = compilation.addAsyncEntrypoint(entryOptions, module, /** @type {DependencyLocation} */b.loc, /** @type {string} */b.request);\n          maskByChunk.set(entrypoint.chunks[0], ZERO_BIGINT);\n          entrypoint.index = nextChunkGroupIndex++;\n          cgi = {\n            chunkGroup: entrypoint,\n            runtime: entrypoint.options.runtime || entrypoint.name,\n            minAvailableModules: ZERO_BIGINT,\n            availableModulesToBeMerged: [],\n            skippedItems: undefined,\n            resultingAvailableModules: undefined,\n            children: undefined,\n            availableSources: undefined,\n            availableChildren: undefined,\n            preOrderIndex: 0,\n            postOrderIndex: 0,\n            chunkLoading: entryOptions.chunkLoading !== undefined ? entryOptions.chunkLoading !== false : chunkGroupInfo.chunkLoading,\n            asyncChunks: entryOptions.asyncChunks !== undefined ? entryOptions.asyncChunks : chunkGroupInfo.asyncChunks\n          };\n          chunkGroupInfoMap.set(entrypoint, cgi);\n          chunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n          if (chunkName) {\n            namedAsyncEntrypoints.set(chunkName, cgi);\n          }\n        } else {\n          entrypoint = /** @type {Entrypoint} */cgi.chunkGroup;\n          // TODO merge entryOptions\n          entrypoint.addOrigin(module, /** @type {DependencyLocation} */b.loc, /** @type {string} */b.request);\n          chunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n        }\n\n        // 2. We enqueue the DependenciesBlock for traversal\n        queueDelayed.push({\n          action: PROCESS_ENTRY_BLOCK,\n          block: b,\n          module,\n          chunk: entrypoint.chunks[0],\n          chunkGroup: entrypoint,\n          chunkGroupInfo: cgi\n        });\n      } else if (!chunkGroupInfo.asyncChunks || !chunkGroupInfo.chunkLoading) {\n        // Just queue the block into the current chunk group\n        queue.push({\n          action: PROCESS_BLOCK,\n          block: b,\n          module,\n          chunk,\n          chunkGroup,\n          chunkGroupInfo\n        });\n      } else {\n        cgi = chunkName ? namedChunkGroups.get(chunkName) : undefined;\n        if (!cgi) {\n          c = compilation.addChunkInGroup(b.groupOptions || b.chunkName, module, /** @type {DependencyLocation} */b.loc, /** @type {string} */b.request);\n          maskByChunk.set(c.chunks[0], ZERO_BIGINT);\n          c.index = nextChunkGroupIndex++;\n          cgi = {\n            chunkGroup: c,\n            runtime: chunkGroupInfo.runtime,\n            minAvailableModules: undefined,\n            availableModulesToBeMerged: [],\n            skippedItems: undefined,\n            resultingAvailableModules: undefined,\n            children: undefined,\n            availableSources: undefined,\n            availableChildren: undefined,\n            preOrderIndex: 0,\n            postOrderIndex: 0,\n            chunkLoading: chunkGroupInfo.chunkLoading,\n            asyncChunks: chunkGroupInfo.asyncChunks\n          };\n          allCreatedChunkGroups.add(c);\n          chunkGroupInfoMap.set(c, cgi);\n          if (chunkName) {\n            namedChunkGroups.set(chunkName, cgi);\n          }\n        } else {\n          c = cgi.chunkGroup;\n          if (c.isInitial()) {\n            compilation.errors.push(new AsyncDependencyToInitialChunkError( /** @type {string} */chunkName, module, /** @type {DependencyLocation} */b.loc));\n            c = chunkGroup;\n          } else {\n            c.addOptions(b.groupOptions);\n          }\n          c.addOrigin(module, /** @type {DependencyLocation} */b.loc, /** @type {string} */b.request);\n        }\n        blockConnections.set(b, []);\n      }\n      blockChunkGroups.set(b, /** @type {ChunkGroupInfo} */cgi);\n      blockByChunkGroups.set( /** @type {ChunkGroupInfo} */cgi, b);\n    } else if (entryOptions) {\n      entrypoint = /** @type {Entrypoint} */cgi.chunkGroup;\n    } else {\n      c = cgi.chunkGroup;\n    }\n    if (c !== undefined) {\n      // 2. We store the connection for the block\n      // to connect it later if needed\n      /** @type {BlockChunkGroupConnection[]} */\n      blockConnections.get(b).push({\n        originChunkGroupInfo: chunkGroupInfo,\n        chunkGroup: c\n      });\n\n      // 3. We enqueue the chunk group info creation/updating\n      let connectList = queueConnect.get(chunkGroupInfo);\n      if (connectList === undefined) {\n        connectList = new Set();\n        queueConnect.set(chunkGroupInfo, connectList);\n      }\n      connectList.add( /** @type {ChunkGroupInfo} */cgi);\n\n      // TODO check if this really need to be done for each traversal\n      // or if it is enough when it's queued when created\n      // 4. We enqueue the DependenciesBlock for traversal\n      queueDelayed.push({\n        action: PROCESS_BLOCK,\n        block: b,\n        module,\n        chunk: c.chunks[0],\n        chunkGroup: c,\n        chunkGroupInfo: ( /** @type {ChunkGroupInfo} */cgi)\n      });\n    } else if (entrypoint !== undefined) {\n      chunkGroupInfo.chunkGroup.addAsyncEntrypoint(entrypoint);\n    }\n  };\n\n  /**\n   * @param {DependenciesBlock} block the block\n   * @returns {void}\n   */\n  const processBlock = block => {\n    statProcessedBlocks++;\n    // get prepared block info\n    const blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n    if (blockModules !== undefined) {\n      const minAvailableModules = /** @type {bigint} */\n      chunkGroupInfo.minAvailableModules;\n      // Buffer items because order need to be reversed to get indices correct\n      // Traverse all referenced modules\n      for (let i = 0, len = blockModules.length; i < len; i += 3) {\n        const refModule = /** @type {Module} */blockModules[i];\n        // For single comparisons this might be cheaper\n        const isModuleInChunk = chunkGraph.isModuleInChunk(refModule, chunk);\n        if (isModuleInChunk) {\n          // skip early if already connected\n          continue;\n        }\n        const refOrdinal = /** @type {number} */getModuleOrdinal(refModule);\n        const activeState = /** @type {ConnectionState} */\n        blockModules[i + 1];\n        if (activeState !== true) {\n          const connections = /** @type {ModuleGraphConnection[]} */\n          blockModules[i + 2];\n          skipConnectionBuffer.push([refModule, connections]);\n          // We skip inactive connections\n          if (activeState === false) continue;\n        } else if (isOrdinalSetInMask(minAvailableModules, refOrdinal)) {\n          // already in parent chunks, skip it for now\n          skipBuffer.push(refModule);\n          continue;\n        }\n        // enqueue, then add and enter to be in the correct order\n        // this is relevant with circular dependencies\n        queueBuffer.push({\n          action: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n          block: refModule,\n          module: refModule,\n          chunk,\n          chunkGroup,\n          chunkGroupInfo\n        });\n      }\n      // Add buffered items in reverse order\n      if (skipConnectionBuffer.length > 0) {\n        let {\n          skippedModuleConnections\n        } = chunkGroupInfo;\n        if (skippedModuleConnections === undefined) {\n          chunkGroupInfo.skippedModuleConnections = skippedModuleConnections = new Set();\n        }\n        for (let i = skipConnectionBuffer.length - 1; i >= 0; i--) {\n          skippedModuleConnections.add(skipConnectionBuffer[i]);\n        }\n        skipConnectionBuffer.length = 0;\n      }\n      if (skipBuffer.length > 0) {\n        let {\n          skippedItems\n        } = chunkGroupInfo;\n        if (skippedItems === undefined) {\n          chunkGroupInfo.skippedItems = skippedItems = new Set();\n        }\n        for (let i = skipBuffer.length - 1; i >= 0; i--) {\n          skippedItems.add(skipBuffer[i]);\n        }\n        skipBuffer.length = 0;\n      }\n      if (queueBuffer.length > 0) {\n        for (let i = queueBuffer.length - 1; i >= 0; i--) {\n          queue.push(queueBuffer[i]);\n        }\n        queueBuffer.length = 0;\n      }\n    }\n\n    // Traverse all Blocks\n    for (const b of block.blocks) {\n      iteratorBlock(b);\n    }\n    if (block.blocks.length > 0 && module !== block) {\n      blocksWithNestedBlocks.add(block);\n    }\n  };\n\n  /**\n   * @param {DependenciesBlock} block the block\n   * @returns {void}\n   */\n  const processEntryBlock = block => {\n    statProcessedBlocks++;\n    // get prepared block info\n    const blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n    if (blockModules !== undefined) {\n      // Traverse all referenced modules in reverse order\n      for (let i = blockModules.length - 3; i >= 0; i -= 3) {\n        const refModule = /** @type {Module} */blockModules[i];\n        const activeState = /** @type {ConnectionState} */\n        blockModules[i + 1];\n        // enqueue, then add and enter to be in the correct order\n        // this is relevant with circular dependencies\n        queue.push({\n          action: activeState === true ? ADD_AND_ENTER_ENTRY_MODULE : PROCESS_BLOCK,\n          block: refModule,\n          module: refModule,\n          chunk,\n          chunkGroup,\n          chunkGroupInfo\n        });\n      }\n    }\n\n    // Traverse all Blocks\n    for (const b of block.blocks) {\n      iteratorBlock(b);\n    }\n    if (block.blocks.length > 0 && module !== block) {\n      blocksWithNestedBlocks.add(block);\n    }\n  };\n  const processQueue = () => {\n    while (queue.length) {\n      statProcessedQueueItems++;\n      const queueItem = /** @type {QueueItem} */queue.pop();\n      module = queueItem.module;\n      block = queueItem.block;\n      chunk = queueItem.chunk;\n      chunkGroup = queueItem.chunkGroup;\n      chunkGroupInfo = queueItem.chunkGroupInfo;\n      switch (queueItem.action) {\n        case ADD_AND_ENTER_ENTRY_MODULE:\n          chunkGraph.connectChunkAndEntryModule(chunk, module, /** @type {Entrypoint} */chunkGroup);\n        // fallthrough\n        case ADD_AND_ENTER_MODULE:\n          {\n            const isModuleInChunk = chunkGraph.isModuleInChunk(module, chunk);\n            if (isModuleInChunk) {\n              // already connected, skip it\n              break;\n            }\n            // We connect Module and Chunk\n            chunkGraph.connectChunkAndModule(chunk, module);\n            const moduleOrdinal = getModuleOrdinal(module);\n            let chunkMask = /** @type {bigint} */maskByChunk.get(chunk);\n            chunkMask |= ONE_BIGINT << BigInt(moduleOrdinal);\n            maskByChunk.set(chunk, chunkMask);\n          }\n        // fallthrough\n        case ENTER_MODULE:\n          {\n            const index = chunkGroup.getModulePreOrderIndex(module);\n            if (index === undefined) {\n              chunkGroup.setModulePreOrderIndex(module, chunkGroupInfo.preOrderIndex++);\n            }\n            if (moduleGraph.setPreOrderIndexIfUnset(module, nextFreeModulePreOrderIndex)) {\n              nextFreeModulePreOrderIndex++;\n            }\n\n            // reuse queueItem\n            queueItem.action = LEAVE_MODULE;\n            queue.push(queueItem);\n          }\n        // fallthrough\n        case PROCESS_BLOCK:\n          {\n            processBlock(block);\n            break;\n          }\n        case PROCESS_ENTRY_BLOCK:\n          {\n            processEntryBlock(block);\n            break;\n          }\n        case LEAVE_MODULE:\n          {\n            const index = chunkGroup.getModulePostOrderIndex(module);\n            if (index === undefined) {\n              chunkGroup.setModulePostOrderIndex(module, chunkGroupInfo.postOrderIndex++);\n            }\n            if (moduleGraph.setPostOrderIndexIfUnset(module, nextFreeModulePostOrderIndex)) {\n              nextFreeModulePostOrderIndex++;\n            }\n            break;\n          }\n      }\n    }\n  };\n\n  /**\n   * @param {ChunkGroupInfo} chunkGroupInfo The info object for the chunk group\n   * @returns {bigint} The mask of available modules after the chunk group\n   */\n  const calculateResultingAvailableModules = chunkGroupInfo => {\n    if (chunkGroupInfo.resultingAvailableModules !== undefined) return chunkGroupInfo.resultingAvailableModules;\n    let resultingAvailableModules = /** @type {bigint} */\n    chunkGroupInfo.minAvailableModules;\n\n    // add the modules from the chunk group to the set\n    for (const chunk of chunkGroupInfo.chunkGroup.chunks) {\n      const mask = /** @type {bigint} */maskByChunk.get(chunk);\n      resultingAvailableModules |= mask;\n    }\n    return chunkGroupInfo.resultingAvailableModules = resultingAvailableModules;\n  };\n  const processConnectQueue = () => {\n    // Figure out new parents for chunk groups\n    // to get new available modules for these children\n    for (const [chunkGroupInfo, targets] of queueConnect) {\n      // 1. Add new targets to the list of children\n      if (chunkGroupInfo.children === undefined) {\n        chunkGroupInfo.children = targets;\n      } else {\n        for (const target of targets) {\n          chunkGroupInfo.children.add(target);\n        }\n      }\n\n      // 2. Calculate resulting available modules\n      const resultingAvailableModules = calculateResultingAvailableModules(chunkGroupInfo);\n      const runtime = chunkGroupInfo.runtime;\n\n      // 3. Update chunk group info\n      for (const target of targets) {\n        target.availableModulesToBeMerged.push(resultingAvailableModules);\n        chunkGroupsForMerging.add(target);\n        const oldRuntime = target.runtime;\n        const newRuntime = mergeRuntime(oldRuntime, runtime);\n        if (oldRuntime !== newRuntime) {\n          target.runtime = newRuntime;\n          outdatedChunkGroupInfo.add(target);\n        }\n      }\n      statConnectedChunkGroups += targets.size;\n    }\n    queueConnect.clear();\n  };\n  const processChunkGroupsForMerging = () => {\n    statProcessedChunkGroupsForMerging += chunkGroupsForMerging.size;\n\n    // Execute the merge\n    for (const info of chunkGroupsForMerging) {\n      const availableModulesToBeMerged = info.availableModulesToBeMerged;\n      const cachedMinAvailableModules = info.minAvailableModules;\n      let minAvailableModules = cachedMinAvailableModules;\n      statMergedAvailableModuleSets += availableModulesToBeMerged.length;\n      for (const availableModules of availableModulesToBeMerged) {\n        if (minAvailableModules === undefined) {\n          minAvailableModules = availableModules;\n        } else {\n          minAvailableModules &= availableModules;\n        }\n      }\n      const changed = minAvailableModules !== cachedMinAvailableModules;\n      availableModulesToBeMerged.length = 0;\n      if (changed) {\n        info.minAvailableModules = minAvailableModules;\n        info.resultingAvailableModules = undefined;\n        outdatedChunkGroupInfo.add(info);\n      }\n    }\n    chunkGroupsForMerging.clear();\n  };\n  const processChunkGroupsForCombining = () => {\n    for (const info of chunkGroupsForCombining) {\n      for (const source of ( /** @type {Set<ChunkGroupInfo>} */\n      info.availableSources)) {\n        if (source.minAvailableModules === undefined) {\n          chunkGroupsForCombining.delete(info);\n          break;\n        }\n      }\n    }\n    for (const info of chunkGroupsForCombining) {\n      let availableModules = ZERO_BIGINT;\n      // combine minAvailableModules from all resultingAvailableModules\n      for (const source of ( /** @type {Set<ChunkGroupInfo>} */\n      info.availableSources)) {\n        const resultingAvailableModules = calculateResultingAvailableModules(source);\n        availableModules |= resultingAvailableModules;\n      }\n      info.minAvailableModules = availableModules;\n      info.resultingAvailableModules = undefined;\n      outdatedChunkGroupInfo.add(info);\n    }\n    chunkGroupsForCombining.clear();\n  };\n  const processOutdatedChunkGroupInfo = () => {\n    statChunkGroupInfoUpdated += outdatedChunkGroupInfo.size;\n    // Revisit skipped elements\n    for (const info of outdatedChunkGroupInfo) {\n      // 1. Reconsider skipped items\n      if (info.skippedItems !== undefined) {\n        const minAvailableModules = /** @type {bigint} */\n        info.minAvailableModules;\n        for (const module of info.skippedItems) {\n          const ordinal = getModuleOrdinal(module);\n          if (!isOrdinalSetInMask(minAvailableModules, ordinal)) {\n            queue.push({\n              action: ADD_AND_ENTER_MODULE,\n              block: module,\n              module,\n              chunk: info.chunkGroup.chunks[0],\n              chunkGroup: info.chunkGroup,\n              chunkGroupInfo: info\n            });\n            info.skippedItems.delete(module);\n          }\n        }\n      }\n\n      // 2. Reconsider skipped connections\n      if (info.skippedModuleConnections !== undefined) {\n        const minAvailableModules = /** @type {bigint} */\n        info.minAvailableModules;\n        for (const entry of info.skippedModuleConnections) {\n          const [module, connections] = entry;\n          const activeState = getActiveStateOfConnections(connections, info.runtime);\n          if (activeState === false) continue;\n          if (activeState === true) {\n            const ordinal = getModuleOrdinal(module);\n            info.skippedModuleConnections.delete(entry);\n            if (isOrdinalSetInMask(minAvailableModules, ordinal)) {\n              /** @type {NonNullable<ChunkGroupInfo[\"skippedItems\"]>} */\n              info.skippedItems.add(module);\n              continue;\n            }\n          }\n          queue.push({\n            action: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n            block: module,\n            module,\n            chunk: info.chunkGroup.chunks[0],\n            chunkGroup: info.chunkGroup,\n            chunkGroupInfo: info\n          });\n        }\n      }\n\n      // 2. Reconsider children chunk groups\n      if (info.children !== undefined) {\n        statChildChunkGroupsReconnected += info.children.size;\n        for (const cgi of info.children) {\n          let connectList = queueConnect.get(info);\n          if (connectList === undefined) {\n            connectList = new Set();\n            queueConnect.set(info, connectList);\n          }\n          connectList.add(cgi);\n        }\n      }\n\n      // 3. Reconsider chunk groups for combining\n      if (info.availableChildren !== undefined) {\n        for (const cgi of info.availableChildren) {\n          chunkGroupsForCombining.add(cgi);\n        }\n      }\n      outdatedOrderIndexChunkGroups.add(info);\n    }\n    outdatedChunkGroupInfo.clear();\n  };\n\n  // Iterative traversal of the Module graph\n  // Recursive would be simpler to write but could result in Stack Overflows\n  while (queue.length || queueConnect.size) {\n    logger.time(\"visitModules: visiting\");\n    processQueue();\n    logger.timeAggregateEnd(\"visitModules: prepare\");\n    logger.timeEnd(\"visitModules: visiting\");\n    if (chunkGroupsForCombining.size > 0) {\n      logger.time(\"visitModules: combine available modules\");\n      processChunkGroupsForCombining();\n      logger.timeEnd(\"visitModules: combine available modules\");\n    }\n    if (queueConnect.size > 0) {\n      logger.time(\"visitModules: calculating available modules\");\n      processConnectQueue();\n      logger.timeEnd(\"visitModules: calculating available modules\");\n      if (chunkGroupsForMerging.size > 0) {\n        logger.time(\"visitModules: merging available modules\");\n        processChunkGroupsForMerging();\n        logger.timeEnd(\"visitModules: merging available modules\");\n      }\n    }\n    if (outdatedChunkGroupInfo.size > 0) {\n      logger.time(\"visitModules: check modules for revisit\");\n      processOutdatedChunkGroupInfo();\n      logger.timeEnd(\"visitModules: check modules for revisit\");\n    }\n\n    // Run queueDelayed when all items of the queue are processed\n    // This is important to get the global indexing correct\n    // Async blocks should be processed after all sync blocks are processed\n    if (queue.length === 0) {\n      const tempQueue = queue;\n      queue = queueDelayed.reverse();\n      queueDelayed = tempQueue;\n    }\n  }\n  for (const info of outdatedOrderIndexChunkGroups) {\n    const {\n      chunkGroup,\n      runtime\n    } = info;\n    const block = blockByChunkGroups.get(info);\n    if (!block) {\n      continue;\n    }\n    let preOrderIndex = 0;\n    let postOrderIndex = 0;\n\n    /**\n     * @param {DependenciesBlock} current current\n     * @param {BlocksWithNestedBlocks} visited visited dependencies blocks\n     */\n    const process = (current, visited) => {\n      const blockModules = getBlockModules(current, runtime);\n      if (blockModules === undefined) {\n        return;\n      }\n      for (let i = 0, len = blockModules.length; i < len; i += 3) {\n        const activeState = /** @type {ConnectionState} */\n        blockModules[i + 1];\n        if (activeState === false) {\n          continue;\n        }\n        const refModule = /** @type {Module} */blockModules[i];\n        if (visited.has(refModule)) {\n          continue;\n        }\n        visited.add(refModule);\n        if (refModule) {\n          chunkGroup.setModulePreOrderIndex(refModule, preOrderIndex++);\n          process(refModule, visited);\n          chunkGroup.setModulePostOrderIndex(refModule, postOrderIndex++);\n        }\n      }\n    };\n    process(block, new Set());\n  }\n  outdatedOrderIndexChunkGroups.clear();\n  ordinalByModule.clear();\n  logger.log(`${statProcessedQueueItems} queue items processed (${statProcessedBlocks} blocks)`);\n  logger.log(`${statConnectedChunkGroups} chunk groups connected`);\n  logger.log(`${statProcessedChunkGroupsForMerging} chunk groups processed for merging (${statMergedAvailableModuleSets} module sets, ${statForkedAvailableModules} forked, ${statForkedAvailableModulesCount} + ${statForkedAvailableModulesCountPlus} modules forked, ${statForkedMergedModulesCount} + ${statForkedMergedModulesCountPlus} modules merged into fork, ${statForkedResultModulesCount} resulting modules)`);\n  logger.log(`${statChunkGroupInfoUpdated} chunk group info updated (${statChildChunkGroupsReconnected} already connected chunk groups reconnected)`);\n};\n\n/**\n *\n * @param {Compilation} compilation the compilation\n * @param {BlocksWithNestedBlocks} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {BlockConnections} blockConnections connection for blocks\n * @param {MaskByChunk} maskByChunk mapping from chunk to module mask\n */\nconst connectChunkGroups = (compilation, blocksWithNestedBlocks, blockConnections, maskByChunk) => {\n  const {\n    chunkGraph\n  } = compilation;\n\n  /**\n   * Helper function to check if all modules of a chunk are available\n   *\n   * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n   * @param {bigint} availableModules the comparator set\n   * @returns {boolean} return true if all modules of a chunk are available\n   */\n  const areModulesAvailable = (chunkGroup, availableModules) => {\n    for (const chunk of chunkGroup.chunks) {\n      const chunkMask = /** @type {bigint} */maskByChunk.get(chunk);\n      if ((chunkMask & availableModules) !== chunkMask) return false;\n    }\n    return true;\n  };\n\n  // For each edge in the basic chunk graph\n  for (const [block, connections] of blockConnections) {\n    // 1. Check if connection is needed\n    // When none of the dependencies need to be connected\n    // we can skip all of them\n    // It's not possible to filter each item so it doesn't create inconsistent\n    // connections and modules can only create one version\n    // TODO maybe decide this per runtime\n    if (\n    // TODO is this needed?\n    !blocksWithNestedBlocks.has(block) && connections.every(({\n      chunkGroup,\n      originChunkGroupInfo\n    }) => areModulesAvailable(chunkGroup, /** @type {bigint} */originChunkGroupInfo.resultingAvailableModules))) {\n      continue;\n    }\n\n    // 2. Foreach edge\n    for (let i = 0; i < connections.length; i++) {\n      const {\n        chunkGroup,\n        originChunkGroupInfo\n      } = connections[i];\n\n      // 3. Connect block with chunk\n      chunkGraph.connectBlockAndChunkGroup(block, chunkGroup);\n\n      // 4. Connect chunk with parent\n      connectChunkGroupParentAndChild(originChunkGroupInfo.chunkGroup, chunkGroup);\n    }\n  }\n};\n\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\nconst cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {\n  const {\n    chunkGraph\n  } = compilation;\n  for (const chunkGroup of allCreatedChunkGroups) {\n    if (chunkGroup.getNumberOfParents() === 0) {\n      for (const chunk of chunkGroup.chunks) {\n        compilation.chunks.delete(chunk);\n        chunkGraph.disconnectChunk(chunk);\n      }\n      chunkGraph.disconnectChunkGroup(chunkGroup);\n      chunkGroup.remove();\n    }\n  }\n};\n\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {InputEntrypointsAndModules} inputEntrypointsAndModules chunk groups which are processed with the modules\n * @returns {void}\n */\nconst buildChunkGraph = (compilation, inputEntrypointsAndModules) => {\n  const logger = compilation.getLogger(\"webpack.buildChunkGraph\");\n\n  // SHARED STATE\n\n  /** @type {BlockConnections} */\n  const blockConnections = new Map();\n\n  /** @type {AllCreatedChunkGroups} */\n  const allCreatedChunkGroups = new Set();\n\n  /** @type {ChunkGroupInfoMap} */\n  const chunkGroupInfoMap = new Map();\n\n  /** @type {BlocksWithNestedBlocks} */\n  const blocksWithNestedBlocks = new Set();\n\n  /** @type {MaskByChunk} */\n  const maskByChunk = new Map();\n\n  // PART ONE\n\n  logger.time(\"visitModules\");\n  visitModules(logger, compilation, inputEntrypointsAndModules, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups, maskByChunk);\n  logger.timeEnd(\"visitModules\");\n\n  // PART TWO\n\n  logger.time(\"connectChunkGroups\");\n  connectChunkGroups(compilation, blocksWithNestedBlocks, blockConnections, maskByChunk);\n  logger.timeEnd(\"connectChunkGroups\");\n  for (const [chunkGroup, chunkGroupInfo] of chunkGroupInfoMap) {\n    for (const chunk of chunkGroup.chunks) chunk.runtime = mergeRuntime(chunk.runtime, chunkGroupInfo.runtime);\n  }\n\n  // Cleanup work\n\n  logger.time(\"cleanup\");\n  cleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n  logger.timeEnd(\"cleanup\");\n};\nmodule.exports = buildChunkGraph;","map":{"version":3,"names":["AsyncDependencyToInitialChunkError","require","connectChunkGroupParentAndChild","ModuleGraphConnection","getEntryRuntime","mergeRuntime","ZERO_BIGINT","BigInt","ONE_BIGINT","isOrdinalSetInMask","mask","ordinal","asUintN","getActiveStateOfConnections","connections","runtime","merged","getActiveState","i","length","c","addConnectionStates","extractBlockModules","module","moduleGraph","blockModulesMap","blockCache","modules","arrays","queue","block","pop","arr","push","set","b","blocks","connection","getOutgoingConnections","d","dependency","m","weak","getParentBlock","index","getParentBlockIndex","dependencies","indexOf","get","indexMap","outer","j","undefined","state","Map","idx","visitModules","logger","compilation","inputEntrypointsAndModules","chunkGroupInfoMap","blockConnections","blocksWithNestedBlocks","allCreatedChunkGroups","maskByChunk","chunkGraph","moduleMemCaches","blockModulesRuntimeMap","ordinalByModule","getModuleOrdinal","size","chunk","chunks","getChunkModulesIterable","getBlockModules","blockModules","getRootBlock","memCache","map","provide","time","timeAggregate","statProcessedQueueItems","statProcessedBlocks","statConnectedChunkGroups","statProcessedChunkGroupsForMerging","statMergedAvailableModuleSets","statForkedAvailableModules","statForkedAvailableModulesCount","statForkedAvailableModulesCountPlus","statForkedMergedModulesCount","statForkedMergedModulesCountPlus","statForkedResultModulesCount","statChunkGroupInfoUpdated","statChildChunkGroupsReconnected","nextChunkGroupIndex","nextFreeModulePreOrderIndex","nextFreeModulePostOrderIndex","blockChunkGroups","blockByChunkGroups","namedChunkGroups","namedAsyncEntrypoints","outdatedOrderIndexChunkGroups","Set","ADD_AND_ENTER_ENTRY_MODULE","ADD_AND_ENTER_MODULE","ENTER_MODULE","PROCESS_BLOCK","PROCESS_ENTRY_BLOCK","LEAVE_MODULE","queueConnect","chunkGroupsForCombining","chunkGroup","name","options","chunkGroupInfo","minAvailableModules","availableModulesToBeMerged","skippedItems","resultingAvailableModules","children","availableSources","availableChildren","preOrderIndex","postOrderIndex","chunkLoading","outputOptions","asyncChunks","getNumberOfParents","add","getEntrypointChunk","action","parent","parentsIterable","parentChunkGroupInfo","reverse","outdatedChunkGroupInfo","chunkGroupsForMerging","queueDelayed","skipConnectionBuffer","skipBuffer","queueBuffer","iteratorBlock","cgi","entrypoint","entryOptions","groupOptions","chunkName","addAsyncEntrypoint","loc","request","connectBlockAndChunkGroup","addOrigin","addChunkInGroup","isInitial","errors","addOptions","originChunkGroupInfo","connectList","processBlock","len","refModule","isModuleInChunk","refOrdinal","activeState","skippedModuleConnections","processEntryBlock","processQueue","queueItem","connectChunkAndEntryModule","connectChunkAndModule","moduleOrdinal","chunkMask","getModulePreOrderIndex","setModulePreOrderIndex","setPreOrderIndexIfUnset","getModulePostOrderIndex","setModulePostOrderIndex","setPostOrderIndexIfUnset","calculateResultingAvailableModules","processConnectQueue","targets","target","oldRuntime","newRuntime","clear","processChunkGroupsForMerging","info","cachedMinAvailableModules","availableModules","changed","processChunkGroupsForCombining","source","delete","processOutdatedChunkGroupInfo","entry","timeAggregateEnd","timeEnd","tempQueue","process","current","visited","has","log","connectChunkGroups","areModulesAvailable","every","cleanupUnconnectedGroups","disconnectChunk","disconnectChunkGroup","remove","buildChunkGraph","getLogger","exports"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/buildChunkGraph.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\nconst { connectChunkGroupParentAndChild } = require(\"./GraphHelpers\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst { getEntryRuntime, mergeRuntime } = require(\"./util/runtime\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./ModuleGraphConnection\").ConnectionState} ConnectionState */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {Object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n * @property {ChunkGroupInfo} chunkGroupInfo\n */\n\n/**\n * @typedef {Object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {RuntimeSpec} runtime the runtimes\n * @property {bigint | undefined} minAvailableModules current minimal set of modules available at this point\n * @property {bigint[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {Set<Module>=} skippedItems modules that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<[Module, ModuleGraphConnection[]]>=} skippedModuleConnections referenced modules that where skipped because they were not active in this runtime\n * @property {bigint | undefined} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroupInfo> | undefined} children set of children chunk groups, that will be revisited when availableModules shrink\n * @property {Set<ChunkGroupInfo> | undefined} availableSources set of chunk groups that are the source for minAvailableModules\n * @property {Set<ChunkGroupInfo> | undefined} availableChildren set of chunk groups which depend on the this chunk group as availableSource\n * @property {number} preOrderIndex next pre order index\n * @property {number} postOrderIndex next post order index\n * @property {boolean} chunkLoading has a chunk loading mechanism\n * @property {boolean} asyncChunks create async chunks\n */\n\n/**\n * @typedef {Object} BlockChunkGroupConnection\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\n/** @typedef {(Module | ConnectionState | ModuleGraphConnection)[]} BlockModulesInTuples */\n/** @typedef {(Module | ConnectionState | ModuleGraphConnection[])[]} BlockModulesInFlattenTuples */\n/** @typedef {Map<DependenciesBlock, BlockModulesInFlattenTuples>} BlockModulesMap */\n/** @typedef {Map<Chunk, bigint>} MaskByChunk */\n/** @typedef {Set<DependenciesBlock>} BlocksWithNestedBlocks */\n/** @typedef {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} BlockConnections */\n/** @typedef {Map<ChunkGroup, ChunkGroupInfo>} ChunkGroupInfoMap */\n/** @typedef {Set<ChunkGroup>} AllCreatedChunkGroups */\n/** @typedef {Map<Entrypoint, Module[]>} InputEntrypointsAndModules */\n\nconst ZERO_BIGINT = BigInt(0);\nconst ONE_BIGINT = BigInt(1);\n\n/**\n * @param {bigint} mask The mask to test\n * @param {number} ordinal The ordinal of the bit to test\n * @returns {boolean} If the ordinal-th bit is set in the mask\n */\nconst isOrdinalSetInMask = (mask, ordinal) =>\n\tBigInt.asUintN(1, mask >> BigInt(ordinal)) !== ZERO_BIGINT;\n\n/**\n * @param {ModuleGraphConnection[]} connections list of connections\n * @param {RuntimeSpec} runtime for which runtime\n * @returns {ConnectionState} connection state\n */\nconst getActiveStateOfConnections = (connections, runtime) => {\n\tlet merged = connections[0].getActiveState(runtime);\n\tif (merged === true) return true;\n\tfor (let i = 1; i < connections.length; i++) {\n\t\tconst c = connections[i];\n\t\tmerged = ModuleGraphConnection.addConnectionStates(\n\t\t\tmerged,\n\t\t\tc.getActiveState(runtime)\n\t\t);\n\t\tif (merged === true) return true;\n\t}\n\treturn merged;\n};\n\n/**\n * @param {Module} module module\n * @param {ModuleGraph} moduleGraph module graph\n * @param {RuntimeSpec} runtime runtime\n * @param {BlockModulesMap} blockModulesMap block modules map\n */\nconst extractBlockModules = (module, moduleGraph, runtime, blockModulesMap) => {\n\t/** @type {DependenciesBlock | undefined} */\n\tlet blockCache;\n\t/** @type {BlockModulesInTuples | undefined} */\n\tlet modules;\n\n\t/** @type {BlockModulesInTuples[]} */\n\tconst arrays = [];\n\n\t/** @type {DependenciesBlock[]} */\n\tconst queue = [module];\n\twhile (queue.length > 0) {\n\t\tconst block = /** @type {DependenciesBlock} */ (queue.pop());\n\t\t/** @type {Module[]} */\n\t\tconst arr = [];\n\t\tarrays.push(arr);\n\t\tblockModulesMap.set(block, arr);\n\t\tfor (const b of block.blocks) {\n\t\t\tqueue.push(b);\n\t\t}\n\t}\n\n\tfor (const connection of moduleGraph.getOutgoingConnections(module)) {\n\t\tconst d = connection.dependency;\n\t\t// We skip connections without dependency\n\t\tif (!d) continue;\n\t\tconst m = connection.module;\n\t\t// We skip connections without Module pointer\n\t\tif (!m) continue;\n\t\t// We skip weak connections\n\t\tif (connection.weak) continue;\n\n\t\tconst block = moduleGraph.getParentBlock(d);\n\t\tlet index = moduleGraph.getParentBlockIndex(d);\n\n\t\t// deprecated fallback\n\t\tif (index < 0) {\n\t\t\tindex = /** @type {DependenciesBlock} */ (block).dependencies.indexOf(d);\n\t\t}\n\n\t\tif (blockCache !== block) {\n\t\t\tmodules =\n\t\t\t\t/** @type {BlockModulesInTuples} */\n\t\t\t\t(\n\t\t\t\t\tblockModulesMap.get(\n\t\t\t\t\t\t(blockCache = /** @type {DependenciesBlock} */ (block))\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t}\n\n\t\tconst i = index * 3;\n\t\t/** @type {BlockModulesInTuples} */\n\t\t(modules)[i] = m;\n\t\t/** @type {BlockModulesInTuples} */\n\t\t(modules)[i + 1] = connection.getActiveState(runtime);\n\t\t/** @type {BlockModulesInTuples} */\n\t\t(modules)[i + 2] = connection;\n\t}\n\n\tfor (const modules of arrays) {\n\t\tif (modules.length === 0) continue;\n\t\tlet indexMap;\n\t\tlet length = 0;\n\t\touter: for (let j = 0; j < modules.length; j += 3) {\n\t\t\tconst m = modules[j];\n\t\t\tif (m === undefined) continue;\n\t\t\tconst state = /** @type {ConnectionState} */ (modules[j + 1]);\n\t\t\tconst connection = /** @type {ModuleGraphConnection} */ (modules[j + 2]);\n\t\t\tif (indexMap === undefined) {\n\t\t\t\tlet i = 0;\n\t\t\t\tfor (; i < length; i += 3) {\n\t\t\t\t\tif (modules[i] === m) {\n\t\t\t\t\t\tconst merged = /** @type {ConnectionState} */ (modules[i + 1]);\n\t\t\t\t\t\t/** @type {ModuleGraphConnection[]} */\n\t\t\t\t\t\t(/** @type {unknown} */ (modules[i + 2])).push(connection);\n\t\t\t\t\t\tif (merged === true) continue outer;\n\t\t\t\t\t\tmodules[i + 1] = ModuleGraphConnection.addConnectionStates(\n\t\t\t\t\t\t\tmerged,\n\t\t\t\t\t\t\tstate\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmodules[length] = m;\n\t\t\t\tlength++;\n\t\t\t\tmodules[length] = state;\n\t\t\t\tlength++;\n\t\t\t\t/** @type {ModuleGraphConnection[]} */\n\t\t\t\t(/** @type {unknown} */ (modules[length])) = [connection];\n\t\t\t\tlength++;\n\t\t\t\tif (length > 30) {\n\t\t\t\t\t// To avoid worse case performance, we will use an index map for\n\t\t\t\t\t// linear cost access, which allows to maintain O(n) complexity\n\t\t\t\t\t// while keeping allocations down to a minimum\n\t\t\t\t\tindexMap = new Map();\n\t\t\t\t\tfor (let i = 0; i < length; i += 3) {\n\t\t\t\t\t\tindexMap.set(modules[i], i + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst idx = indexMap.get(m);\n\t\t\t\tif (idx !== undefined) {\n\t\t\t\t\tconst merged = /** @type {ConnectionState} */ (modules[idx]);\n\t\t\t\t\t/** @type {ModuleGraphConnection[]} */\n\t\t\t\t\t(/** @type {unknown} */ (modules[idx + 1])).push(connection);\n\t\t\t\t\tif (merged === true) continue outer;\n\t\t\t\t\tmodules[idx] = ModuleGraphConnection.addConnectionStates(\n\t\t\t\t\t\tmerged,\n\t\t\t\t\t\tstate\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tmodules[length] = m;\n\t\t\t\t\tlength++;\n\t\t\t\t\tmodules[length] = state;\n\t\t\t\t\tindexMap.set(m, length);\n\t\t\t\t\tlength++;\n\t\t\t\t\t/** @type {ModuleGraphConnection[]} */\n\t\t\t\t\t(\n\t\t\t\t\t\t/** @type {unknown} */\n\t\t\t\t\t\t(modules[length])\n\t\t\t\t\t) = [connection];\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmodules.length = length;\n\t}\n};\n\n/**\n *\n * @param {Logger} logger a logger\n * @param {Compilation} compilation the compilation\n * @param {InputEntrypointsAndModules} inputEntrypointsAndModules chunk groups which are processed with the modules\n * @param {ChunkGroupInfoMap} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {BlockConnections} blockConnections connection for blocks\n * @param {BlocksWithNestedBlocks} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {AllCreatedChunkGroups} allCreatedChunkGroups filled with all chunk groups that are created here\n * @param {MaskByChunk} maskByChunk module content mask by chunk\n */\nconst visitModules = (\n\tlogger,\n\tcompilation,\n\tinputEntrypointsAndModules,\n\tchunkGroupInfoMap,\n\tblockConnections,\n\tblocksWithNestedBlocks,\n\tallCreatedChunkGroups,\n\tmaskByChunk\n) => {\n\tconst { moduleGraph, chunkGraph, moduleMemCaches } = compilation;\n\n\tconst blockModulesRuntimeMap = new Map();\n\n\t/** @type {BlockModulesMap | undefined} */\n\tlet blockModulesMap;\n\n\t/** @type {Map<Module, number>} */\n\tconst ordinalByModule = new Map();\n\n\t/**\n\t * @param {Module} module The module to look up\n\t * @returns {number} The ordinal of the module in masks\n\t */\n\tconst getModuleOrdinal = module => {\n\t\tlet ordinal = ordinalByModule.get(module);\n\t\tif (ordinal === undefined) {\n\t\t\tordinal = ordinalByModule.size;\n\t\t\tordinalByModule.set(module, ordinal);\n\t\t}\n\t\treturn ordinal;\n\t};\n\n\tfor (const chunk of compilation.chunks) {\n\t\tlet mask = ZERO_BIGINT;\n\t\tfor (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\tmask |= ONE_BIGINT << BigInt(getModuleOrdinal(m));\n\t\t}\n\t\tmaskByChunk.set(chunk, mask);\n\t}\n\n\t/**\n\t *\n\t * @param {DependenciesBlock} block block\n\t * @param {RuntimeSpec} runtime runtime\n\t * @returns {BlockModulesInFlattenTuples} block modules in flatten tuples\n\t */\n\tconst getBlockModules = (block, runtime) => {\n\t\tblockModulesMap = blockModulesRuntimeMap.get(runtime);\n\t\tif (blockModulesMap === undefined) {\n\t\t\tblockModulesMap = new Map();\n\t\t\tblockModulesRuntimeMap.set(runtime, blockModulesMap);\n\t\t}\n\t\tlet blockModules = blockModulesMap.get(block);\n\t\tif (blockModules !== undefined) return blockModules;\n\t\tconst module = /** @type {Module} */ (block.getRootBlock());\n\t\tconst memCache = moduleMemCaches && moduleMemCaches.get(module);\n\t\tif (memCache !== undefined) {\n\t\t\tconst map = memCache.provide(\n\t\t\t\t\"bundleChunkGraph.blockModules\",\n\t\t\t\truntime,\n\t\t\t\t() => {\n\t\t\t\t\tlogger.time(\"visitModules: prepare\");\n\t\t\t\t\tconst map = new Map();\n\t\t\t\t\textractBlockModules(module, moduleGraph, runtime, map);\n\t\t\t\t\tlogger.timeAggregate(\"visitModules: prepare\");\n\t\t\t\t\treturn map;\n\t\t\t\t}\n\t\t\t);\n\t\t\tfor (const [block, blockModules] of map)\n\t\t\t\tblockModulesMap.set(block, blockModules);\n\t\t\treturn map.get(block);\n\t\t} else {\n\t\t\tlogger.time(\"visitModules: prepare\");\n\t\t\textractBlockModules(module, moduleGraph, runtime, blockModulesMap);\n\t\t\tblockModules =\n\t\t\t\t/** @type {BlockModulesInFlattenTuples} */\n\t\t\t\t(blockModulesMap.get(block));\n\t\t\tlogger.timeAggregate(\"visitModules: prepare\");\n\t\t\treturn blockModules;\n\t\t}\n\t};\n\n\tlet statProcessedQueueItems = 0;\n\tlet statProcessedBlocks = 0;\n\tlet statConnectedChunkGroups = 0;\n\tlet statProcessedChunkGroupsForMerging = 0;\n\tlet statMergedAvailableModuleSets = 0;\n\tlet statForkedAvailableModules = 0;\n\tlet statForkedAvailableModulesCount = 0;\n\tlet statForkedAvailableModulesCountPlus = 0;\n\tlet statForkedMergedModulesCount = 0;\n\tlet statForkedMergedModulesCountPlus = 0;\n\tlet statForkedResultModulesCount = 0;\n\tlet statChunkGroupInfoUpdated = 0;\n\tlet statChildChunkGroupsReconnected = 0;\n\n\tlet nextChunkGroupIndex = 0;\n\tlet nextFreeModulePreOrderIndex = 0;\n\tlet nextFreeModulePostOrderIndex = 0;\n\n\t/** @type {Map<DependenciesBlock, ChunkGroupInfo>} */\n\tconst blockChunkGroups = new Map();\n\n\t/** @type {Map<ChunkGroupInfo, DependenciesBlock>} */\n\tconst blockByChunkGroups = new Map();\n\n\t/** @type {Map<string, ChunkGroupInfo>} */\n\tconst namedChunkGroups = new Map();\n\n\t/** @type {Map<string, ChunkGroupInfo>} */\n\tconst namedAsyncEntrypoints = new Map();\n\n\t/** @type {Set<ChunkGroupInfo>} */\n\tconst outdatedOrderIndexChunkGroups = new Set();\n\n\tconst ADD_AND_ENTER_ENTRY_MODULE = 0;\n\tconst ADD_AND_ENTER_MODULE = 1;\n\tconst ENTER_MODULE = 2;\n\tconst PROCESS_BLOCK = 3;\n\tconst PROCESS_ENTRY_BLOCK = 4;\n\tconst LEAVE_MODULE = 5;\n\n\t/** @type {QueueItem[]} */\n\tlet queue = [];\n\n\t/** @type {Map<ChunkGroupInfo, Set<ChunkGroupInfo>>} */\n\tconst queueConnect = new Map();\n\t/** @type {Set<ChunkGroupInfo>} */\n\tconst chunkGroupsForCombining = new Set();\n\n\t// Fill queue with entrypoint modules\n\t// Create ChunkGroupInfo for entrypoints\n\tfor (const [chunkGroup, modules] of inputEntrypointsAndModules) {\n\t\tconst runtime = getEntryRuntime(\n\t\t\tcompilation,\n\t\t\t/** @type {string} */ (chunkGroup.name),\n\t\t\tchunkGroup.options\n\t\t);\n\t\t/** @type {ChunkGroupInfo} */\n\t\tconst chunkGroupInfo = {\n\t\t\tchunkGroup,\n\t\t\truntime,\n\t\t\tminAvailableModules: undefined,\n\t\t\tavailableModulesToBeMerged: [],\n\t\t\tskippedItems: undefined,\n\t\t\tresultingAvailableModules: undefined,\n\t\t\tchildren: undefined,\n\t\t\tavailableSources: undefined,\n\t\t\tavailableChildren: undefined,\n\t\t\tpreOrderIndex: 0,\n\t\t\tpostOrderIndex: 0,\n\t\t\tchunkLoading:\n\t\t\t\tchunkGroup.options.chunkLoading !== undefined\n\t\t\t\t\t? chunkGroup.options.chunkLoading !== false\n\t\t\t\t\t: compilation.outputOptions.chunkLoading !== false,\n\t\t\tasyncChunks:\n\t\t\t\tchunkGroup.options.asyncChunks !== undefined\n\t\t\t\t\t? chunkGroup.options.asyncChunks\n\t\t\t\t\t: compilation.outputOptions.asyncChunks !== false\n\t\t};\n\t\tchunkGroup.index = nextChunkGroupIndex++;\n\t\tif (chunkGroup.getNumberOfParents() > 0) {\n\t\t\t// minAvailableModules for child entrypoints are unknown yet, set to undefined.\n\t\t\t// This means no module is added until other sets are merged into\n\t\t\t// this minAvailableModules (by the parent entrypoints)\n\t\t\tconst skippedItems = new Set(modules);\n\t\t\tchunkGroupInfo.skippedItems = skippedItems;\n\t\t\tchunkGroupsForCombining.add(chunkGroupInfo);\n\t\t} else {\n\t\t\t// The application may start here: We start with an empty list of available modules\n\t\t\tchunkGroupInfo.minAvailableModules = ZERO_BIGINT;\n\t\t\tconst chunk = chunkGroup.getEntrypointChunk();\n\t\t\tfor (const module of modules) {\n\t\t\t\tqueue.push({\n\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\n\t\t\t\t\tblock: module,\n\t\t\t\t\tmodule,\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\tchunkGroupInfo\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tchunkGroupInfoMap.set(chunkGroup, chunkGroupInfo);\n\t\tif (chunkGroup.name) {\n\t\t\tnamedChunkGroups.set(chunkGroup.name, chunkGroupInfo);\n\t\t}\n\t}\n\t// Fill availableSources with parent-child dependencies between entrypoints\n\tfor (const chunkGroupInfo of chunkGroupsForCombining) {\n\t\tconst { chunkGroup } = chunkGroupInfo;\n\t\tchunkGroupInfo.availableSources = new Set();\n\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\tconst parentChunkGroupInfo =\n\t\t\t\t/** @type {ChunkGroupInfo} */\n\t\t\t\t(chunkGroupInfoMap.get(parent));\n\t\t\tchunkGroupInfo.availableSources.add(parentChunkGroupInfo);\n\t\t\tif (parentChunkGroupInfo.availableChildren === undefined) {\n\t\t\t\tparentChunkGroupInfo.availableChildren = new Set();\n\t\t\t}\n\t\t\tparentChunkGroupInfo.availableChildren.add(chunkGroupInfo);\n\t\t}\n\t}\n\t// pop() is used to read from the queue\n\t// so it need to be reversed to be iterated in\n\t// correct order\n\tqueue.reverse();\n\n\t/** @type {Set<ChunkGroupInfo>} */\n\tconst outdatedChunkGroupInfo = new Set();\n\t/** @type {Set<ChunkGroupInfo>} */\n\tconst chunkGroupsForMerging = new Set();\n\t/** @type {QueueItem[]} */\n\tlet queueDelayed = [];\n\n\t/** @type {[Module, ModuleGraphConnection[]][]} */\n\tconst skipConnectionBuffer = [];\n\t/** @type {Module[]} */\n\tconst skipBuffer = [];\n\t/** @type {QueueItem[]} */\n\tconst queueBuffer = [];\n\n\t/** @type {Module} */\n\tlet module;\n\t/** @type {Chunk} */\n\tlet chunk;\n\t/** @type {ChunkGroup} */\n\tlet chunkGroup;\n\t/** @type {DependenciesBlock} */\n\tlet block;\n\t/** @type {ChunkGroupInfo} */\n\tlet chunkGroupInfo;\n\n\t// For each async Block in graph\n\t/**\n\t * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n\t * @returns {void}\n\t */\n\tconst iteratorBlock = b => {\n\t\t// 1. We create a chunk group with single chunk in it for this Block\n\t\t// but only once (blockChunkGroups map)\n\t\t/** @type {ChunkGroupInfo | undefined} */\n\t\tlet cgi = blockChunkGroups.get(b);\n\t\t/** @type {ChunkGroup | undefined} */\n\t\tlet c;\n\t\t/** @type {Entrypoint | undefined} */\n\t\tlet entrypoint;\n\t\tconst entryOptions = b.groupOptions && b.groupOptions.entryOptions;\n\t\tif (cgi === undefined) {\n\t\t\tconst chunkName = (b.groupOptions && b.groupOptions.name) || b.chunkName;\n\t\t\tif (entryOptions) {\n\t\t\t\tcgi = namedAsyncEntrypoints.get(/** @type {string} */ (chunkName));\n\t\t\t\tif (!cgi) {\n\t\t\t\t\tentrypoint = compilation.addAsyncEntrypoint(\n\t\t\t\t\t\tentryOptions,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t/** @type {DependencyLocation} */ (b.loc),\n\t\t\t\t\t\t/** @type {string} */ (b.request)\n\t\t\t\t\t);\n\t\t\t\t\tmaskByChunk.set(entrypoint.chunks[0], ZERO_BIGINT);\n\t\t\t\t\tentrypoint.index = nextChunkGroupIndex++;\n\t\t\t\t\tcgi = {\n\t\t\t\t\t\tchunkGroup: entrypoint,\n\t\t\t\t\t\truntime: entrypoint.options.runtime || entrypoint.name,\n\t\t\t\t\t\tminAvailableModules: ZERO_BIGINT,\n\t\t\t\t\t\tavailableModulesToBeMerged: [],\n\t\t\t\t\t\tskippedItems: undefined,\n\t\t\t\t\t\tresultingAvailableModules: undefined,\n\t\t\t\t\t\tchildren: undefined,\n\t\t\t\t\t\tavailableSources: undefined,\n\t\t\t\t\t\tavailableChildren: undefined,\n\t\t\t\t\t\tpreOrderIndex: 0,\n\t\t\t\t\t\tpostOrderIndex: 0,\n\t\t\t\t\t\tchunkLoading:\n\t\t\t\t\t\t\tentryOptions.chunkLoading !== undefined\n\t\t\t\t\t\t\t\t? entryOptions.chunkLoading !== false\n\t\t\t\t\t\t\t\t: chunkGroupInfo.chunkLoading,\n\t\t\t\t\t\tasyncChunks:\n\t\t\t\t\t\t\tentryOptions.asyncChunks !== undefined\n\t\t\t\t\t\t\t\t? entryOptions.asyncChunks\n\t\t\t\t\t\t\t\t: chunkGroupInfo.asyncChunks\n\t\t\t\t\t};\n\t\t\t\t\tchunkGroupInfoMap.set(entrypoint, cgi);\n\n\t\t\t\t\tchunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\tnamedAsyncEntrypoints.set(chunkName, cgi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tentrypoint = /** @type {Entrypoint} */ (cgi.chunkGroup);\n\t\t\t\t\t// TODO merge entryOptions\n\t\t\t\t\tentrypoint.addOrigin(\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t/** @type {DependencyLocation} */ (b.loc),\n\t\t\t\t\t\t/** @type {string} */ (b.request)\n\t\t\t\t\t);\n\t\t\t\t\tchunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n\t\t\t\t}\n\n\t\t\t\t// 2. We enqueue the DependenciesBlock for traversal\n\t\t\t\tqueueDelayed.push({\n\t\t\t\t\taction: PROCESS_ENTRY_BLOCK,\n\t\t\t\t\tblock: b,\n\t\t\t\t\tmodule,\n\t\t\t\t\tchunk: entrypoint.chunks[0],\n\t\t\t\t\tchunkGroup: entrypoint,\n\t\t\t\t\tchunkGroupInfo: cgi\n\t\t\t\t});\n\t\t\t} else if (!chunkGroupInfo.asyncChunks || !chunkGroupInfo.chunkLoading) {\n\t\t\t\t// Just queue the block into the current chunk group\n\t\t\t\tqueue.push({\n\t\t\t\t\taction: PROCESS_BLOCK,\n\t\t\t\t\tblock: b,\n\t\t\t\t\tmodule,\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\tchunkGroupInfo\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcgi = chunkName ? namedChunkGroups.get(chunkName) : undefined;\n\t\t\t\tif (!cgi) {\n\t\t\t\t\tc = compilation.addChunkInGroup(\n\t\t\t\t\t\tb.groupOptions || b.chunkName,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t/** @type {DependencyLocation} */ (b.loc),\n\t\t\t\t\t\t/** @type {string} */ (b.request)\n\t\t\t\t\t);\n\t\t\t\t\tmaskByChunk.set(c.chunks[0], ZERO_BIGINT);\n\t\t\t\t\tc.index = nextChunkGroupIndex++;\n\t\t\t\t\tcgi = {\n\t\t\t\t\t\tchunkGroup: c,\n\t\t\t\t\t\truntime: chunkGroupInfo.runtime,\n\t\t\t\t\t\tminAvailableModules: undefined,\n\t\t\t\t\t\tavailableModulesToBeMerged: [],\n\t\t\t\t\t\tskippedItems: undefined,\n\t\t\t\t\t\tresultingAvailableModules: undefined,\n\t\t\t\t\t\tchildren: undefined,\n\t\t\t\t\t\tavailableSources: undefined,\n\t\t\t\t\t\tavailableChildren: undefined,\n\t\t\t\t\t\tpreOrderIndex: 0,\n\t\t\t\t\t\tpostOrderIndex: 0,\n\t\t\t\t\t\tchunkLoading: chunkGroupInfo.chunkLoading,\n\t\t\t\t\t\tasyncChunks: chunkGroupInfo.asyncChunks\n\t\t\t\t\t};\n\t\t\t\t\tallCreatedChunkGroups.add(c);\n\t\t\t\t\tchunkGroupInfoMap.set(c, cgi);\n\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\tnamedChunkGroups.set(chunkName, cgi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tc = cgi.chunkGroup;\n\t\t\t\t\tif (c.isInitial()) {\n\t\t\t\t\t\tcompilation.errors.push(\n\t\t\t\t\t\t\tnew AsyncDependencyToInitialChunkError(\n\t\t\t\t\t\t\t\t/** @type {string} */ (chunkName),\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t/** @type {DependencyLocation} */ (b.loc)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tc = chunkGroup;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc.addOptions(b.groupOptions);\n\t\t\t\t\t}\n\t\t\t\t\tc.addOrigin(\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t/** @type {DependencyLocation} */ (b.loc),\n\t\t\t\t\t\t/** @type {string} */ (b.request)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tblockConnections.set(b, []);\n\t\t\t}\n\t\t\tblockChunkGroups.set(b, /** @type {ChunkGroupInfo} */ (cgi));\n\t\t\tblockByChunkGroups.set(/** @type {ChunkGroupInfo} */ (cgi), b);\n\t\t} else if (entryOptions) {\n\t\t\tentrypoint = /** @type {Entrypoint} */ (cgi.chunkGroup);\n\t\t} else {\n\t\t\tc = cgi.chunkGroup;\n\t\t}\n\n\t\tif (c !== undefined) {\n\t\t\t// 2. We store the connection for the block\n\t\t\t// to connect it later if needed\n\t\t\t/** @type {BlockChunkGroupConnection[]} */\n\t\t\t(blockConnections.get(b)).push({\n\t\t\t\toriginChunkGroupInfo: chunkGroupInfo,\n\t\t\t\tchunkGroup: c\n\t\t\t});\n\n\t\t\t// 3. We enqueue the chunk group info creation/updating\n\t\t\tlet connectList = queueConnect.get(chunkGroupInfo);\n\t\t\tif (connectList === undefined) {\n\t\t\t\tconnectList = new Set();\n\t\t\t\tqueueConnect.set(chunkGroupInfo, connectList);\n\t\t\t}\n\t\t\tconnectList.add(/** @type {ChunkGroupInfo} */ (cgi));\n\n\t\t\t// TODO check if this really need to be done for each traversal\n\t\t\t// or if it is enough when it's queued when created\n\t\t\t// 4. We enqueue the DependenciesBlock for traversal\n\t\t\tqueueDelayed.push({\n\t\t\t\taction: PROCESS_BLOCK,\n\t\t\t\tblock: b,\n\t\t\t\tmodule,\n\t\t\t\tchunk: c.chunks[0],\n\t\t\t\tchunkGroup: c,\n\t\t\t\tchunkGroupInfo: /** @type {ChunkGroupInfo} */ (cgi)\n\t\t\t});\n\t\t} else if (entrypoint !== undefined) {\n\t\t\tchunkGroupInfo.chunkGroup.addAsyncEntrypoint(entrypoint);\n\t\t}\n\t};\n\n\t/**\n\t * @param {DependenciesBlock} block the block\n\t * @returns {void}\n\t */\n\tconst processBlock = block => {\n\t\tstatProcessedBlocks++;\n\t\t// get prepared block info\n\t\tconst blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n\n\t\tif (blockModules !== undefined) {\n\t\t\tconst minAvailableModules =\n\t\t\t\t/** @type {bigint} */\n\t\t\t\t(chunkGroupInfo.minAvailableModules);\n\t\t\t// Buffer items because order need to be reversed to get indices correct\n\t\t\t// Traverse all referenced modules\n\t\t\tfor (let i = 0, len = blockModules.length; i < len; i += 3) {\n\t\t\t\tconst refModule = /** @type {Module} */ (blockModules[i]);\n\t\t\t\t// For single comparisons this might be cheaper\n\t\t\t\tconst isModuleInChunk = chunkGraph.isModuleInChunk(refModule, chunk);\n\n\t\t\t\tif (isModuleInChunk) {\n\t\t\t\t\t// skip early if already connected\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst refOrdinal = /** @type {number} */ getModuleOrdinal(refModule);\n\t\t\t\tconst activeState = /** @type {ConnectionState} */ (\n\t\t\t\t\tblockModules[i + 1]\n\t\t\t\t);\n\t\t\t\tif (activeState !== true) {\n\t\t\t\t\tconst connections = /** @type {ModuleGraphConnection[]} */ (\n\t\t\t\t\t\tblockModules[i + 2]\n\t\t\t\t\t);\n\t\t\t\t\tskipConnectionBuffer.push([refModule, connections]);\n\t\t\t\t\t// We skip inactive connections\n\t\t\t\t\tif (activeState === false) continue;\n\t\t\t\t} else if (isOrdinalSetInMask(minAvailableModules, refOrdinal)) {\n\t\t\t\t\t// already in parent chunks, skip it for now\n\t\t\t\t\tskipBuffer.push(refModule);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// enqueue, then add and enter to be in the correct order\n\t\t\t\t// this is relevant with circular dependencies\n\t\t\t\tqueueBuffer.push({\n\t\t\t\t\taction: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n\t\t\t\t\tblock: refModule,\n\t\t\t\t\tmodule: refModule,\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\tchunkGroupInfo\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Add buffered items in reverse order\n\t\t\tif (skipConnectionBuffer.length > 0) {\n\t\t\t\tlet { skippedModuleConnections } = chunkGroupInfo;\n\t\t\t\tif (skippedModuleConnections === undefined) {\n\t\t\t\t\tchunkGroupInfo.skippedModuleConnections = skippedModuleConnections =\n\t\t\t\t\t\tnew Set();\n\t\t\t\t}\n\t\t\t\tfor (let i = skipConnectionBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\tskippedModuleConnections.add(skipConnectionBuffer[i]);\n\t\t\t\t}\n\t\t\t\tskipConnectionBuffer.length = 0;\n\t\t\t}\n\t\t\tif (skipBuffer.length > 0) {\n\t\t\t\tlet { skippedItems } = chunkGroupInfo;\n\t\t\t\tif (skippedItems === undefined) {\n\t\t\t\t\tchunkGroupInfo.skippedItems = skippedItems = new Set();\n\t\t\t\t}\n\t\t\t\tfor (let i = skipBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\tskippedItems.add(skipBuffer[i]);\n\t\t\t\t}\n\t\t\t\tskipBuffer.length = 0;\n\t\t\t}\n\t\t\tif (queueBuffer.length > 0) {\n\t\t\t\tfor (let i = queueBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\tqueue.push(queueBuffer[i]);\n\t\t\t\t}\n\t\t\t\tqueueBuffer.length = 0;\n\t\t\t}\n\t\t}\n\n\t\t// Traverse all Blocks\n\t\tfor (const b of block.blocks) {\n\t\t\titeratorBlock(b);\n\t\t}\n\n\t\tif (block.blocks.length > 0 && module !== block) {\n\t\t\tblocksWithNestedBlocks.add(block);\n\t\t}\n\t};\n\n\t/**\n\t * @param {DependenciesBlock} block the block\n\t * @returns {void}\n\t */\n\tconst processEntryBlock = block => {\n\t\tstatProcessedBlocks++;\n\t\t// get prepared block info\n\t\tconst blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n\n\t\tif (blockModules !== undefined) {\n\t\t\t// Traverse all referenced modules in reverse order\n\t\t\tfor (let i = blockModules.length - 3; i >= 0; i -= 3) {\n\t\t\t\tconst refModule = /** @type {Module} */ (blockModules[i]);\n\t\t\t\tconst activeState = /** @type {ConnectionState} */ (\n\t\t\t\t\tblockModules[i + 1]\n\t\t\t\t);\n\t\t\t\t// enqueue, then add and enter to be in the correct order\n\t\t\t\t// this is relevant with circular dependencies\n\t\t\t\tqueue.push({\n\t\t\t\t\taction:\n\t\t\t\t\t\tactiveState === true ? ADD_AND_ENTER_ENTRY_MODULE : PROCESS_BLOCK,\n\t\t\t\t\tblock: refModule,\n\t\t\t\t\tmodule: refModule,\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\tchunkGroupInfo\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Traverse all Blocks\n\t\tfor (const b of block.blocks) {\n\t\t\titeratorBlock(b);\n\t\t}\n\n\t\tif (block.blocks.length > 0 && module !== block) {\n\t\t\tblocksWithNestedBlocks.add(block);\n\t\t}\n\t};\n\n\tconst processQueue = () => {\n\t\twhile (queue.length) {\n\t\t\tstatProcessedQueueItems++;\n\t\t\tconst queueItem = /** @type {QueueItem} */ (queue.pop());\n\t\t\tmodule = queueItem.module;\n\t\t\tblock = queueItem.block;\n\t\t\tchunk = queueItem.chunk;\n\t\t\tchunkGroup = queueItem.chunkGroup;\n\t\t\tchunkGroupInfo = queueItem.chunkGroupInfo;\n\n\t\t\tswitch (queueItem.action) {\n\t\t\t\tcase ADD_AND_ENTER_ENTRY_MODULE:\n\t\t\t\t\tchunkGraph.connectChunkAndEntryModule(\n\t\t\t\t\t\tchunk,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t/** @type {Entrypoint} */ (chunkGroup)\n\t\t\t\t\t);\n\t\t\t\t// fallthrough\n\t\t\t\tcase ADD_AND_ENTER_MODULE: {\n\t\t\t\t\tconst isModuleInChunk = chunkGraph.isModuleInChunk(module, chunk);\n\n\t\t\t\t\tif (isModuleInChunk) {\n\t\t\t\t\t\t// already connected, skip it\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// We connect Module and Chunk\n\t\t\t\t\tchunkGraph.connectChunkAndModule(chunk, module);\n\t\t\t\t\tconst moduleOrdinal = getModuleOrdinal(module);\n\t\t\t\t\tlet chunkMask = /** @type {bigint} */ (maskByChunk.get(chunk));\n\t\t\t\t\tchunkMask |= ONE_BIGINT << BigInt(moduleOrdinal);\n\t\t\t\t\tmaskByChunk.set(chunk, chunkMask);\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\t\tcase ENTER_MODULE: {\n\t\t\t\t\tconst index = chunkGroup.getModulePreOrderIndex(module);\n\t\t\t\t\tif (index === undefined) {\n\t\t\t\t\t\tchunkGroup.setModulePreOrderIndex(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tchunkGroupInfo.preOrderIndex++\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tmoduleGraph.setPreOrderIndexIfUnset(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tnextFreeModulePreOrderIndex\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tnextFreeModulePreOrderIndex++;\n\t\t\t\t\t}\n\n\t\t\t\t\t// reuse queueItem\n\t\t\t\t\tqueueItem.action = LEAVE_MODULE;\n\t\t\t\t\tqueue.push(queueItem);\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\t\tcase PROCESS_BLOCK: {\n\t\t\t\t\tprocessBlock(block);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase PROCESS_ENTRY_BLOCK: {\n\t\t\t\t\tprocessEntryBlock(block);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase LEAVE_MODULE: {\n\t\t\t\t\tconst index = chunkGroup.getModulePostOrderIndex(module);\n\t\t\t\t\tif (index === undefined) {\n\t\t\t\t\t\tchunkGroup.setModulePostOrderIndex(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tchunkGroupInfo.postOrderIndex++\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tmoduleGraph.setPostOrderIndexIfUnset(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tnextFreeModulePostOrderIndex\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tnextFreeModulePostOrderIndex++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @param {ChunkGroupInfo} chunkGroupInfo The info object for the chunk group\n\t * @returns {bigint} The mask of available modules after the chunk group\n\t */\n\tconst calculateResultingAvailableModules = chunkGroupInfo => {\n\t\tif (chunkGroupInfo.resultingAvailableModules !== undefined)\n\t\t\treturn chunkGroupInfo.resultingAvailableModules;\n\n\t\tlet resultingAvailableModules = /** @type {bigint} */ (\n\t\t\tchunkGroupInfo.minAvailableModules\n\t\t);\n\n\t\t// add the modules from the chunk group to the set\n\t\tfor (const chunk of chunkGroupInfo.chunkGroup.chunks) {\n\t\t\tconst mask = /** @type {bigint} */ (maskByChunk.get(chunk));\n\t\t\tresultingAvailableModules |= mask;\n\t\t}\n\n\t\treturn (chunkGroupInfo.resultingAvailableModules =\n\t\t\tresultingAvailableModules);\n\t};\n\n\tconst processConnectQueue = () => {\n\t\t// Figure out new parents for chunk groups\n\t\t// to get new available modules for these children\n\t\tfor (const [chunkGroupInfo, targets] of queueConnect) {\n\t\t\t// 1. Add new targets to the list of children\n\t\t\tif (chunkGroupInfo.children === undefined) {\n\t\t\t\tchunkGroupInfo.children = targets;\n\t\t\t} else {\n\t\t\t\tfor (const target of targets) {\n\t\t\t\t\tchunkGroupInfo.children.add(target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 2. Calculate resulting available modules\n\t\t\tconst resultingAvailableModules =\n\t\t\t\tcalculateResultingAvailableModules(chunkGroupInfo);\n\n\t\t\tconst runtime = chunkGroupInfo.runtime;\n\n\t\t\t// 3. Update chunk group info\n\t\t\tfor (const target of targets) {\n\t\t\t\ttarget.availableModulesToBeMerged.push(resultingAvailableModules);\n\t\t\t\tchunkGroupsForMerging.add(target);\n\t\t\t\tconst oldRuntime = target.runtime;\n\t\t\t\tconst newRuntime = mergeRuntime(oldRuntime, runtime);\n\t\t\t\tif (oldRuntime !== newRuntime) {\n\t\t\t\t\ttarget.runtime = newRuntime;\n\t\t\t\t\toutdatedChunkGroupInfo.add(target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatConnectedChunkGroups += targets.size;\n\t\t}\n\t\tqueueConnect.clear();\n\t};\n\n\tconst processChunkGroupsForMerging = () => {\n\t\tstatProcessedChunkGroupsForMerging += chunkGroupsForMerging.size;\n\n\t\t// Execute the merge\n\t\tfor (const info of chunkGroupsForMerging) {\n\t\t\tconst availableModulesToBeMerged = info.availableModulesToBeMerged;\n\t\t\tconst cachedMinAvailableModules = info.minAvailableModules;\n\t\t\tlet minAvailableModules = cachedMinAvailableModules;\n\n\t\t\tstatMergedAvailableModuleSets += availableModulesToBeMerged.length;\n\n\t\t\tfor (const availableModules of availableModulesToBeMerged) {\n\t\t\t\tif (minAvailableModules === undefined) {\n\t\t\t\t\tminAvailableModules = availableModules;\n\t\t\t\t} else {\n\t\t\t\t\tminAvailableModules &= availableModules;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst changed = minAvailableModules !== cachedMinAvailableModules;\n\n\t\t\tavailableModulesToBeMerged.length = 0;\n\t\t\tif (changed) {\n\t\t\t\tinfo.minAvailableModules = minAvailableModules;\n\t\t\t\tinfo.resultingAvailableModules = undefined;\n\t\t\t\toutdatedChunkGroupInfo.add(info);\n\t\t\t}\n\t\t}\n\t\tchunkGroupsForMerging.clear();\n\t};\n\n\tconst processChunkGroupsForCombining = () => {\n\t\tfor (const info of chunkGroupsForCombining) {\n\t\t\tfor (const source of /** @type {Set<ChunkGroupInfo>} */ (\n\t\t\t\tinfo.availableSources\n\t\t\t)) {\n\t\t\t\tif (source.minAvailableModules === undefined) {\n\t\t\t\t\tchunkGroupsForCombining.delete(info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const info of chunkGroupsForCombining) {\n\t\t\tlet availableModules = ZERO_BIGINT;\n\t\t\t// combine minAvailableModules from all resultingAvailableModules\n\t\t\tfor (const source of /** @type {Set<ChunkGroupInfo>} */ (\n\t\t\t\tinfo.availableSources\n\t\t\t)) {\n\t\t\t\tconst resultingAvailableModules =\n\t\t\t\t\tcalculateResultingAvailableModules(source);\n\t\t\t\tavailableModules |= resultingAvailableModules;\n\t\t\t}\n\t\t\tinfo.minAvailableModules = availableModules;\n\t\t\tinfo.resultingAvailableModules = undefined;\n\t\t\toutdatedChunkGroupInfo.add(info);\n\t\t}\n\t\tchunkGroupsForCombining.clear();\n\t};\n\n\tconst processOutdatedChunkGroupInfo = () => {\n\t\tstatChunkGroupInfoUpdated += outdatedChunkGroupInfo.size;\n\t\t// Revisit skipped elements\n\t\tfor (const info of outdatedChunkGroupInfo) {\n\t\t\t// 1. Reconsider skipped items\n\t\t\tif (info.skippedItems !== undefined) {\n\t\t\t\tconst minAvailableModules =\n\t\t\t\t\t/** @type {bigint} */\n\t\t\t\t\t(info.minAvailableModules);\n\t\t\t\tfor (const module of info.skippedItems) {\n\t\t\t\t\tconst ordinal = getModuleOrdinal(module);\n\t\t\t\t\tif (!isOrdinalSetInMask(minAvailableModules, ordinal)) {\n\t\t\t\t\t\tqueue.push({\n\t\t\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\n\t\t\t\t\t\t\tblock: module,\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tchunk: info.chunkGroup.chunks[0],\n\t\t\t\t\t\t\tchunkGroup: info.chunkGroup,\n\t\t\t\t\t\t\tchunkGroupInfo: info\n\t\t\t\t\t\t});\n\t\t\t\t\t\tinfo.skippedItems.delete(module);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 2. Reconsider skipped connections\n\t\t\tif (info.skippedModuleConnections !== undefined) {\n\t\t\t\tconst minAvailableModules =\n\t\t\t\t\t/** @type {bigint} */\n\t\t\t\t\t(info.minAvailableModules);\n\t\t\t\tfor (const entry of info.skippedModuleConnections) {\n\t\t\t\t\tconst [module, connections] = entry;\n\t\t\t\t\tconst activeState = getActiveStateOfConnections(\n\t\t\t\t\t\tconnections,\n\t\t\t\t\t\tinfo.runtime\n\t\t\t\t\t);\n\t\t\t\t\tif (activeState === false) continue;\n\t\t\t\t\tif (activeState === true) {\n\t\t\t\t\t\tconst ordinal = getModuleOrdinal(module);\n\t\t\t\t\t\tinfo.skippedModuleConnections.delete(entry);\n\t\t\t\t\t\tif (isOrdinalSetInMask(minAvailableModules, ordinal)) {\n\t\t\t\t\t\t\t/** @type {NonNullable<ChunkGroupInfo[\"skippedItems\"]>} */\n\t\t\t\t\t\t\t(info.skippedItems).add(module);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tqueue.push({\n\t\t\t\t\t\taction: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n\t\t\t\t\t\tblock: module,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tchunk: info.chunkGroup.chunks[0],\n\t\t\t\t\t\tchunkGroup: info.chunkGroup,\n\t\t\t\t\t\tchunkGroupInfo: info\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 2. Reconsider children chunk groups\n\t\t\tif (info.children !== undefined) {\n\t\t\t\tstatChildChunkGroupsReconnected += info.children.size;\n\t\t\t\tfor (const cgi of info.children) {\n\t\t\t\t\tlet connectList = queueConnect.get(info);\n\t\t\t\t\tif (connectList === undefined) {\n\t\t\t\t\t\tconnectList = new Set();\n\t\t\t\t\t\tqueueConnect.set(info, connectList);\n\t\t\t\t\t}\n\t\t\t\t\tconnectList.add(cgi);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 3. Reconsider chunk groups for combining\n\t\t\tif (info.availableChildren !== undefined) {\n\t\t\t\tfor (const cgi of info.availableChildren) {\n\t\t\t\t\tchunkGroupsForCombining.add(cgi);\n\t\t\t\t}\n\t\t\t}\n\t\t\toutdatedOrderIndexChunkGroups.add(info);\n\t\t}\n\t\toutdatedChunkGroupInfo.clear();\n\t};\n\n\t// Iterative traversal of the Module graph\n\t// Recursive would be simpler to write but could result in Stack Overflows\n\twhile (queue.length || queueConnect.size) {\n\t\tlogger.time(\"visitModules: visiting\");\n\t\tprocessQueue();\n\t\tlogger.timeAggregateEnd(\"visitModules: prepare\");\n\t\tlogger.timeEnd(\"visitModules: visiting\");\n\n\t\tif (chunkGroupsForCombining.size > 0) {\n\t\t\tlogger.time(\"visitModules: combine available modules\");\n\t\t\tprocessChunkGroupsForCombining();\n\t\t\tlogger.timeEnd(\"visitModules: combine available modules\");\n\t\t}\n\n\t\tif (queueConnect.size > 0) {\n\t\t\tlogger.time(\"visitModules: calculating available modules\");\n\t\t\tprocessConnectQueue();\n\t\t\tlogger.timeEnd(\"visitModules: calculating available modules\");\n\n\t\t\tif (chunkGroupsForMerging.size > 0) {\n\t\t\t\tlogger.time(\"visitModules: merging available modules\");\n\t\t\t\tprocessChunkGroupsForMerging();\n\t\t\t\tlogger.timeEnd(\"visitModules: merging available modules\");\n\t\t\t}\n\t\t}\n\n\t\tif (outdatedChunkGroupInfo.size > 0) {\n\t\t\tlogger.time(\"visitModules: check modules for revisit\");\n\t\t\tprocessOutdatedChunkGroupInfo();\n\t\t\tlogger.timeEnd(\"visitModules: check modules for revisit\");\n\t\t}\n\n\t\t// Run queueDelayed when all items of the queue are processed\n\t\t// This is important to get the global indexing correct\n\t\t// Async blocks should be processed after all sync blocks are processed\n\t\tif (queue.length === 0) {\n\t\t\tconst tempQueue = queue;\n\t\t\tqueue = queueDelayed.reverse();\n\t\t\tqueueDelayed = tempQueue;\n\t\t}\n\t}\n\n\tfor (const info of outdatedOrderIndexChunkGroups) {\n\t\tconst { chunkGroup, runtime } = info;\n\n\t\tconst block = blockByChunkGroups.get(info);\n\n\t\tif (!block) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet preOrderIndex = 0;\n\t\tlet postOrderIndex = 0;\n\n\t\t/**\n\t\t * @param {DependenciesBlock} current current\n\t\t * @param {BlocksWithNestedBlocks} visited visited dependencies blocks\n\t\t */\n\t\tconst process = (current, visited) => {\n\t\t\tconst blockModules = getBlockModules(current, runtime);\n\t\t\tif (blockModules === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (let i = 0, len = blockModules.length; i < len; i += 3) {\n\t\t\t\tconst activeState = /** @type {ConnectionState} */ (\n\t\t\t\t\tblockModules[i + 1]\n\t\t\t\t);\n\t\t\t\tif (activeState === false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst refModule = /** @type {Module} */ (blockModules[i]);\n\t\t\t\tif (visited.has(refModule)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvisited.add(refModule);\n\n\t\t\t\tif (refModule) {\n\t\t\t\t\tchunkGroup.setModulePreOrderIndex(refModule, preOrderIndex++);\n\t\t\t\t\tprocess(refModule, visited);\n\t\t\t\t\tchunkGroup.setModulePostOrderIndex(refModule, postOrderIndex++);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tprocess(block, new Set());\n\t}\n\toutdatedOrderIndexChunkGroups.clear();\n\tordinalByModule.clear();\n\n\tlogger.log(\n\t\t`${statProcessedQueueItems} queue items processed (${statProcessedBlocks} blocks)`\n\t);\n\tlogger.log(`${statConnectedChunkGroups} chunk groups connected`);\n\tlogger.log(\n\t\t`${statProcessedChunkGroupsForMerging} chunk groups processed for merging (${statMergedAvailableModuleSets} module sets, ${statForkedAvailableModules} forked, ${statForkedAvailableModulesCount} + ${statForkedAvailableModulesCountPlus} modules forked, ${statForkedMergedModulesCount} + ${statForkedMergedModulesCountPlus} modules merged into fork, ${statForkedResultModulesCount} resulting modules)`\n\t);\n\tlogger.log(\n\t\t`${statChunkGroupInfoUpdated} chunk group info updated (${statChildChunkGroupsReconnected} already connected chunk groups reconnected)`\n\t);\n};\n\n/**\n *\n * @param {Compilation} compilation the compilation\n * @param {BlocksWithNestedBlocks} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {BlockConnections} blockConnections connection for blocks\n * @param {MaskByChunk} maskByChunk mapping from chunk to module mask\n */\nconst connectChunkGroups = (\n\tcompilation,\n\tblocksWithNestedBlocks,\n\tblockConnections,\n\tmaskByChunk\n) => {\n\tconst { chunkGraph } = compilation;\n\n\t/**\n\t * Helper function to check if all modules of a chunk are available\n\t *\n\t * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n\t * @param {bigint} availableModules the comparator set\n\t * @returns {boolean} return true if all modules of a chunk are available\n\t */\n\tconst areModulesAvailable = (chunkGroup, availableModules) => {\n\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\tconst chunkMask = /** @type {bigint} */ (maskByChunk.get(chunk));\n\t\t\tif ((chunkMask & availableModules) !== chunkMask) return false;\n\t\t}\n\t\treturn true;\n\t};\n\n\t// For each edge in the basic chunk graph\n\tfor (const [block, connections] of blockConnections) {\n\t\t// 1. Check if connection is needed\n\t\t// When none of the dependencies need to be connected\n\t\t// we can skip all of them\n\t\t// It's not possible to filter each item so it doesn't create inconsistent\n\t\t// connections and modules can only create one version\n\t\t// TODO maybe decide this per runtime\n\t\tif (\n\t\t\t// TODO is this needed?\n\t\t\t!blocksWithNestedBlocks.has(block) &&\n\t\t\tconnections.every(({ chunkGroup, originChunkGroupInfo }) =>\n\t\t\t\tareModulesAvailable(\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\t/** @type {bigint} */ (originChunkGroupInfo.resultingAvailableModules)\n\t\t\t\t)\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// 2. Foreach edge\n\t\tfor (let i = 0; i < connections.length; i++) {\n\t\t\tconst { chunkGroup, originChunkGroupInfo } = connections[i];\n\n\t\t\t// 3. Connect block with chunk\n\t\t\tchunkGraph.connectBlockAndChunkGroup(block, chunkGroup);\n\n\t\t\t// 4. Connect chunk with parent\n\t\t\tconnectChunkGroupParentAndChild(\n\t\t\t\toriginChunkGroupInfo.chunkGroup,\n\t\t\t\tchunkGroup\n\t\t\t);\n\t\t}\n\t}\n};\n\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\nconst cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {\n\tconst { chunkGraph } = compilation;\n\n\tfor (const chunkGroup of allCreatedChunkGroups) {\n\t\tif (chunkGroup.getNumberOfParents() === 0) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tcompilation.chunks.delete(chunk);\n\t\t\t\tchunkGraph.disconnectChunk(chunk);\n\t\t\t}\n\t\t\tchunkGraph.disconnectChunkGroup(chunkGroup);\n\t\t\tchunkGroup.remove();\n\t\t}\n\t}\n};\n\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {InputEntrypointsAndModules} inputEntrypointsAndModules chunk groups which are processed with the modules\n * @returns {void}\n */\nconst buildChunkGraph = (compilation, inputEntrypointsAndModules) => {\n\tconst logger = compilation.getLogger(\"webpack.buildChunkGraph\");\n\n\t// SHARED STATE\n\n\t/** @type {BlockConnections} */\n\tconst blockConnections = new Map();\n\n\t/** @type {AllCreatedChunkGroups} */\n\tconst allCreatedChunkGroups = new Set();\n\n\t/** @type {ChunkGroupInfoMap} */\n\tconst chunkGroupInfoMap = new Map();\n\n\t/** @type {BlocksWithNestedBlocks} */\n\tconst blocksWithNestedBlocks = new Set();\n\n\t/** @type {MaskByChunk} */\n\tconst maskByChunk = new Map();\n\n\t// PART ONE\n\n\tlogger.time(\"visitModules\");\n\tvisitModules(\n\t\tlogger,\n\t\tcompilation,\n\t\tinputEntrypointsAndModules,\n\t\tchunkGroupInfoMap,\n\t\tblockConnections,\n\t\tblocksWithNestedBlocks,\n\t\tallCreatedChunkGroups,\n\t\tmaskByChunk\n\t);\n\tlogger.timeEnd(\"visitModules\");\n\n\t// PART TWO\n\n\tlogger.time(\"connectChunkGroups\");\n\tconnectChunkGroups(\n\t\tcompilation,\n\t\tblocksWithNestedBlocks,\n\t\tblockConnections,\n\t\tmaskByChunk\n\t);\n\tlogger.timeEnd(\"connectChunkGroups\");\n\n\tfor (const [chunkGroup, chunkGroupInfo] of chunkGroupInfoMap) {\n\t\tfor (const chunk of chunkGroup.chunks)\n\t\t\tchunk.runtime = mergeRuntime(chunk.runtime, chunkGroupInfo.runtime);\n\t}\n\n\t// Cleanup work\n\n\tlogger.time(\"cleanup\");\n\tcleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n\tlogger.timeEnd(\"cleanup\");\n};\n\nmodule.exports = buildChunkGraph;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
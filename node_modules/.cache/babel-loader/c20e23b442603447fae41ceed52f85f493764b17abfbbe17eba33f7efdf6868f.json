{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst util = require(\"util\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst {\n  compareLocations,\n  compareChunks,\n  compareIterables\n} = require(\"./util/comparators\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"./Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n\n/** @typedef {{id: number}} HasId */\n/** @typedef {{module: Module, loc: DependencyLocation, request: string}} OriginRecord */\n\n/**\n * @typedef {Object} RawChunkGroupOptions\n * @property {number=} preloadOrder\n * @property {number=} prefetchOrder\n * @property {(\"low\" | \"high\" | \"auto\")=} fetchPriority\n */\n\n/** @typedef {RawChunkGroupOptions & { name?: string }} ChunkGroupOptions */\n\nlet debugId = 5000;\n\n/**\n * @template T\n * @param {SortableSet<T>} set set to convert to array.\n * @returns {T[]} the array format of existing set\n */\nconst getArray = set => Array.from(set);\n\n/**\n * A convenience method used to sort chunks based on their id's\n * @param {ChunkGroup} a first sorting comparator\n * @param {ChunkGroup} b second sorting comparator\n * @returns {1|0|-1} a sorting index to determine order\n */\nconst sortById = (a, b) => {\n  if (a.id < b.id) return -1;\n  if (b.id < a.id) return 1;\n  return 0;\n};\n\n/**\n * @param {OriginRecord} a the first comparator in sort\n * @param {OriginRecord} b the second comparator in sort\n * @returns {1|-1|0} returns sorting order as index\n */\nconst sortOrigin = (a, b) => {\n  const aIdent = a.module ? a.module.identifier() : \"\";\n  const bIdent = b.module ? b.module.identifier() : \"\";\n  if (aIdent < bIdent) return -1;\n  if (aIdent > bIdent) return 1;\n  return compareLocations(a.loc, b.loc);\n};\nclass ChunkGroup {\n  /**\n   * Creates an instance of ChunkGroup.\n   * @param {string | ChunkGroupOptions=} options chunk group options passed to chunkGroup\n   */\n  constructor(options) {\n    if (typeof options === \"string\") {\n      options = {\n        name: options\n      };\n    } else if (!options) {\n      options = {\n        name: undefined\n      };\n    }\n    /** @type {number} */\n    this.groupDebugId = debugId++;\n    this.options = /** @type {ChunkGroupOptions} */options;\n    /** @type {SortableSet<ChunkGroup>} */\n    this._children = new SortableSet(undefined, sortById);\n    /** @type {SortableSet<ChunkGroup>} */\n    this._parents = new SortableSet(undefined, sortById);\n    /** @type {SortableSet<ChunkGroup>} */\n    this._asyncEntrypoints = new SortableSet(undefined, sortById);\n    this._blocks = new SortableSet();\n    /** @type {Chunk[]} */\n    this.chunks = [];\n    /** @type {OriginRecord[]} */\n    this.origins = [];\n    /** Indices in top-down order */\n    /** @private @type {Map<Module, number>} */\n    this._modulePreOrderIndices = new Map();\n    /** Indices in bottom-up order */\n    /** @private @type {Map<Module, number>} */\n    this._modulePostOrderIndices = new Map();\n    /** @type {number | undefined} */\n    this.index = undefined;\n  }\n\n  /**\n   * when a new chunk is added to a chunkGroup, addingOptions will occur.\n   * @param {ChunkGroupOptions} options the chunkGroup options passed to addOptions\n   * @returns {void}\n   */\n  addOptions(options) {\n    for (const _key of Object.keys(options)) {\n      const key = /** @type {keyof ChunkGroupOptions} */_key;\n      if (this.options[key] === undefined) {\n        /** @type {TODO} */\n        this.options[key] = options[key];\n      } else if (this.options[key] !== options[key]) {\n        if (key.endsWith(\"Order\")) {\n          /** @type {TODO} */\n          this.options[key] = Math.max( /** @type {number} */this.options[key], /** @type {number} */options[key]);\n        } else {\n          throw new Error(`ChunkGroup.addOptions: No option merge strategy for ${key}`);\n        }\n      }\n    }\n  }\n\n  /**\n   * returns the name of current ChunkGroup\n   * @returns {string | undefined} returns the ChunkGroup name\n   */\n  get name() {\n    return this.options.name;\n  }\n\n  /**\n   * sets a new name for current ChunkGroup\n   * @param {string | undefined} value the new name for ChunkGroup\n   * @returns {void}\n   */\n  set name(value) {\n    this.options.name = value;\n  }\n\n  /* istanbul ignore next */\n  /**\n   * get a uniqueId for ChunkGroup, made up of its member Chunk debugId's\n   * @returns {string} a unique concatenation of chunk debugId's\n   */\n  get debugId() {\n    return Array.from(this.chunks, x => x.debugId).join(\"+\");\n  }\n\n  /**\n   * get a unique id for ChunkGroup, made up of its member Chunk id's\n   * @returns {string} a unique concatenation of chunk ids\n   */\n  get id() {\n    return Array.from(this.chunks, x => x.id).join(\"+\");\n  }\n\n  /**\n   * Performs an unshift of a specific chunk\n   * @param {Chunk} chunk chunk being unshifted\n   * @returns {boolean} returns true if attempted chunk shift is accepted\n   */\n  unshiftChunk(chunk) {\n    const oldIdx = this.chunks.indexOf(chunk);\n    if (oldIdx > 0) {\n      this.chunks.splice(oldIdx, 1);\n      this.chunks.unshift(chunk);\n    } else if (oldIdx < 0) {\n      this.chunks.unshift(chunk);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * inserts a chunk before another existing chunk in group\n   * @param {Chunk} chunk Chunk being inserted\n   * @param {Chunk} before Placeholder/target chunk marking new chunk insertion point\n   * @returns {boolean} return true if insertion was successful\n   */\n  insertChunk(chunk, before) {\n    const oldIdx = this.chunks.indexOf(chunk);\n    const idx = this.chunks.indexOf(before);\n    if (idx < 0) {\n      throw new Error(\"before chunk not found\");\n    }\n    if (oldIdx >= 0 && oldIdx > idx) {\n      this.chunks.splice(oldIdx, 1);\n      this.chunks.splice(idx, 0, chunk);\n    } else if (oldIdx < 0) {\n      this.chunks.splice(idx, 0, chunk);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * add a chunk into ChunkGroup. Is pushed on or prepended\n   * @param {Chunk} chunk chunk being pushed into ChunkGroupS\n   * @returns {boolean} returns true if chunk addition was successful.\n   */\n  pushChunk(chunk) {\n    const oldIdx = this.chunks.indexOf(chunk);\n    if (oldIdx >= 0) {\n      return false;\n    }\n    this.chunks.push(chunk);\n    return true;\n  }\n\n  /**\n   * @param {Chunk} oldChunk chunk to be replaced\n   * @param {Chunk} newChunk New chunk that will be replaced with\n   * @returns {boolean | undefined} returns true if the replacement was successful\n   */\n  replaceChunk(oldChunk, newChunk) {\n    const oldIdx = this.chunks.indexOf(oldChunk);\n    if (oldIdx < 0) return false;\n    const newIdx = this.chunks.indexOf(newChunk);\n    if (newIdx < 0) {\n      this.chunks[oldIdx] = newChunk;\n      return true;\n    }\n    if (newIdx < oldIdx) {\n      this.chunks.splice(oldIdx, 1);\n      return true;\n    } else if (newIdx !== oldIdx) {\n      this.chunks[oldIdx] = newChunk;\n      this.chunks.splice(newIdx, 1);\n      return true;\n    }\n  }\n\n  /**\n   * @param {Chunk} chunk chunk to remove\n   * @returns {boolean} returns true if chunk was removed\n   */\n  removeChunk(chunk) {\n    const idx = this.chunks.indexOf(chunk);\n    if (idx >= 0) {\n      this.chunks.splice(idx, 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns {boolean} true, when this chunk group will be loaded on initial page load\n   */\n  isInitial() {\n    return false;\n  }\n\n  /**\n   * @param {ChunkGroup} group chunk group to add\n   * @returns {boolean} returns true if chunk group was added\n   */\n  addChild(group) {\n    const size = this._children.size;\n    this._children.add(group);\n    return size !== this._children.size;\n  }\n\n  /**\n   * @returns {ChunkGroup[]} returns the children of this group\n   */\n  getChildren() {\n    return this._children.getFromCache(getArray);\n  }\n  getNumberOfChildren() {\n    return this._children.size;\n  }\n  get childrenIterable() {\n    return this._children;\n  }\n\n  /**\n   * @param {ChunkGroup} group the chunk group to remove\n   * @returns {boolean} returns true if the chunk group was removed\n   */\n  removeChild(group) {\n    if (!this._children.has(group)) {\n      return false;\n    }\n    this._children.delete(group);\n    group.removeParent(this);\n    return true;\n  }\n\n  /**\n   * @param {ChunkGroup} parentChunk the parent group to be added into\n   * @returns {boolean} returns true if this chunk group was added to the parent group\n   */\n  addParent(parentChunk) {\n    if (!this._parents.has(parentChunk)) {\n      this._parents.add(parentChunk);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns {ChunkGroup[]} returns the parents of this group\n   */\n  getParents() {\n    return this._parents.getFromCache(getArray);\n  }\n  getNumberOfParents() {\n    return this._parents.size;\n  }\n\n  /**\n   * @param {ChunkGroup} parent the parent group\n   * @returns {boolean} returns true if the parent group contains this group\n   */\n  hasParent(parent) {\n    return this._parents.has(parent);\n  }\n  get parentsIterable() {\n    return this._parents;\n  }\n\n  /**\n   * @param {ChunkGroup} chunkGroup the parent group\n   * @returns {boolean} returns true if this group has been removed from the parent\n   */\n  removeParent(chunkGroup) {\n    if (this._parents.delete(chunkGroup)) {\n      chunkGroup.removeChild(this);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @param {Entrypoint} entrypoint entrypoint to add\n   * @returns {boolean} returns true if entrypoint was added\n   */\n  addAsyncEntrypoint(entrypoint) {\n    const size = this._asyncEntrypoints.size;\n    this._asyncEntrypoints.add(entrypoint);\n    return size !== this._asyncEntrypoints.size;\n  }\n  get asyncEntrypointsIterable() {\n    return this._asyncEntrypoints;\n  }\n\n  /**\n   * @returns {Array<AsyncDependenciesBlock>} an array containing the blocks\n   */\n  getBlocks() {\n    return this._blocks.getFromCache(getArray);\n  }\n  getNumberOfBlocks() {\n    return this._blocks.size;\n  }\n\n  /**\n   * @param {AsyncDependenciesBlock} block block\n   * @returns {boolean} true, if block exists\n   */\n  hasBlock(block) {\n    return this._blocks.has(block);\n  }\n\n  /**\n   * @returns {Iterable<AsyncDependenciesBlock>} blocks\n   */\n  get blocksIterable() {\n    return this._blocks;\n  }\n\n  /**\n   * @param {AsyncDependenciesBlock} block a block\n   * @returns {boolean} false, if block was already added\n   */\n  addBlock(block) {\n    if (!this._blocks.has(block)) {\n      this._blocks.add(block);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @param {Module} module origin module\n   * @param {DependencyLocation} loc location of the reference in the origin module\n   * @param {string} request request name of the reference\n   * @returns {void}\n   */\n  addOrigin(module, loc, request) {\n    this.origins.push({\n      module,\n      loc,\n      request\n    });\n  }\n\n  /**\n   * @returns {string[]} the files contained this chunk group\n   */\n  getFiles() {\n    const files = new Set();\n    for (const chunk of this.chunks) {\n      for (const file of chunk.files) {\n        files.add(file);\n      }\n    }\n    return Array.from(files);\n  }\n\n  /**\n   * @returns {void}\n   */\n  remove() {\n    // cleanup parents\n    for (const parentChunkGroup of this._parents) {\n      // remove this chunk from its parents\n      parentChunkGroup._children.delete(this);\n\n      // cleanup \"sub chunks\"\n      for (const chunkGroup of this._children) {\n        /**\n         * remove this chunk as \"intermediary\" and connect\n         * it \"sub chunks\" and parents directly\n         */\n        // add parent to each \"sub chunk\"\n        chunkGroup.addParent(parentChunkGroup);\n        // add \"sub chunk\" to parent\n        parentChunkGroup.addChild(chunkGroup);\n      }\n    }\n\n    /**\n     * we need to iterate again over the children\n     * to remove this from the child's parents.\n     * This can not be done in the above loop\n     * as it is not guaranteed that `this._parents` contains anything.\n     */\n    for (const chunkGroup of this._children) {\n      // remove this as parent of every \"sub chunk\"\n      chunkGroup._parents.delete(this);\n    }\n\n    // remove chunks\n    for (const chunk of this.chunks) {\n      chunk.removeGroup(this);\n    }\n  }\n  sortItems() {\n    this.origins.sort(sortOrigin);\n  }\n\n  /**\n   * Sorting predicate which allows current ChunkGroup to be compared against another.\n   * Sorting values are based off of number of chunks in ChunkGroup.\n   *\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @param {ChunkGroup} otherGroup the chunkGroup to compare this against\n   * @returns {-1|0|1} sort position for comparison\n   */\n  compareTo(chunkGraph, otherGroup) {\n    if (this.chunks.length > otherGroup.chunks.length) return -1;\n    if (this.chunks.length < otherGroup.chunks.length) return 1;\n    return compareIterables(compareChunks(chunkGraph))(this.chunks, otherGroup.chunks);\n  }\n\n  /**\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @returns {Record<string, ChunkGroup[]>} mapping from children type to ordered list of ChunkGroups\n   */\n  getChildrenByOrders(moduleGraph, chunkGraph) {\n    /** @type {Map<string, {order: number, group: ChunkGroup}[]>} */\n    const lists = new Map();\n    for (const childGroup of this._children) {\n      for (const key of Object.keys(childGroup.options)) {\n        if (key.endsWith(\"Order\")) {\n          const name = key.slice(0, key.length - \"Order\".length);\n          let list = lists.get(name);\n          if (list === undefined) {\n            lists.set(name, list = []);\n          }\n          list.push({\n            order: ( /** @type {number} */\n\n            childGroup.options[( /** @type {keyof ChunkGroupOptions} */key)]),\n            group: childGroup\n          });\n        }\n      }\n    }\n    /** @type {Record<string, ChunkGroup[]>} */\n    const result = Object.create(null);\n    for (const [name, list] of lists) {\n      list.sort((a, b) => {\n        const cmp = b.order - a.order;\n        if (cmp !== 0) return cmp;\n        return a.group.compareTo(chunkGraph, b.group);\n      });\n      result[name] = list.map(i => i.group);\n    }\n    return result;\n  }\n\n  /**\n   * Sets the top-down index of a module in this ChunkGroup\n   * @param {Module} module module for which the index should be set\n   * @param {number} index the index of the module\n   * @returns {void}\n   */\n  setModulePreOrderIndex(module, index) {\n    this._modulePreOrderIndices.set(module, index);\n  }\n\n  /**\n   * Gets the top-down index of a module in this ChunkGroup\n   * @param {Module} module the module\n   * @returns {number | undefined} index\n   */\n  getModulePreOrderIndex(module) {\n    return this._modulePreOrderIndices.get(module);\n  }\n\n  /**\n   * Sets the bottom-up index of a module in this ChunkGroup\n   * @param {Module} module module for which the index should be set\n   * @param {number} index the index of the module\n   * @returns {void}\n   */\n  setModulePostOrderIndex(module, index) {\n    this._modulePostOrderIndices.set(module, index);\n  }\n\n  /**\n   * Gets the bottom-up index of a module in this ChunkGroup\n   * @param {Module} module the module\n   * @returns {number | undefined} index\n   */\n  getModulePostOrderIndex(module) {\n    return this._modulePostOrderIndices.get(module);\n  }\n\n  /* istanbul ignore next */\n  checkConstraints() {\n    const chunk = this;\n    for (const child of chunk._children) {\n      if (!child._parents.has(chunk)) {\n        throw new Error(`checkConstraints: child missing parent ${chunk.debugId} -> ${child.debugId}`);\n      }\n    }\n    for (const parentChunk of chunk._parents) {\n      if (!parentChunk._children.has(chunk)) {\n        throw new Error(`checkConstraints: parent missing child ${parentChunk.debugId} <- ${chunk.debugId}`);\n      }\n    }\n  }\n}\nChunkGroup.prototype.getModuleIndex = util.deprecate(ChunkGroup.prototype.getModulePreOrderIndex, \"ChunkGroup.getModuleIndex was renamed to getModulePreOrderIndex\", \"DEP_WEBPACK_CHUNK_GROUP_GET_MODULE_INDEX\");\nChunkGroup.prototype.getModuleIndex2 = util.deprecate(ChunkGroup.prototype.getModulePostOrderIndex, \"ChunkGroup.getModuleIndex2 was renamed to getModulePostOrderIndex\", \"DEP_WEBPACK_CHUNK_GROUP_GET_MODULE_INDEX_2\");\nmodule.exports = ChunkGroup;","map":{"version":3,"names":["util","require","SortableSet","compareLocations","compareChunks","compareIterables","debugId","getArray","set","Array","from","sortById","a","b","id","sortOrigin","aIdent","module","identifier","bIdent","loc","ChunkGroup","constructor","options","name","undefined","groupDebugId","_children","_parents","_asyncEntrypoints","_blocks","chunks","origins","_modulePreOrderIndices","Map","_modulePostOrderIndices","index","addOptions","_key","Object","keys","key","endsWith","Math","max","Error","value","x","join","unshiftChunk","chunk","oldIdx","indexOf","splice","unshift","insertChunk","before","idx","pushChunk","push","replaceChunk","oldChunk","newChunk","newIdx","removeChunk","isInitial","addChild","group","size","add","getChildren","getFromCache","getNumberOfChildren","childrenIterable","removeChild","has","delete","removeParent","addParent","parentChunk","getParents","getNumberOfParents","hasParent","parent","parentsIterable","chunkGroup","addAsyncEntrypoint","entrypoint","asyncEntrypointsIterable","getBlocks","getNumberOfBlocks","hasBlock","block","blocksIterable","addBlock","addOrigin","request","getFiles","files","Set","file","remove","parentChunkGroup","removeGroup","sortItems","sort","compareTo","chunkGraph","otherGroup","length","getChildrenByOrders","moduleGraph","lists","childGroup","slice","list","get","order","result","create","cmp","map","i","setModulePreOrderIndex","getModulePreOrderIndex","setModulePostOrderIndex","getModulePostOrderIndex","checkConstraints","child","prototype","getModuleIndex","deprecate","getModuleIndex2","exports"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/ChunkGroup.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst util = require(\"util\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst {\n\tcompareLocations,\n\tcompareChunks,\n\tcompareIterables\n} = require(\"./util/comparators\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"./Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n\n/** @typedef {{id: number}} HasId */\n/** @typedef {{module: Module, loc: DependencyLocation, request: string}} OriginRecord */\n\n/**\n * @typedef {Object} RawChunkGroupOptions\n * @property {number=} preloadOrder\n * @property {number=} prefetchOrder\n * @property {(\"low\" | \"high\" | \"auto\")=} fetchPriority\n */\n\n/** @typedef {RawChunkGroupOptions & { name?: string }} ChunkGroupOptions */\n\nlet debugId = 5000;\n\n/**\n * @template T\n * @param {SortableSet<T>} set set to convert to array.\n * @returns {T[]} the array format of existing set\n */\nconst getArray = set => Array.from(set);\n\n/**\n * A convenience method used to sort chunks based on their id's\n * @param {ChunkGroup} a first sorting comparator\n * @param {ChunkGroup} b second sorting comparator\n * @returns {1|0|-1} a sorting index to determine order\n */\nconst sortById = (a, b) => {\n\tif (a.id < b.id) return -1;\n\tif (b.id < a.id) return 1;\n\treturn 0;\n};\n\n/**\n * @param {OriginRecord} a the first comparator in sort\n * @param {OriginRecord} b the second comparator in sort\n * @returns {1|-1|0} returns sorting order as index\n */\nconst sortOrigin = (a, b) => {\n\tconst aIdent = a.module ? a.module.identifier() : \"\";\n\tconst bIdent = b.module ? b.module.identifier() : \"\";\n\tif (aIdent < bIdent) return -1;\n\tif (aIdent > bIdent) return 1;\n\treturn compareLocations(a.loc, b.loc);\n};\n\nclass ChunkGroup {\n\t/**\n\t * Creates an instance of ChunkGroup.\n\t * @param {string | ChunkGroupOptions=} options chunk group options passed to chunkGroup\n\t */\n\tconstructor(options) {\n\t\tif (typeof options === \"string\") {\n\t\t\toptions = { name: options };\n\t\t} else if (!options) {\n\t\t\toptions = { name: undefined };\n\t\t}\n\t\t/** @type {number} */\n\t\tthis.groupDebugId = debugId++;\n\t\tthis.options = /** @type {ChunkGroupOptions} */ (options);\n\t\t/** @type {SortableSet<ChunkGroup>} */\n\t\tthis._children = new SortableSet(undefined, sortById);\n\t\t/** @type {SortableSet<ChunkGroup>} */\n\t\tthis._parents = new SortableSet(undefined, sortById);\n\t\t/** @type {SortableSet<ChunkGroup>} */\n\t\tthis._asyncEntrypoints = new SortableSet(undefined, sortById);\n\t\tthis._blocks = new SortableSet();\n\t\t/** @type {Chunk[]} */\n\t\tthis.chunks = [];\n\t\t/** @type {OriginRecord[]} */\n\t\tthis.origins = [];\n\t\t/** Indices in top-down order */\n\t\t/** @private @type {Map<Module, number>} */\n\t\tthis._modulePreOrderIndices = new Map();\n\t\t/** Indices in bottom-up order */\n\t\t/** @private @type {Map<Module, number>} */\n\t\tthis._modulePostOrderIndices = new Map();\n\t\t/** @type {number | undefined} */\n\t\tthis.index = undefined;\n\t}\n\n\t/**\n\t * when a new chunk is added to a chunkGroup, addingOptions will occur.\n\t * @param {ChunkGroupOptions} options the chunkGroup options passed to addOptions\n\t * @returns {void}\n\t */\n\taddOptions(options) {\n\t\tfor (const _key of Object.keys(options)) {\n\t\t\tconst key = /** @type {keyof ChunkGroupOptions} */ (_key);\n\t\t\tif (this.options[key] === undefined) {\n\t\t\t\t/** @type {TODO} */\n\t\t\t\t(this.options)[key] = options[key];\n\t\t\t} else if (this.options[key] !== options[key]) {\n\t\t\t\tif (key.endsWith(\"Order\")) {\n\t\t\t\t\t/** @type {TODO} */\n\t\t\t\t\t(this.options)[key] = Math.max(\n\t\t\t\t\t\t/** @type {number} */ (this.options[key]),\n\t\t\t\t\t\t/** @type {number} */ (options[key])\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`ChunkGroup.addOptions: No option merge strategy for ${key}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * returns the name of current ChunkGroup\n\t * @returns {string | undefined} returns the ChunkGroup name\n\t */\n\tget name() {\n\t\treturn this.options.name;\n\t}\n\n\t/**\n\t * sets a new name for current ChunkGroup\n\t * @param {string | undefined} value the new name for ChunkGroup\n\t * @returns {void}\n\t */\n\tset name(value) {\n\t\tthis.options.name = value;\n\t}\n\n\t/* istanbul ignore next */\n\t/**\n\t * get a uniqueId for ChunkGroup, made up of its member Chunk debugId's\n\t * @returns {string} a unique concatenation of chunk debugId's\n\t */\n\tget debugId() {\n\t\treturn Array.from(this.chunks, x => x.debugId).join(\"+\");\n\t}\n\n\t/**\n\t * get a unique id for ChunkGroup, made up of its member Chunk id's\n\t * @returns {string} a unique concatenation of chunk ids\n\t */\n\tget id() {\n\t\treturn Array.from(this.chunks, x => x.id).join(\"+\");\n\t}\n\n\t/**\n\t * Performs an unshift of a specific chunk\n\t * @param {Chunk} chunk chunk being unshifted\n\t * @returns {boolean} returns true if attempted chunk shift is accepted\n\t */\n\tunshiftChunk(chunk) {\n\t\tconst oldIdx = this.chunks.indexOf(chunk);\n\t\tif (oldIdx > 0) {\n\t\t\tthis.chunks.splice(oldIdx, 1);\n\t\t\tthis.chunks.unshift(chunk);\n\t\t} else if (oldIdx < 0) {\n\t\t\tthis.chunks.unshift(chunk);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * inserts a chunk before another existing chunk in group\n\t * @param {Chunk} chunk Chunk being inserted\n\t * @param {Chunk} before Placeholder/target chunk marking new chunk insertion point\n\t * @returns {boolean} return true if insertion was successful\n\t */\n\tinsertChunk(chunk, before) {\n\t\tconst oldIdx = this.chunks.indexOf(chunk);\n\t\tconst idx = this.chunks.indexOf(before);\n\t\tif (idx < 0) {\n\t\t\tthrow new Error(\"before chunk not found\");\n\t\t}\n\t\tif (oldIdx >= 0 && oldIdx > idx) {\n\t\t\tthis.chunks.splice(oldIdx, 1);\n\t\t\tthis.chunks.splice(idx, 0, chunk);\n\t\t} else if (oldIdx < 0) {\n\t\t\tthis.chunks.splice(idx, 0, chunk);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * add a chunk into ChunkGroup. Is pushed on or prepended\n\t * @param {Chunk} chunk chunk being pushed into ChunkGroupS\n\t * @returns {boolean} returns true if chunk addition was successful.\n\t */\n\tpushChunk(chunk) {\n\t\tconst oldIdx = this.chunks.indexOf(chunk);\n\t\tif (oldIdx >= 0) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.chunks.push(chunk);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Chunk} oldChunk chunk to be replaced\n\t * @param {Chunk} newChunk New chunk that will be replaced with\n\t * @returns {boolean | undefined} returns true if the replacement was successful\n\t */\n\treplaceChunk(oldChunk, newChunk) {\n\t\tconst oldIdx = this.chunks.indexOf(oldChunk);\n\t\tif (oldIdx < 0) return false;\n\t\tconst newIdx = this.chunks.indexOf(newChunk);\n\t\tif (newIdx < 0) {\n\t\t\tthis.chunks[oldIdx] = newChunk;\n\t\t\treturn true;\n\t\t}\n\t\tif (newIdx < oldIdx) {\n\t\t\tthis.chunks.splice(oldIdx, 1);\n\t\t\treturn true;\n\t\t} else if (newIdx !== oldIdx) {\n\t\t\tthis.chunks[oldIdx] = newChunk;\n\t\t\tthis.chunks.splice(newIdx, 1);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk chunk to remove\n\t * @returns {boolean} returns true if chunk was removed\n\t */\n\tremoveChunk(chunk) {\n\t\tconst idx = this.chunks.indexOf(chunk);\n\t\tif (idx >= 0) {\n\t\t\tthis.chunks.splice(idx, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean} true, when this chunk group will be loaded on initial page load\n\t */\n\tisInitial() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} group chunk group to add\n\t * @returns {boolean} returns true if chunk group was added\n\t */\n\taddChild(group) {\n\t\tconst size = this._children.size;\n\t\tthis._children.add(group);\n\t\treturn size !== this._children.size;\n\t}\n\n\t/**\n\t * @returns {ChunkGroup[]} returns the children of this group\n\t */\n\tgetChildren() {\n\t\treturn this._children.getFromCache(getArray);\n\t}\n\n\tgetNumberOfChildren() {\n\t\treturn this._children.size;\n\t}\n\n\tget childrenIterable() {\n\t\treturn this._children;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} group the chunk group to remove\n\t * @returns {boolean} returns true if the chunk group was removed\n\t */\n\tremoveChild(group) {\n\t\tif (!this._children.has(group)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._children.delete(group);\n\t\tgroup.removeParent(this);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} parentChunk the parent group to be added into\n\t * @returns {boolean} returns true if this chunk group was added to the parent group\n\t */\n\taddParent(parentChunk) {\n\t\tif (!this._parents.has(parentChunk)) {\n\t\t\tthis._parents.add(parentChunk);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {ChunkGroup[]} returns the parents of this group\n\t */\n\tgetParents() {\n\t\treturn this._parents.getFromCache(getArray);\n\t}\n\n\tgetNumberOfParents() {\n\t\treturn this._parents.size;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} parent the parent group\n\t * @returns {boolean} returns true if the parent group contains this group\n\t */\n\thasParent(parent) {\n\t\treturn this._parents.has(parent);\n\t}\n\n\tget parentsIterable() {\n\t\treturn this._parents;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the parent group\n\t * @returns {boolean} returns true if this group has been removed from the parent\n\t */\n\tremoveParent(chunkGroup) {\n\t\tif (this._parents.delete(chunkGroup)) {\n\t\t\tchunkGroup.removeChild(this);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Entrypoint} entrypoint entrypoint to add\n\t * @returns {boolean} returns true if entrypoint was added\n\t */\n\taddAsyncEntrypoint(entrypoint) {\n\t\tconst size = this._asyncEntrypoints.size;\n\t\tthis._asyncEntrypoints.add(entrypoint);\n\t\treturn size !== this._asyncEntrypoints.size;\n\t}\n\n\tget asyncEntrypointsIterable() {\n\t\treturn this._asyncEntrypoints;\n\t}\n\n\t/**\n\t * @returns {Array<AsyncDependenciesBlock>} an array containing the blocks\n\t */\n\tgetBlocks() {\n\t\treturn this._blocks.getFromCache(getArray);\n\t}\n\n\tgetNumberOfBlocks() {\n\t\treturn this._blocks.size;\n\t}\n\n\t/**\n\t * @param {AsyncDependenciesBlock} block block\n\t * @returns {boolean} true, if block exists\n\t */\n\thasBlock(block) {\n\t\treturn this._blocks.has(block);\n\t}\n\n\t/**\n\t * @returns {Iterable<AsyncDependenciesBlock>} blocks\n\t */\n\tget blocksIterable() {\n\t\treturn this._blocks;\n\t}\n\n\t/**\n\t * @param {AsyncDependenciesBlock} block a block\n\t * @returns {boolean} false, if block was already added\n\t */\n\taddBlock(block) {\n\t\tif (!this._blocks.has(block)) {\n\t\t\tthis._blocks.add(block);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Module} module origin module\n\t * @param {DependencyLocation} loc location of the reference in the origin module\n\t * @param {string} request request name of the reference\n\t * @returns {void}\n\t */\n\taddOrigin(module, loc, request) {\n\t\tthis.origins.push({\n\t\t\tmodule,\n\t\t\tloc,\n\t\t\trequest\n\t\t});\n\t}\n\n\t/**\n\t * @returns {string[]} the files contained this chunk group\n\t */\n\tgetFiles() {\n\t\tconst files = new Set();\n\n\t\tfor (const chunk of this.chunks) {\n\t\t\tfor (const file of chunk.files) {\n\t\t\t\tfiles.add(file);\n\t\t\t}\n\t\t}\n\n\t\treturn Array.from(files);\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tremove() {\n\t\t// cleanup parents\n\t\tfor (const parentChunkGroup of this._parents) {\n\t\t\t// remove this chunk from its parents\n\t\t\tparentChunkGroup._children.delete(this);\n\n\t\t\t// cleanup \"sub chunks\"\n\t\t\tfor (const chunkGroup of this._children) {\n\t\t\t\t/**\n\t\t\t\t * remove this chunk as \"intermediary\" and connect\n\t\t\t\t * it \"sub chunks\" and parents directly\n\t\t\t\t */\n\t\t\t\t// add parent to each \"sub chunk\"\n\t\t\t\tchunkGroup.addParent(parentChunkGroup);\n\t\t\t\t// add \"sub chunk\" to parent\n\t\t\t\tparentChunkGroup.addChild(chunkGroup);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * we need to iterate again over the children\n\t\t * to remove this from the child's parents.\n\t\t * This can not be done in the above loop\n\t\t * as it is not guaranteed that `this._parents` contains anything.\n\t\t */\n\t\tfor (const chunkGroup of this._children) {\n\t\t\t// remove this as parent of every \"sub chunk\"\n\t\t\tchunkGroup._parents.delete(this);\n\t\t}\n\n\t\t// remove chunks\n\t\tfor (const chunk of this.chunks) {\n\t\t\tchunk.removeGroup(this);\n\t\t}\n\t}\n\n\tsortItems() {\n\t\tthis.origins.sort(sortOrigin);\n\t}\n\n\t/**\n\t * Sorting predicate which allows current ChunkGroup to be compared against another.\n\t * Sorting values are based off of number of chunks in ChunkGroup.\n\t *\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {ChunkGroup} otherGroup the chunkGroup to compare this against\n\t * @returns {-1|0|1} sort position for comparison\n\t */\n\tcompareTo(chunkGraph, otherGroup) {\n\t\tif (this.chunks.length > otherGroup.chunks.length) return -1;\n\t\tif (this.chunks.length < otherGroup.chunks.length) return 1;\n\t\treturn compareIterables(compareChunks(chunkGraph))(\n\t\t\tthis.chunks,\n\t\t\totherGroup.chunks\n\t\t);\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @returns {Record<string, ChunkGroup[]>} mapping from children type to ordered list of ChunkGroups\n\t */\n\tgetChildrenByOrders(moduleGraph, chunkGraph) {\n\t\t/** @type {Map<string, {order: number, group: ChunkGroup}[]>} */\n\t\tconst lists = new Map();\n\t\tfor (const childGroup of this._children) {\n\t\t\tfor (const key of Object.keys(childGroup.options)) {\n\t\t\t\tif (key.endsWith(\"Order\")) {\n\t\t\t\t\tconst name = key.slice(0, key.length - \"Order\".length);\n\t\t\t\t\tlet list = lists.get(name);\n\t\t\t\t\tif (list === undefined) {\n\t\t\t\t\t\tlists.set(name, (list = []));\n\t\t\t\t\t}\n\t\t\t\t\tlist.push({\n\t\t\t\t\t\torder:\n\t\t\t\t\t\t\t/** @type {number} */\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tchildGroup.options[/** @type {keyof ChunkGroupOptions} */ (key)]\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\tgroup: childGroup\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/** @type {Record<string, ChunkGroup[]>} */\n\t\tconst result = Object.create(null);\n\t\tfor (const [name, list] of lists) {\n\t\t\tlist.sort((a, b) => {\n\t\t\t\tconst cmp = b.order - a.order;\n\t\t\t\tif (cmp !== 0) return cmp;\n\t\t\t\treturn a.group.compareTo(chunkGraph, b.group);\n\t\t\t});\n\t\t\tresult[name] = list.map(i => i.group);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Sets the top-down index of a module in this ChunkGroup\n\t * @param {Module} module module for which the index should be set\n\t * @param {number} index the index of the module\n\t * @returns {void}\n\t */\n\tsetModulePreOrderIndex(module, index) {\n\t\tthis._modulePreOrderIndices.set(module, index);\n\t}\n\n\t/**\n\t * Gets the top-down index of a module in this ChunkGroup\n\t * @param {Module} module the module\n\t * @returns {number | undefined} index\n\t */\n\tgetModulePreOrderIndex(module) {\n\t\treturn this._modulePreOrderIndices.get(module);\n\t}\n\n\t/**\n\t * Sets the bottom-up index of a module in this ChunkGroup\n\t * @param {Module} module module for which the index should be set\n\t * @param {number} index the index of the module\n\t * @returns {void}\n\t */\n\tsetModulePostOrderIndex(module, index) {\n\t\tthis._modulePostOrderIndices.set(module, index);\n\t}\n\n\t/**\n\t * Gets the bottom-up index of a module in this ChunkGroup\n\t * @param {Module} module the module\n\t * @returns {number | undefined} index\n\t */\n\tgetModulePostOrderIndex(module) {\n\t\treturn this._modulePostOrderIndices.get(module);\n\t}\n\n\t/* istanbul ignore next */\n\tcheckConstraints() {\n\t\tconst chunk = this;\n\t\tfor (const child of chunk._children) {\n\t\t\tif (!child._parents.has(chunk)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`checkConstraints: child missing parent ${chunk.debugId} -> ${child.debugId}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tfor (const parentChunk of chunk._parents) {\n\t\t\tif (!parentChunk._children.has(chunk)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`checkConstraints: parent missing child ${parentChunk.debugId} <- ${chunk.debugId}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\nChunkGroup.prototype.getModuleIndex = util.deprecate(\n\tChunkGroup.prototype.getModulePreOrderIndex,\n\t\"ChunkGroup.getModuleIndex was renamed to getModulePreOrderIndex\",\n\t\"DEP_WEBPACK_CHUNK_GROUP_GET_MODULE_INDEX\"\n);\n\nChunkGroup.prototype.getModuleIndex2 = util.deprecate(\n\tChunkGroup.prototype.getModulePostOrderIndex,\n\t\"ChunkGroup.getModuleIndex2 was renamed to getModulePostOrderIndex\",\n\t\"DEP_WEBPACK_CHUNK_GROUP_GET_MODULE_INDEX_2\"\n);\n\nmodule.exports = ChunkGroup;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
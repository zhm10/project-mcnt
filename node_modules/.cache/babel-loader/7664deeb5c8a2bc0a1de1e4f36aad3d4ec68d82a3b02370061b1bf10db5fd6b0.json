{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  STAGE_ADVANCED\n} = require(\"../OptimizationStages\");\nconst {\n  intersect\n} = require(\"../util/SetHelpers\");\nconst {\n  compareModulesByIdentifier,\n  compareChunks\n} = require(\"../util/comparators\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst identifierUtils = require(\"../util/identifier\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\nconst validate = createSchemaValidation(require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.check.js\"), () => require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\"), {\n  name: \"Aggressive Splitting Plugin\",\n  baseDataPath: \"options\"\n});\n\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Chunk} oldChunk the old chunk\n * @param {Chunk} newChunk the new chunk\n * @returns {(module: Module) => void} function to move module between chunks\n */\nconst moveModuleBetween = (chunkGraph, oldChunk, newChunk) => {\n  return module => {\n    chunkGraph.disconnectChunkAndModule(oldChunk, module);\n    chunkGraph.connectChunkAndModule(newChunk, module);\n  };\n};\n\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Chunk} chunk the chunk\n * @returns {function(Module): boolean} filter for entry module\n */\nconst isNotAEntryModule = (chunkGraph, chunk) => {\n  return module => {\n    return !chunkGraph.isEntryModuleInChunk(module, chunk);\n  };\n};\n\n/** @type {WeakSet<Chunk>} */\nconst recordedChunks = new WeakSet();\nclass AggressiveSplittingPlugin {\n  /**\n   * @param {AggressiveSplittingPluginOptions=} options options object\n   */\n  constructor(options = {}) {\n    validate(options);\n    this.options = options;\n    if (typeof this.options.minSize !== \"number\") {\n      this.options.minSize = 30 * 1024;\n    }\n    if (typeof this.options.maxSize !== \"number\") {\n      this.options.maxSize = 50 * 1024;\n    }\n    if (typeof this.options.chunkOverhead !== \"number\") {\n      this.options.chunkOverhead = 0;\n    }\n    if (typeof this.options.entryChunkMultiplicator !== \"number\") {\n      this.options.entryChunkMultiplicator = 1;\n    }\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk to test\n   * @returns {boolean} true if the chunk was recorded\n   */\n  static wasChunkRecorded(chunk) {\n    return recordedChunks.has(chunk);\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap(\"AggressiveSplittingPlugin\", compilation => {\n      let needAdditionalSeal = false;\n      let newSplits;\n      /** @type {Set<Chunk>} */\n      let fromAggressiveSplittingSet;\n      /** @type {Map<Chunk, TODO>} */\n      let chunkSplitDataMap;\n      compilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", () => {\n        newSplits = [];\n        fromAggressiveSplittingSet = new Set();\n        chunkSplitDataMap = new Map();\n      });\n      compilation.hooks.optimizeChunks.tap({\n        name: \"AggressiveSplittingPlugin\",\n        stage: STAGE_ADVANCED\n      }, chunks => {\n        const chunkGraph = compilation.chunkGraph;\n        // Precompute stuff\n        const nameToModuleMap = new Map();\n        const moduleToNameMap = new Map();\n        const makePathsRelative = identifierUtils.makePathsRelative.bindContextCache(compiler.context, compiler.root);\n        for (const m of compilation.modules) {\n          const name = makePathsRelative(m.identifier());\n          nameToModuleMap.set(name, m);\n          moduleToNameMap.set(m, name);\n        }\n\n        // Check used chunk ids\n        const usedIds = new Set();\n        for (const chunk of chunks) {\n          usedIds.add(chunk.id);\n        }\n        const recordedSplits = compilation.records && compilation.records.aggressiveSplits || [];\n        const usedSplits = newSplits ? recordedSplits.concat(newSplits) : recordedSplits;\n        const minSize = /** @type {number} */this.options.minSize;\n        const maxSize = /** @type {number} */this.options.maxSize;\n        const applySplit = splitData => {\n          // Cannot split if id is already taken\n          if (splitData.id !== undefined && usedIds.has(splitData.id)) {\n            return false;\n          }\n\n          // Get module objects from names\n          const selectedModules = splitData.modules.map(name => nameToModuleMap.get(name));\n\n          // Does the modules exist at all?\n          if (!selectedModules.every(Boolean)) return false;\n\n          // Check if size matches (faster than waiting for hash)\n          let size = 0;\n          for (const m of selectedModules) size += m.size();\n          if (size !== splitData.size) return false;\n\n          // get chunks with all modules\n          const selectedChunks = intersect(selectedModules.map(m => new Set(chunkGraph.getModuleChunksIterable(m))));\n\n          // No relevant chunks found\n          if (selectedChunks.size === 0) return false;\n\n          // The found chunk is already the split or similar\n          if (selectedChunks.size === 1 && chunkGraph.getNumberOfChunkModules(Array.from(selectedChunks)[0]) === selectedModules.length) {\n            const chunk = Array.from(selectedChunks)[0];\n            if (fromAggressiveSplittingSet.has(chunk)) return false;\n            fromAggressiveSplittingSet.add(chunk);\n            chunkSplitDataMap.set(chunk, splitData);\n            return true;\n          }\n\n          // split the chunk into two parts\n          const newChunk = compilation.addChunk();\n          newChunk.chunkReason = \"aggressive splitted\";\n          for (const chunk of selectedChunks) {\n            selectedModules.forEach(moveModuleBetween(chunkGraph, chunk, newChunk));\n            chunk.split(newChunk);\n            chunk.name = null;\n          }\n          fromAggressiveSplittingSet.add(newChunk);\n          chunkSplitDataMap.set(newChunk, splitData);\n          if (splitData.id !== null && splitData.id !== undefined) {\n            newChunk.id = splitData.id;\n            newChunk.ids = [splitData.id];\n          }\n          return true;\n        };\n\n        // try to restore to recorded splitting\n        let changed = false;\n        for (let j = 0; j < usedSplits.length; j++) {\n          const splitData = usedSplits[j];\n          if (applySplit(splitData)) changed = true;\n        }\n\n        // for any chunk which isn't splitted yet, split it and create a new entry\n        // start with the biggest chunk\n        const cmpFn = compareChunks(chunkGraph);\n        const sortedChunks = Array.from(chunks).sort((a, b) => {\n          const diff1 = chunkGraph.getChunkModulesSize(b) - chunkGraph.getChunkModulesSize(a);\n          if (diff1) return diff1;\n          const diff2 = chunkGraph.getNumberOfChunkModules(a) - chunkGraph.getNumberOfChunkModules(b);\n          if (diff2) return diff2;\n          return cmpFn(a, b);\n        });\n        for (const chunk of sortedChunks) {\n          if (fromAggressiveSplittingSet.has(chunk)) continue;\n          const size = chunkGraph.getChunkModulesSize(chunk);\n          if (size > maxSize && chunkGraph.getNumberOfChunkModules(chunk) > 1) {\n            const modules = chunkGraph.getOrderedChunkModules(chunk, compareModulesByIdentifier).filter(isNotAEntryModule(chunkGraph, chunk));\n            const selectedModules = [];\n            let selectedModulesSize = 0;\n            for (let k = 0; k < modules.length; k++) {\n              const module = modules[k];\n              const newSize = selectedModulesSize + module.size();\n              if (newSize > maxSize && selectedModulesSize >= minSize) {\n                break;\n              }\n              selectedModulesSize = newSize;\n              selectedModules.push(module);\n            }\n            if (selectedModules.length === 0) continue;\n            const splitData = {\n              modules: selectedModules.map(m => moduleToNameMap.get(m)).sort(),\n              size: selectedModulesSize\n            };\n            if (applySplit(splitData)) {\n              newSplits = (newSplits || []).concat(splitData);\n              changed = true;\n            }\n          }\n        }\n        if (changed) return true;\n      });\n      compilation.hooks.recordHash.tap(\"AggressiveSplittingPlugin\", records => {\n        // 4. save made splittings to records\n        const allSplits = new Set();\n        const invalidSplits = new Set();\n\n        // Check if some splittings are invalid\n        // We remove invalid splittings and try again\n        for (const chunk of compilation.chunks) {\n          const splitData = chunkSplitDataMap.get(chunk);\n          if (splitData !== undefined) {\n            if (splitData.hash && chunk.hash !== splitData.hash) {\n              // Split was successful, but hash doesn't equal\n              // We can throw away the split since it's useless now\n              invalidSplits.add(splitData);\n            }\n          }\n        }\n        if (invalidSplits.size > 0) {\n          records.aggressiveSplits = records.aggressiveSplits.filter(splitData => !invalidSplits.has(splitData));\n          needAdditionalSeal = true;\n        } else {\n          // set hash and id values on all (new) splittings\n          for (const chunk of compilation.chunks) {\n            const splitData = chunkSplitDataMap.get(chunk);\n            if (splitData !== undefined) {\n              splitData.hash = chunk.hash;\n              splitData.id = chunk.id;\n              allSplits.add(splitData);\n              // set flag for stats\n              recordedChunks.add(chunk);\n            }\n          }\n\n          // Also add all unused historical splits (after the used ones)\n          // They can still be used in some future compilation\n          const recordedSplits = compilation.records && compilation.records.aggressiveSplits;\n          if (recordedSplits) {\n            for (const splitData of recordedSplits) {\n              if (!invalidSplits.has(splitData)) allSplits.add(splitData);\n            }\n          }\n\n          // record all splits\n          records.aggressiveSplits = Array.from(allSplits);\n          needAdditionalSeal = false;\n        }\n      });\n      compilation.hooks.needAdditionalSeal.tap(\"AggressiveSplittingPlugin\", () => {\n        if (needAdditionalSeal) {\n          needAdditionalSeal = false;\n          return true;\n        }\n      });\n    });\n  }\n}\nmodule.exports = AggressiveSplittingPlugin;","map":{"version":3,"names":["STAGE_ADVANCED","require","intersect","compareModulesByIdentifier","compareChunks","createSchemaValidation","identifierUtils","validate","name","baseDataPath","moveModuleBetween","chunkGraph","oldChunk","newChunk","module","disconnectChunkAndModule","connectChunkAndModule","isNotAEntryModule","chunk","isEntryModuleInChunk","recordedChunks","WeakSet","AggressiveSplittingPlugin","constructor","options","minSize","maxSize","chunkOverhead","entryChunkMultiplicator","wasChunkRecorded","has","apply","compiler","hooks","thisCompilation","tap","compilation","needAdditionalSeal","newSplits","fromAggressiveSplittingSet","chunkSplitDataMap","optimize","Set","Map","optimizeChunks","stage","chunks","nameToModuleMap","moduleToNameMap","makePathsRelative","bindContextCache","context","root","m","modules","identifier","set","usedIds","add","id","recordedSplits","records","aggressiveSplits","usedSplits","concat","applySplit","splitData","undefined","selectedModules","map","get","every","Boolean","size","selectedChunks","getModuleChunksIterable","getNumberOfChunkModules","Array","from","length","addChunk","chunkReason","forEach","split","ids","changed","j","cmpFn","sortedChunks","sort","a","b","diff1","getChunkModulesSize","diff2","getOrderedChunkModules","filter","selectedModulesSize","k","newSize","push","recordHash","allSplits","invalidSplits","hash","exports"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/optimize/AggressiveSplittingPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { STAGE_ADVANCED } = require(\"../OptimizationStages\");\nconst { intersect } = require(\"../util/SetHelpers\");\nconst {\n\tcompareModulesByIdentifier,\n\tcompareChunks\n} = require(\"../util/comparators\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst identifierUtils = require(\"../util/identifier\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.check.js\"),\n\t() =>\n\t\trequire(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\"),\n\t{\n\t\tname: \"Aggressive Splitting Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Chunk} oldChunk the old chunk\n * @param {Chunk} newChunk the new chunk\n * @returns {(module: Module) => void} function to move module between chunks\n */\nconst moveModuleBetween = (chunkGraph, oldChunk, newChunk) => {\n\treturn module => {\n\t\tchunkGraph.disconnectChunkAndModule(oldChunk, module);\n\t\tchunkGraph.connectChunkAndModule(newChunk, module);\n\t};\n};\n\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Chunk} chunk the chunk\n * @returns {function(Module): boolean} filter for entry module\n */\nconst isNotAEntryModule = (chunkGraph, chunk) => {\n\treturn module => {\n\t\treturn !chunkGraph.isEntryModuleInChunk(module, chunk);\n\t};\n};\n\n/** @type {WeakSet<Chunk>} */\nconst recordedChunks = new WeakSet();\n\nclass AggressiveSplittingPlugin {\n\t/**\n\t * @param {AggressiveSplittingPluginOptions=} options options object\n\t */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\n\t\tthis.options = options;\n\t\tif (typeof this.options.minSize !== \"number\") {\n\t\t\tthis.options.minSize = 30 * 1024;\n\t\t}\n\t\tif (typeof this.options.maxSize !== \"number\") {\n\t\t\tthis.options.maxSize = 50 * 1024;\n\t\t}\n\t\tif (typeof this.options.chunkOverhead !== \"number\") {\n\t\t\tthis.options.chunkOverhead = 0;\n\t\t}\n\t\tif (typeof this.options.entryChunkMultiplicator !== \"number\") {\n\t\t\tthis.options.entryChunkMultiplicator = 1;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk to test\n\t * @returns {boolean} true if the chunk was recorded\n\t */\n\tstatic wasChunkRecorded(chunk) {\n\t\treturn recordedChunks.has(chunk);\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.thisCompilation.tap(\n\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\tcompilation => {\n\t\t\t\tlet needAdditionalSeal = false;\n\t\t\t\tlet newSplits;\n\t\t\t\t/** @type {Set<Chunk>} */\n\t\t\t\tlet fromAggressiveSplittingSet;\n\t\t\t\t/** @type {Map<Chunk, TODO>} */\n\t\t\t\tlet chunkSplitDataMap;\n\t\t\t\tcompilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", () => {\n\t\t\t\t\tnewSplits = [];\n\t\t\t\t\tfromAggressiveSplittingSet = new Set();\n\t\t\t\t\tchunkSplitDataMap = new Map();\n\t\t\t\t});\n\t\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"AggressiveSplittingPlugin\",\n\t\t\t\t\t\tstage: STAGE_ADVANCED\n\t\t\t\t\t},\n\t\t\t\t\tchunks => {\n\t\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\t\t// Precompute stuff\n\t\t\t\t\t\tconst nameToModuleMap = new Map();\n\t\t\t\t\t\tconst moduleToNameMap = new Map();\n\t\t\t\t\t\tconst makePathsRelative =\n\t\t\t\t\t\t\tidentifierUtils.makePathsRelative.bindContextCache(\n\t\t\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\t\t\tcompiler.root\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tfor (const m of compilation.modules) {\n\t\t\t\t\t\t\tconst name = makePathsRelative(m.identifier());\n\t\t\t\t\t\t\tnameToModuleMap.set(name, m);\n\t\t\t\t\t\t\tmoduleToNameMap.set(m, name);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check used chunk ids\n\t\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\tusedIds.add(chunk.id);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t(compilation.records && compilation.records.aggressiveSplits) ||\n\t\t\t\t\t\t\t[];\n\t\t\t\t\t\tconst usedSplits = newSplits\n\t\t\t\t\t\t\t? recordedSplits.concat(newSplits)\n\t\t\t\t\t\t\t: recordedSplits;\n\n\t\t\t\t\t\tconst minSize = /** @type {number} */ (this.options.minSize);\n\t\t\t\t\t\tconst maxSize = /** @type {number} */ (this.options.maxSize);\n\n\t\t\t\t\t\tconst applySplit = splitData => {\n\t\t\t\t\t\t\t// Cannot split if id is already taken\n\t\t\t\t\t\t\tif (splitData.id !== undefined && usedIds.has(splitData.id)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get module objects from names\n\t\t\t\t\t\t\tconst selectedModules = splitData.modules.map(name =>\n\t\t\t\t\t\t\t\tnameToModuleMap.get(name)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Does the modules exist at all?\n\t\t\t\t\t\t\tif (!selectedModules.every(Boolean)) return false;\n\n\t\t\t\t\t\t\t// Check if size matches (faster than waiting for hash)\n\t\t\t\t\t\t\tlet size = 0;\n\t\t\t\t\t\t\tfor (const m of selectedModules) size += m.size();\n\t\t\t\t\t\t\tif (size !== splitData.size) return false;\n\n\t\t\t\t\t\t\t// get chunks with all modules\n\t\t\t\t\t\t\tconst selectedChunks = intersect(\n\t\t\t\t\t\t\t\tselectedModules.map(\n\t\t\t\t\t\t\t\t\tm => new Set(chunkGraph.getModuleChunksIterable(m))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// No relevant chunks found\n\t\t\t\t\t\t\tif (selectedChunks.size === 0) return false;\n\n\t\t\t\t\t\t\t// The found chunk is already the split or similar\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tselectedChunks.size === 1 &&\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(\n\t\t\t\t\t\t\t\t\tArray.from(selectedChunks)[0]\n\t\t\t\t\t\t\t\t) === selectedModules.length\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst chunk = Array.from(selectedChunks)[0];\n\t\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) return false;\n\t\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(chunk);\n\t\t\t\t\t\t\t\tchunkSplitDataMap.set(chunk, splitData);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// split the chunk into two parts\n\t\t\t\t\t\t\tconst newChunk = compilation.addChunk();\n\t\t\t\t\t\t\tnewChunk.chunkReason = \"aggressive splitted\";\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tselectedModules.forEach(\n\t\t\t\t\t\t\t\t\tmoveModuleBetween(chunkGraph, chunk, newChunk)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t\t\tchunk.name = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(newChunk);\n\t\t\t\t\t\t\tchunkSplitDataMap.set(newChunk, splitData);\n\n\t\t\t\t\t\t\tif (splitData.id !== null && splitData.id !== undefined) {\n\t\t\t\t\t\t\t\tnewChunk.id = splitData.id;\n\t\t\t\t\t\t\t\tnewChunk.ids = [splitData.id];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// try to restore to recorded splitting\n\t\t\t\t\t\tlet changed = false;\n\t\t\t\t\t\tfor (let j = 0; j < usedSplits.length; j++) {\n\t\t\t\t\t\t\tconst splitData = usedSplits[j];\n\t\t\t\t\t\t\tif (applySplit(splitData)) changed = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// for any chunk which isn't splitted yet, split it and create a new entry\n\t\t\t\t\t\t// start with the biggest chunk\n\t\t\t\t\t\tconst cmpFn = compareChunks(chunkGraph);\n\t\t\t\t\t\tconst sortedChunks = Array.from(chunks).sort((a, b) => {\n\t\t\t\t\t\t\tconst diff1 =\n\t\t\t\t\t\t\t\tchunkGraph.getChunkModulesSize(b) -\n\t\t\t\t\t\t\t\tchunkGraph.getChunkModulesSize(a);\n\t\t\t\t\t\t\tif (diff1) return diff1;\n\t\t\t\t\t\t\tconst diff2 =\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(a) -\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(b);\n\t\t\t\t\t\t\tif (diff2) return diff2;\n\t\t\t\t\t\t\treturn cmpFn(a, b);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (const chunk of sortedChunks) {\n\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) continue;\n\t\t\t\t\t\t\tconst size = chunkGraph.getChunkModulesSize(chunk);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tsize > maxSize &&\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(chunk) > 1\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst modules = chunkGraph\n\t\t\t\t\t\t\t\t\t.getOrderedChunkModules(chunk, compareModulesByIdentifier)\n\t\t\t\t\t\t\t\t\t.filter(isNotAEntryModule(chunkGraph, chunk));\n\t\t\t\t\t\t\t\tconst selectedModules = [];\n\t\t\t\t\t\t\t\tlet selectedModulesSize = 0;\n\t\t\t\t\t\t\t\tfor (let k = 0; k < modules.length; k++) {\n\t\t\t\t\t\t\t\t\tconst module = modules[k];\n\t\t\t\t\t\t\t\t\tconst newSize = selectedModulesSize + module.size();\n\t\t\t\t\t\t\t\t\tif (newSize > maxSize && selectedModulesSize >= minSize) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tselectedModulesSize = newSize;\n\t\t\t\t\t\t\t\t\tselectedModules.push(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (selectedModules.length === 0) continue;\n\t\t\t\t\t\t\t\tconst splitData = {\n\t\t\t\t\t\t\t\t\tmodules: selectedModules\n\t\t\t\t\t\t\t\t\t\t.map(m => moduleToNameMap.get(m))\n\t\t\t\t\t\t\t\t\t\t.sort(),\n\t\t\t\t\t\t\t\t\tsize: selectedModulesSize\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tif (applySplit(splitData)) {\n\t\t\t\t\t\t\t\t\tnewSplits = (newSplits || []).concat(splitData);\n\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (changed) return true;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.recordHash.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\trecords => {\n\t\t\t\t\t\t// 4. save made splittings to records\n\t\t\t\t\t\tconst allSplits = new Set();\n\t\t\t\t\t\tconst invalidSplits = new Set();\n\n\t\t\t\t\t\t// Check if some splittings are invalid\n\t\t\t\t\t\t// We remove invalid splittings and try again\n\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\tif (splitData.hash && chunk.hash !== splitData.hash) {\n\t\t\t\t\t\t\t\t\t// Split was successful, but hash doesn't equal\n\t\t\t\t\t\t\t\t\t// We can throw away the split since it's useless now\n\t\t\t\t\t\t\t\t\tinvalidSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (invalidSplits.size > 0) {\n\t\t\t\t\t\t\trecords.aggressiveSplits = records.aggressiveSplits.filter(\n\t\t\t\t\t\t\t\tsplitData => !invalidSplits.has(splitData)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tneedAdditionalSeal = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// set hash and id values on all (new) splittings\n\t\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\t\tsplitData.hash = chunk.hash;\n\t\t\t\t\t\t\t\t\tsplitData.id = chunk.id;\n\t\t\t\t\t\t\t\t\tallSplits.add(splitData);\n\t\t\t\t\t\t\t\t\t// set flag for stats\n\t\t\t\t\t\t\t\t\trecordedChunks.add(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Also add all unused historical splits (after the used ones)\n\t\t\t\t\t\t\t// They can still be used in some future compilation\n\t\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t\tcompilation.records && compilation.records.aggressiveSplits;\n\t\t\t\t\t\t\tif (recordedSplits) {\n\t\t\t\t\t\t\t\tfor (const splitData of recordedSplits) {\n\t\t\t\t\t\t\t\t\tif (!invalidSplits.has(splitData)) allSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// record all splits\n\t\t\t\t\t\t\trecords.aggressiveSplits = Array.from(allSplits);\n\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.needAdditionalSeal.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\t() => {\n\t\t\t\t\t\tif (needAdditionalSeal) {\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = AggressiveSplittingPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
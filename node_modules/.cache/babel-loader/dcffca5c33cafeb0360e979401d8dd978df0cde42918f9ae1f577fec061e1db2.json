{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst NormalModule = require(\"../NormalModule\");\nconst LazySet = require(\"../util/LazySet\");\nconst LoaderDependency = require(\"./LoaderDependency\");\nconst LoaderImportDependency = require(\"./LoaderImportDependency\");\n\n/** @typedef {import(\"../Compilation\").DepConstructor} DepConstructor */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\n/**\n * @callback LoadModuleCallback\n * @param {(Error | null)=} err error object\n * @param {string | Buffer=} source source code\n * @param {object=} map source map\n * @param {Module=} module loaded module if successful\n */\n\n/**\n * @callback ImportModuleCallback\n * @param {(Error | null)=} err error object\n * @param {any=} exports exports of the evaluated module\n */\n\n/**\n * @typedef {Object} ImportModuleOptions\n * @property {string=} layer the target layer\n * @property {string=} publicPath the target public path\n * @property {string=} baseUri target base uri\n */\n\nclass LoaderPlugin {\n  /**\n   * @param {Object} options options\n   */\n  constructor(options = {}) {}\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"LoaderPlugin\", (compilation, {\n      normalModuleFactory\n    }) => {\n      compilation.dependencyFactories.set(LoaderDependency, normalModuleFactory);\n      compilation.dependencyFactories.set(LoaderImportDependency, normalModuleFactory);\n    });\n    compiler.hooks.compilation.tap(\"LoaderPlugin\", compilation => {\n      const moduleGraph = compilation.moduleGraph;\n      NormalModule.getCompilationHooks(compilation).loader.tap(\"LoaderPlugin\", loaderContext => {\n        /**\n         * @param {string} request the request string to load the module from\n         * @param {LoadModuleCallback} callback callback returning the loaded module or error\n         * @returns {void}\n         */\n        loaderContext.loadModule = (request, callback) => {\n          const dep = new LoaderDependency(request);\n          dep.loc = {\n            name: request\n          };\n          const factory = compilation.dependencyFactories.get( /** @type {DepConstructor} */dep.constructor);\n          if (factory === undefined) {\n            return callback(new Error(`No module factory available for dependency type: ${dep.constructor.name}`));\n          }\n          compilation.buildQueue.increaseParallelism();\n          compilation.handleModuleCreation({\n            factory,\n            dependencies: [dep],\n            originModule: loaderContext._module,\n            context: loaderContext.context,\n            recursive: false\n          }, err => {\n            compilation.buildQueue.decreaseParallelism();\n            if (err) {\n              return callback(err);\n            }\n            const referencedModule = moduleGraph.getModule(dep);\n            if (!referencedModule) {\n              return callback(new Error(\"Cannot load the module\"));\n            }\n            if (referencedModule.getNumberOfErrors() > 0) {\n              return callback(new Error(\"The loaded module contains errors\"));\n            }\n            const moduleSource = referencedModule.originalSource();\n            if (!moduleSource) {\n              return callback(new Error(\"The module created for a LoaderDependency must have an original source\"));\n            }\n            let source, map;\n            if (moduleSource.sourceAndMap) {\n              const sourceAndMap = moduleSource.sourceAndMap();\n              map = sourceAndMap.map;\n              source = sourceAndMap.source;\n            } else {\n              map = moduleSource.map();\n              source = moduleSource.source();\n            }\n            const fileDependencies = new LazySet();\n            const contextDependencies = new LazySet();\n            const missingDependencies = new LazySet();\n            const buildDependencies = new LazySet();\n            referencedModule.addCacheDependencies(fileDependencies, contextDependencies, missingDependencies, buildDependencies);\n            for (const d of fileDependencies) {\n              loaderContext.addDependency(d);\n            }\n            for (const d of contextDependencies) {\n              loaderContext.addContextDependency(d);\n            }\n            for (const d of missingDependencies) {\n              loaderContext.addMissingDependency(d);\n            }\n            for (const d of buildDependencies) {\n              loaderContext.addBuildDependency(d);\n            }\n            return callback(null, source, map, referencedModule);\n          });\n        };\n\n        /**\n         * @param {string} request the request string to load the module from\n         * @param {ImportModuleOptions=} options options\n         * @param {ImportModuleCallback=} callback callback returning the exports\n         * @returns {void}\n         */\n        const importModule = (request, options, callback) => {\n          const dep = new LoaderImportDependency(request);\n          dep.loc = {\n            name: request\n          };\n          const factory = compilation.dependencyFactories.get( /** @type {DepConstructor} */dep.constructor);\n          if (factory === undefined) {\n            return callback(new Error(`No module factory available for dependency type: ${dep.constructor.name}`));\n          }\n          compilation.buildQueue.increaseParallelism();\n          compilation.handleModuleCreation({\n            factory,\n            dependencies: [dep],\n            originModule: loaderContext._module,\n            contextInfo: {\n              issuerLayer: options.layer\n            },\n            context: loaderContext.context,\n            connectOrigin: false,\n            checkCycle: true\n          }, err => {\n            compilation.buildQueue.decreaseParallelism();\n            if (err) {\n              return callback(err);\n            }\n            const referencedModule = moduleGraph.getModule(dep);\n            if (!referencedModule) {\n              return callback(new Error(\"Cannot load the module\"));\n            }\n            compilation.executeModule(referencedModule, {\n              entryOptions: {\n                baseUri: options.baseUri,\n                publicPath: options.publicPath\n              }\n            }, (err, result) => {\n              if (err) return callback(err);\n              for (const d of result.fileDependencies) {\n                loaderContext.addDependency(d);\n              }\n              for (const d of result.contextDependencies) {\n                loaderContext.addContextDependency(d);\n              }\n              for (const d of result.missingDependencies) {\n                loaderContext.addMissingDependency(d);\n              }\n              for (const d of result.buildDependencies) {\n                loaderContext.addBuildDependency(d);\n              }\n              if (result.cacheable === false) loaderContext.cacheable(false);\n              for (const [name, {\n                source,\n                info\n              }] of result.assets) {\n                const {\n                  buildInfo\n                } = loaderContext._module;\n                if (!buildInfo.assets) {\n                  buildInfo.assets = Object.create(null);\n                  buildInfo.assetsInfo = new Map();\n                }\n                buildInfo.assets[name] = source;\n                buildInfo.assetsInfo.set(name, info);\n              }\n              callback(null, result.exports);\n            });\n          });\n        };\n\n        /**\n         * @param {string} request the request string to load the module from\n         * @param {ImportModuleOptions} options options\n         * @param {ImportModuleCallback=} callback callback returning the exports\n         * @returns {Promise<any> | void} exports\n         */\n        loaderContext.importModule = (request, options, callback) => {\n          if (!callback) {\n            return new Promise((resolve, reject) => {\n              importModule(request, options || {}, (err, result) => {\n                if (err) reject(err);else resolve(result);\n              });\n            });\n          }\n          return importModule(request, options || {}, callback);\n        };\n      });\n    });\n  }\n}\nmodule.exports = LoaderPlugin;","map":{"version":3,"names":["NormalModule","require","LazySet","LoaderDependency","LoaderImportDependency","LoaderPlugin","constructor","options","apply","compiler","hooks","compilation","tap","normalModuleFactory","dependencyFactories","set","moduleGraph","getCompilationHooks","loader","loaderContext","loadModule","request","callback","dep","loc","name","factory","get","undefined","Error","buildQueue","increaseParallelism","handleModuleCreation","dependencies","originModule","_module","context","recursive","err","decreaseParallelism","referencedModule","getModule","getNumberOfErrors","moduleSource","originalSource","source","map","sourceAndMap","fileDependencies","contextDependencies","missingDependencies","buildDependencies","addCacheDependencies","d","addDependency","addContextDependency","addMissingDependency","addBuildDependency","importModule","contextInfo","issuerLayer","layer","connectOrigin","checkCycle","executeModule","entryOptions","baseUri","publicPath","result","cacheable","info","assets","buildInfo","Object","create","assetsInfo","Map","exports","Promise","resolve","reject","module"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/dependencies/LoaderPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst NormalModule = require(\"../NormalModule\");\nconst LazySet = require(\"../util/LazySet\");\nconst LoaderDependency = require(\"./LoaderDependency\");\nconst LoaderImportDependency = require(\"./LoaderImportDependency\");\n\n/** @typedef {import(\"../Compilation\").DepConstructor} DepConstructor */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\n/**\n * @callback LoadModuleCallback\n * @param {(Error | null)=} err error object\n * @param {string | Buffer=} source source code\n * @param {object=} map source map\n * @param {Module=} module loaded module if successful\n */\n\n/**\n * @callback ImportModuleCallback\n * @param {(Error | null)=} err error object\n * @param {any=} exports exports of the evaluated module\n */\n\n/**\n * @typedef {Object} ImportModuleOptions\n * @property {string=} layer the target layer\n * @property {string=} publicPath the target public path\n * @property {string=} baseUri target base uri\n */\n\nclass LoaderPlugin {\n\t/**\n\t * @param {Object} options options\n\t */\n\tconstructor(options = {}) {}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"LoaderPlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tLoaderDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tLoaderImportDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\n\t\tcompiler.hooks.compilation.tap(\"LoaderPlugin\", compilation => {\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\tNormalModule.getCompilationHooks(compilation).loader.tap(\n\t\t\t\t\"LoaderPlugin\",\n\t\t\t\tloaderContext => {\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} request the request string to load the module from\n\t\t\t\t\t * @param {LoadModuleCallback} callback callback returning the loaded module or error\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tloaderContext.loadModule = (request, callback) => {\n\t\t\t\t\t\tconst dep = new LoaderDependency(request);\n\t\t\t\t\t\tdep.loc = {\n\t\t\t\t\t\t\tname: request\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst factory = compilation.dependencyFactories.get(\n\t\t\t\t\t\t\t/** @type {DepConstructor} */ (dep.constructor)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (factory === undefined) {\n\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t`No module factory available for dependency type: ${dep.constructor.name}`\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcompilation.buildQueue.increaseParallelism();\n\t\t\t\t\t\tcompilation.handleModuleCreation(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfactory,\n\t\t\t\t\t\t\t\tdependencies: [dep],\n\t\t\t\t\t\t\t\toriginModule: loaderContext._module,\n\t\t\t\t\t\t\t\tcontext: loaderContext.context,\n\t\t\t\t\t\t\t\trecursive: false\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\tcompilation.buildQueue.decreaseParallelism();\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst referencedModule = moduleGraph.getModule(dep);\n\t\t\t\t\t\t\t\tif (!referencedModule) {\n\t\t\t\t\t\t\t\t\treturn callback(new Error(\"Cannot load the module\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (referencedModule.getNumberOfErrors() > 0) {\n\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\tnew Error(\"The loaded module contains errors\")\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst moduleSource = referencedModule.originalSource();\n\t\t\t\t\t\t\t\tif (!moduleSource) {\n\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\"The module created for a LoaderDependency must have an original source\"\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet source, map;\n\t\t\t\t\t\t\t\tif (moduleSource.sourceAndMap) {\n\t\t\t\t\t\t\t\t\tconst sourceAndMap = moduleSource.sourceAndMap();\n\t\t\t\t\t\t\t\t\tmap = sourceAndMap.map;\n\t\t\t\t\t\t\t\t\tsource = sourceAndMap.source;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmap = moduleSource.map();\n\t\t\t\t\t\t\t\t\tsource = moduleSource.source();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst fileDependencies = new LazySet();\n\t\t\t\t\t\t\t\tconst contextDependencies = new LazySet();\n\t\t\t\t\t\t\t\tconst missingDependencies = new LazySet();\n\t\t\t\t\t\t\t\tconst buildDependencies = new LazySet();\n\t\t\t\t\t\t\t\treferencedModule.addCacheDependencies(\n\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\tcontextDependencies,\n\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\tbuildDependencies\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tfor (const d of fileDependencies) {\n\t\t\t\t\t\t\t\t\tloaderContext.addDependency(d);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const d of contextDependencies) {\n\t\t\t\t\t\t\t\t\tloaderContext.addContextDependency(d);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const d of missingDependencies) {\n\t\t\t\t\t\t\t\t\tloaderContext.addMissingDependency(d);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const d of buildDependencies) {\n\t\t\t\t\t\t\t\t\tloaderContext.addBuildDependency(d);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn callback(null, source, map, referencedModule);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} request the request string to load the module from\n\t\t\t\t\t * @param {ImportModuleOptions=} options options\n\t\t\t\t\t * @param {ImportModuleCallback=} callback callback returning the exports\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst importModule = (request, options, callback) => {\n\t\t\t\t\t\tconst dep = new LoaderImportDependency(request);\n\t\t\t\t\t\tdep.loc = {\n\t\t\t\t\t\t\tname: request\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst factory = compilation.dependencyFactories.get(\n\t\t\t\t\t\t\t/** @type {DepConstructor} */ (dep.constructor)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (factory === undefined) {\n\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t`No module factory available for dependency type: ${dep.constructor.name}`\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcompilation.buildQueue.increaseParallelism();\n\t\t\t\t\t\tcompilation.handleModuleCreation(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfactory,\n\t\t\t\t\t\t\t\tdependencies: [dep],\n\t\t\t\t\t\t\t\toriginModule: loaderContext._module,\n\t\t\t\t\t\t\t\tcontextInfo: {\n\t\t\t\t\t\t\t\t\tissuerLayer: options.layer\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcontext: loaderContext.context,\n\t\t\t\t\t\t\t\tconnectOrigin: false,\n\t\t\t\t\t\t\t\tcheckCycle: true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\tcompilation.buildQueue.decreaseParallelism();\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst referencedModule = moduleGraph.getModule(dep);\n\t\t\t\t\t\t\t\tif (!referencedModule) {\n\t\t\t\t\t\t\t\t\treturn callback(new Error(\"Cannot load the module\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcompilation.executeModule(\n\t\t\t\t\t\t\t\t\treferencedModule,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tentryOptions: {\n\t\t\t\t\t\t\t\t\t\t\tbaseUri: options.baseUri,\n\t\t\t\t\t\t\t\t\t\t\tpublicPath: options.publicPath\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\tfor (const d of result.fileDependencies) {\n\t\t\t\t\t\t\t\t\t\t\tloaderContext.addDependency(d);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor (const d of result.contextDependencies) {\n\t\t\t\t\t\t\t\t\t\t\tloaderContext.addContextDependency(d);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor (const d of result.missingDependencies) {\n\t\t\t\t\t\t\t\t\t\t\tloaderContext.addMissingDependency(d);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor (const d of result.buildDependencies) {\n\t\t\t\t\t\t\t\t\t\t\tloaderContext.addBuildDependency(d);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (result.cacheable === false)\n\t\t\t\t\t\t\t\t\t\t\tloaderContext.cacheable(false);\n\t\t\t\t\t\t\t\t\t\tfor (const [name, { source, info }] of result.assets) {\n\t\t\t\t\t\t\t\t\t\t\tconst { buildInfo } = loaderContext._module;\n\t\t\t\t\t\t\t\t\t\t\tif (!buildInfo.assets) {\n\t\t\t\t\t\t\t\t\t\t\t\tbuildInfo.assets = Object.create(null);\n\t\t\t\t\t\t\t\t\t\t\t\tbuildInfo.assetsInfo = new Map();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tbuildInfo.assets[name] = source;\n\t\t\t\t\t\t\t\t\t\t\tbuildInfo.assetsInfo.set(name, info);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcallback(null, result.exports);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} request the request string to load the module from\n\t\t\t\t\t * @param {ImportModuleOptions} options options\n\t\t\t\t\t * @param {ImportModuleCallback=} callback callback returning the exports\n\t\t\t\t\t * @returns {Promise<any> | void} exports\n\t\t\t\t\t */\n\t\t\t\t\tloaderContext.importModule = (request, options, callback) => {\n\t\t\t\t\t\tif (!callback) {\n\t\t\t\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\t\t\t\timportModule(request, options || {}, (err, result) => {\n\t\t\t\t\t\t\t\t\tif (err) reject(err);\n\t\t\t\t\t\t\t\t\telse resolve(result);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn importModule(request, options || {}, callback);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = LoaderPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
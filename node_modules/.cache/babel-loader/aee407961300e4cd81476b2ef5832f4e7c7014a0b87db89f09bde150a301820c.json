{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  STAGE_BASIC\n} = require(\"../OptimizationStages\");\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\n/**\n * Intersects multiple masks represented as bigints\n * @param {bigint[]} masks The module masks to intersect\n * @returns {bigint} The intersection of all masks\n */\nfunction intersectMasks(masks) {\n  let result = masks[0];\n  for (let i = masks.length - 1; i >= 1; i--) {\n    result &= masks[i];\n  }\n  return result;\n}\nconst ZERO_BIGINT = BigInt(0);\nconst ONE_BIGINT = BigInt(1);\nconst THIRTY_TWO_BIGINT = BigInt(32);\n\n/**\n * Parses the module mask and returns the modules represented by it\n * @param {bigint} mask the module mask\n * @param {Module[]} ordinalModules the modules in the order they were added to the mask (LSB is index 0)\n * @returns {Generator<Module>} the modules represented by the mask\n */\nfunction* getModulesFromMask(mask, ordinalModules) {\n  let offset = 31;\n  while (mask !== ZERO_BIGINT) {\n    // Consider the last 32 bits, since that's what Math.clz32 can handle\n    let last32 = Number(BigInt.asUintN(32, mask));\n    while (last32 > 0) {\n      let last = Math.clz32(last32);\n      // The number of trailing zeros is the number trimmed off the input mask + 31 - the number of leading zeros\n      // The 32 is baked into the initial value of offset\n      const moduleIndex = offset - last;\n      // The number of trailing zeros is the index into the array generated by getOrCreateModuleMask\n      const module = ordinalModules[moduleIndex];\n      yield module;\n      // Remove the matched module from the mask\n      // Since we can only count leading zeros, not trailing, we can't just downshift the mask\n      last32 &= ~(1 << 31 - last);\n    }\n\n    // Remove the processed chunk from the mask\n    mask >>= THIRTY_TWO_BIGINT;\n    offset += 32;\n  }\n}\nclass RemoveParentModulesPlugin {\n  /**\n   * @param {Compiler} compiler the compiler\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"RemoveParentModulesPlugin\", compilation => {\n      /**\n       * @param {Iterable<Chunk>} chunks the chunks\n       * @param {ChunkGroup[]} chunkGroups the chunk groups\n       */\n      const handler = (chunks, chunkGroups) => {\n        const chunkGraph = compilation.chunkGraph;\n        const queue = new Set();\n        const availableModulesMap = new WeakMap();\n        let nextModuleMask = ONE_BIGINT;\n        const maskByModule = new WeakMap();\n        /** @type {Module[]} */\n        const ordinalModules = [];\n\n        /**\n         * Gets or creates a unique mask for a module\n         * @param {Module} mod the module to get the mask for\n         * @returns {bigint} the module mask to uniquely identify the module\n         */\n        const getOrCreateModuleMask = mod => {\n          let id = maskByModule.get(mod);\n          if (id === undefined) {\n            id = nextModuleMask;\n            ordinalModules.push(mod);\n            maskByModule.set(mod, id);\n            nextModuleMask <<= ONE_BIGINT;\n          }\n          return id;\n        };\n\n        // Initialize masks by chunk and by chunk group for quicker comparisons\n        const chunkMasks = new WeakMap();\n        for (const chunk of chunks) {\n          let mask = ZERO_BIGINT;\n          for (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n            const id = getOrCreateModuleMask(m);\n            mask |= id;\n          }\n          chunkMasks.set(chunk, mask);\n        }\n        const chunkGroupMasks = new WeakMap();\n        for (const chunkGroup of chunkGroups) {\n          let mask = ZERO_BIGINT;\n          for (const chunk of chunkGroup.chunks) {\n            const chunkMask = chunkMasks.get(chunk);\n            if (chunkMask !== undefined) {\n              mask |= chunkMask;\n            }\n          }\n          chunkGroupMasks.set(chunkGroup, mask);\n        }\n        for (const chunkGroup of compilation.entrypoints.values()) {\n          // initialize available modules for chunks without parents\n          availableModulesMap.set(chunkGroup, ZERO_BIGINT);\n          for (const child of chunkGroup.childrenIterable) {\n            queue.add(child);\n          }\n        }\n        for (const chunkGroup of compilation.asyncEntrypoints) {\n          // initialize available modules for chunks without parents\n          availableModulesMap.set(chunkGroup, ZERO_BIGINT);\n          for (const child of chunkGroup.childrenIterable) {\n            queue.add(child);\n          }\n        }\n        for (const chunkGroup of queue) {\n          let availableModulesMask = availableModulesMap.get(chunkGroup);\n          let changed = false;\n          for (const parent of chunkGroup.parentsIterable) {\n            const availableModulesInParent = availableModulesMap.get(parent);\n            if (availableModulesInParent !== undefined) {\n              const parentMask = availableModulesInParent | chunkGroupMasks.get(parent);\n              // If we know the available modules in parent: process these\n              if (availableModulesMask === undefined) {\n                // if we have not own info yet: create new entry\n                availableModulesMask = parentMask;\n                changed = true;\n              } else {\n                let newMask = availableModulesMask & parentMask;\n                if (newMask !== availableModulesMask) {\n                  changed = true;\n                  availableModulesMask = newMask;\n                }\n              }\n            }\n          }\n          if (changed) {\n            availableModulesMap.set(chunkGroup, availableModulesMask);\n            // if something changed: enqueue our children\n            for (const child of chunkGroup.childrenIterable) {\n              // Push the child to the end of the queue\n              queue.delete(child);\n              queue.add(child);\n            }\n          }\n        }\n\n        // now we have available modules for every chunk\n        for (const chunk of chunks) {\n          const chunkMask = chunkMasks.get(chunk);\n          if (chunkMask === undefined) continue; // No info about this chunk\n\n          const availableModulesSets = Array.from(chunk.groupsIterable, chunkGroup => availableModulesMap.get(chunkGroup));\n          if (availableModulesSets.some(s => s === undefined)) continue; // No info about this chunk group\n\n          const availableModulesMask = intersectMasks(availableModulesSets);\n          const toRemoveMask = chunkMask & availableModulesMask;\n          if (toRemoveMask !== ZERO_BIGINT) {\n            for (const module of getModulesFromMask(toRemoveMask, ordinalModules)) {\n              chunkGraph.disconnectChunkAndModule(chunk, module);\n            }\n          }\n        }\n      };\n      compilation.hooks.optimizeChunks.tap({\n        name: \"RemoveParentModulesPlugin\",\n        stage: STAGE_BASIC\n      }, handler);\n    });\n  }\n}\nmodule.exports = RemoveParentModulesPlugin;","map":{"version":3,"names":["STAGE_BASIC","require","intersectMasks","masks","result","i","length","ZERO_BIGINT","BigInt","ONE_BIGINT","THIRTY_TWO_BIGINT","getModulesFromMask","mask","ordinalModules","offset","last32","Number","asUintN","last","Math","clz32","moduleIndex","module","RemoveParentModulesPlugin","apply","compiler","hooks","compilation","tap","handler","chunks","chunkGroups","chunkGraph","queue","Set","availableModulesMap","WeakMap","nextModuleMask","maskByModule","getOrCreateModuleMask","mod","id","get","undefined","push","set","chunkMasks","chunk","m","getChunkModulesIterable","chunkGroupMasks","chunkGroup","chunkMask","entrypoints","values","child","childrenIterable","add","asyncEntrypoints","availableModulesMask","changed","parent","parentsIterable","availableModulesInParent","parentMask","newMask","delete","availableModulesSets","Array","from","groupsIterable","some","s","toRemoveMask","disconnectChunkAndModule","optimizeChunks","name","stage","exports"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/optimize/RemoveParentModulesPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { STAGE_BASIC } = require(\"../OptimizationStages\");\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\n/**\n * Intersects multiple masks represented as bigints\n * @param {bigint[]} masks The module masks to intersect\n * @returns {bigint} The intersection of all masks\n */\nfunction intersectMasks(masks) {\n\tlet result = masks[0];\n\tfor (let i = masks.length - 1; i >= 1; i--) {\n\t\tresult &= masks[i];\n\t}\n\treturn result;\n}\n\nconst ZERO_BIGINT = BigInt(0);\nconst ONE_BIGINT = BigInt(1);\nconst THIRTY_TWO_BIGINT = BigInt(32);\n\n/**\n * Parses the module mask and returns the modules represented by it\n * @param {bigint} mask the module mask\n * @param {Module[]} ordinalModules the modules in the order they were added to the mask (LSB is index 0)\n * @returns {Generator<Module>} the modules represented by the mask\n */\nfunction* getModulesFromMask(mask, ordinalModules) {\n\tlet offset = 31;\n\twhile (mask !== ZERO_BIGINT) {\n\t\t// Consider the last 32 bits, since that's what Math.clz32 can handle\n\t\tlet last32 = Number(BigInt.asUintN(32, mask));\n\t\twhile (last32 > 0) {\n\t\t\tlet last = Math.clz32(last32);\n\t\t\t// The number of trailing zeros is the number trimmed off the input mask + 31 - the number of leading zeros\n\t\t\t// The 32 is baked into the initial value of offset\n\t\t\tconst moduleIndex = offset - last;\n\t\t\t// The number of trailing zeros is the index into the array generated by getOrCreateModuleMask\n\t\t\tconst module = ordinalModules[moduleIndex];\n\t\t\tyield module;\n\t\t\t// Remove the matched module from the mask\n\t\t\t// Since we can only count leading zeros, not trailing, we can't just downshift the mask\n\t\t\tlast32 &= ~(1 << (31 - last));\n\t\t}\n\n\t\t// Remove the processed chunk from the mask\n\t\tmask >>= THIRTY_TWO_BIGINT;\n\t\toffset += 32;\n\t}\n}\n\nclass RemoveParentModulesPlugin {\n\t/**\n\t * @param {Compiler} compiler the compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"RemoveParentModulesPlugin\", compilation => {\n\t\t\t/**\n\t\t\t * @param {Iterable<Chunk>} chunks the chunks\n\t\t\t * @param {ChunkGroup[]} chunkGroups the chunk groups\n\t\t\t */\n\t\t\tconst handler = (chunks, chunkGroups) => {\n\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\tconst queue = new Set();\n\t\t\t\tconst availableModulesMap = new WeakMap();\n\n\t\t\t\tlet nextModuleMask = ONE_BIGINT;\n\t\t\t\tconst maskByModule = new WeakMap();\n\t\t\t\t/** @type {Module[]} */\n\t\t\t\tconst ordinalModules = [];\n\n\t\t\t\t/**\n\t\t\t\t * Gets or creates a unique mask for a module\n\t\t\t\t * @param {Module} mod the module to get the mask for\n\t\t\t\t * @returns {bigint} the module mask to uniquely identify the module\n\t\t\t\t */\n\t\t\t\tconst getOrCreateModuleMask = mod => {\n\t\t\t\t\tlet id = maskByModule.get(mod);\n\t\t\t\t\tif (id === undefined) {\n\t\t\t\t\t\tid = nextModuleMask;\n\t\t\t\t\t\tordinalModules.push(mod);\n\t\t\t\t\t\tmaskByModule.set(mod, id);\n\t\t\t\t\t\tnextModuleMask <<= ONE_BIGINT;\n\t\t\t\t\t}\n\t\t\t\t\treturn id;\n\t\t\t\t};\n\n\t\t\t\t// Initialize masks by chunk and by chunk group for quicker comparisons\n\t\t\t\tconst chunkMasks = new WeakMap();\n\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\tlet mask = ZERO_BIGINT;\n\t\t\t\t\tfor (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\t\t\t\tconst id = getOrCreateModuleMask(m);\n\t\t\t\t\t\tmask |= id;\n\t\t\t\t\t}\n\t\t\t\t\tchunkMasks.set(chunk, mask);\n\t\t\t\t}\n\n\t\t\t\tconst chunkGroupMasks = new WeakMap();\n\t\t\t\tfor (const chunkGroup of chunkGroups) {\n\t\t\t\t\tlet mask = ZERO_BIGINT;\n\t\t\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\t\t\tconst chunkMask = chunkMasks.get(chunk);\n\t\t\t\t\t\tif (chunkMask !== undefined) {\n\t\t\t\t\t\t\tmask |= chunkMask;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tchunkGroupMasks.set(chunkGroup, mask);\n\t\t\t\t}\n\n\t\t\t\tfor (const chunkGroup of compilation.entrypoints.values()) {\n\t\t\t\t\t// initialize available modules for chunks without parents\n\t\t\t\t\tavailableModulesMap.set(chunkGroup, ZERO_BIGINT);\n\t\t\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\t\t\tqueue.add(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const chunkGroup of compilation.asyncEntrypoints) {\n\t\t\t\t\t// initialize available modules for chunks without parents\n\t\t\t\t\tavailableModulesMap.set(chunkGroup, ZERO_BIGINT);\n\t\t\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\t\t\tqueue.add(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const chunkGroup of queue) {\n\t\t\t\t\tlet availableModulesMask = availableModulesMap.get(chunkGroup);\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\t\t\t\tconst availableModulesInParent = availableModulesMap.get(parent);\n\t\t\t\t\t\tif (availableModulesInParent !== undefined) {\n\t\t\t\t\t\t\tconst parentMask =\n\t\t\t\t\t\t\t\tavailableModulesInParent | chunkGroupMasks.get(parent);\n\t\t\t\t\t\t\t// If we know the available modules in parent: process these\n\t\t\t\t\t\t\tif (availableModulesMask === undefined) {\n\t\t\t\t\t\t\t\t// if we have not own info yet: create new entry\n\t\t\t\t\t\t\t\tavailableModulesMask = parentMask;\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlet newMask = availableModulesMask & parentMask;\n\t\t\t\t\t\t\t\tif (newMask !== availableModulesMask) {\n\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\tavailableModulesMask = newMask;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (changed) {\n\t\t\t\t\t\tavailableModulesMap.set(chunkGroup, availableModulesMask);\n\t\t\t\t\t\t// if something changed: enqueue our children\n\t\t\t\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\t\t\t\t// Push the child to the end of the queue\n\t\t\t\t\t\t\tqueue.delete(child);\n\t\t\t\t\t\t\tqueue.add(child);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// now we have available modules for every chunk\n\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\tconst chunkMask = chunkMasks.get(chunk);\n\t\t\t\t\tif (chunkMask === undefined) continue; // No info about this chunk\n\n\t\t\t\t\tconst availableModulesSets = Array.from(\n\t\t\t\t\t\tchunk.groupsIterable,\n\t\t\t\t\t\tchunkGroup => availableModulesMap.get(chunkGroup)\n\t\t\t\t\t);\n\t\t\t\t\tif (availableModulesSets.some(s => s === undefined)) continue; // No info about this chunk group\n\n\t\t\t\t\tconst availableModulesMask = intersectMasks(availableModulesSets);\n\t\t\t\t\tconst toRemoveMask = chunkMask & availableModulesMask;\n\t\t\t\t\tif (toRemoveMask !== ZERO_BIGINT) {\n\t\t\t\t\t\tfor (const module of getModulesFromMask(\n\t\t\t\t\t\t\ttoRemoveMask,\n\t\t\t\t\t\t\tordinalModules\n\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t{\n\t\t\t\t\tname: \"RemoveParentModulesPlugin\",\n\t\t\t\t\tstage: STAGE_BASIC\n\t\t\t\t},\n\t\t\t\thandler\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = RemoveParentModulesPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst SortableSet = require(\"./SortableSet\");\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Entrypoint\").EntryOptions} EntryOptions */\n\n/** @typedef {string | SortableSet<string> | undefined} RuntimeSpec */\n/** @typedef {RuntimeSpec | boolean} RuntimeCondition */\n\n/**\n * @param {Compilation} compilation the compilation\n * @param {string} name name of the entry\n * @param {EntryOptions=} options optionally already received entry options\n * @returns {RuntimeSpec} runtime\n */\nexports.getEntryRuntime = (compilation, name, options) => {\n  let dependOn;\n  let runtime;\n  if (options) {\n    ({\n      dependOn,\n      runtime\n    } = options);\n  } else {\n    const entry = compilation.entries.get(name);\n    if (!entry) return name;\n    ({\n      dependOn,\n      runtime\n    } = entry.options);\n  }\n  if (dependOn) {\n    /** @type {RuntimeSpec} */\n    let result = undefined;\n    const queue = new Set(dependOn);\n    for (const name of queue) {\n      const dep = compilation.entries.get(name);\n      if (!dep) continue;\n      const {\n        dependOn,\n        runtime\n      } = dep.options;\n      if (dependOn) {\n        for (const name of dependOn) {\n          queue.add(name);\n        }\n      } else {\n        result = mergeRuntimeOwned(result, runtime || name);\n      }\n    }\n    return result || name;\n  } else {\n    return runtime || name;\n  }\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime\n * @param {function(string | undefined): void} fn functor\n * @param {boolean} deterministicOrder enforce a deterministic order\n * @returns {void}\n */\nconst forEachRuntime = (runtime, fn, deterministicOrder = false) => {\n  if (runtime === undefined) {\n    fn(undefined);\n  } else if (typeof runtime === \"string\") {\n    fn(runtime);\n  } else {\n    if (deterministicOrder) runtime.sort();\n    for (const r of runtime) {\n      fn(r);\n    }\n  }\n};\nexports.forEachRuntime = forEachRuntime;\n\n/**\n * @template T\n * @param {SortableSet<T>} set set\n * @returns {string} runtime key\n */\nconst getRuntimesKey = set => {\n  set.sort();\n  return Array.from(set).join(\"\\n\");\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime(s)\n * @returns {string} key of runtimes\n */\nconst getRuntimeKey = runtime => {\n  if (runtime === undefined) return \"*\";\n  if (typeof runtime === \"string\") return runtime;\n  return runtime.getFromUnorderedCache(getRuntimesKey);\n};\nexports.getRuntimeKey = getRuntimeKey;\n\n/**\n * @param {string} key key of runtimes\n * @returns {RuntimeSpec} runtime(s)\n */\nconst keyToRuntime = key => {\n  if (key === \"*\") return undefined;\n  const items = key.split(\"\\n\");\n  if (items.length === 1) return items[0];\n  return new SortableSet(items);\n};\nexports.keyToRuntime = keyToRuntime;\n\n/**\n * @template T\n * @param {SortableSet<T>} set set\n * @returns {string} runtime string\n */\nconst getRuntimesString = set => {\n  set.sort();\n  return Array.from(set).join(\"+\");\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime(s)\n * @returns {string} readable version\n */\nconst runtimeToString = runtime => {\n  if (runtime === undefined) return \"*\";\n  if (typeof runtime === \"string\") return runtime;\n  return runtime.getFromUnorderedCache(getRuntimesString);\n};\nexports.runtimeToString = runtimeToString;\n\n/**\n * @param {RuntimeCondition} runtimeCondition runtime condition\n * @returns {string} readable version\n */\nexports.runtimeConditionToString = runtimeCondition => {\n  if (runtimeCondition === true) return \"true\";\n  if (runtimeCondition === false) return \"false\";\n  return runtimeToString(runtimeCondition);\n};\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {boolean} true, when they are equal\n */\nconst runtimeEqual = (a, b) => {\n  if (a === b) {\n    return true;\n  } else if (a === undefined || b === undefined || typeof a === \"string\" || typeof b === \"string\") {\n    return false;\n  } else if (a.size !== b.size) {\n    return false;\n  } else {\n    a.sort();\n    b.sort();\n    const aIt = a[Symbol.iterator]();\n    const bIt = b[Symbol.iterator]();\n    for (;;) {\n      const aV = aIt.next();\n      if (aV.done) return true;\n      const bV = bIt.next();\n      if (aV.value !== bV.value) return false;\n    }\n  }\n};\nexports.runtimeEqual = runtimeEqual;\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {-1|0|1} compare\n */\nexports.compareRuntime = (a, b) => {\n  if (a === b) {\n    return 0;\n  } else if (a === undefined) {\n    return -1;\n  } else if (b === undefined) {\n    return 1;\n  } else {\n    const aKey = getRuntimeKey(a);\n    const bKey = getRuntimeKey(b);\n    if (aKey < bKey) return -1;\n    if (aKey > bKey) return 1;\n    return 0;\n  }\n};\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\nconst mergeRuntime = (a, b) => {\n  if (a === undefined) {\n    return b;\n  } else if (b === undefined) {\n    return a;\n  } else if (a === b) {\n    return a;\n  } else if (typeof a === \"string\") {\n    if (typeof b === \"string\") {\n      const set = new SortableSet();\n      set.add(a);\n      set.add(b);\n      return set;\n    } else if (b.has(a)) {\n      return b;\n    } else {\n      const set = new SortableSet(b);\n      set.add(a);\n      return set;\n    }\n  } else {\n    if (typeof b === \"string\") {\n      if (a.has(b)) return a;\n      const set = new SortableSet(a);\n      set.add(b);\n      return set;\n    } else {\n      const set = new SortableSet(a);\n      for (const item of b) set.add(item);\n      if (set.size === a.size) return a;\n      return set;\n    }\n  }\n};\nexports.mergeRuntime = mergeRuntime;\n\n/**\n * @param {RuntimeSpec[] | undefined} runtimes first\n * @param {RuntimeSpec} runtime second\n * @returns {RuntimeSpec} merged\n */\nexports.deepMergeRuntime = (runtimes, runtime) => {\n  if (!Array.isArray(runtimes)) {\n    return runtime;\n  }\n  let merged = runtime;\n  for (const r of runtimes) {\n    merged = mergeRuntime(runtime, r);\n  }\n  return merged;\n};\n\n/**\n * @param {RuntimeCondition} a first\n * @param {RuntimeCondition} b second\n * @param {RuntimeSpec} runtime full runtime\n * @returns {RuntimeCondition} result\n */\nexports.mergeRuntimeCondition = (a, b, runtime) => {\n  if (a === false) return b;\n  if (b === false) return a;\n  if (a === true || b === true) return true;\n  const merged = mergeRuntime(a, b);\n  if (merged === undefined) return undefined;\n  if (typeof merged === \"string\") {\n    if (typeof runtime === \"string\" && merged === runtime) return true;\n    return merged;\n  }\n  if (typeof runtime === \"string\" || runtime === undefined) return merged;\n  if (merged.size === runtime.size) return true;\n  return merged;\n};\n\n/**\n * @param {RuntimeSpec | true} a first\n * @param {RuntimeSpec | true} b second\n * @param {RuntimeSpec} runtime full runtime\n * @returns {RuntimeSpec | true} result\n */\nexports.mergeRuntimeConditionNonFalse = (a, b, runtime) => {\n  if (a === true || b === true) return true;\n  const merged = mergeRuntime(a, b);\n  if (merged === undefined) return undefined;\n  if (typeof merged === \"string\") {\n    if (typeof runtime === \"string\" && merged === runtime) return true;\n    return merged;\n  }\n  if (typeof runtime === \"string\" || runtime === undefined) return merged;\n  if (merged.size === runtime.size) return true;\n  return merged;\n};\n\n/**\n * @param {RuntimeSpec} a first (may be modified)\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\nconst mergeRuntimeOwned = (a, b) => {\n  if (b === undefined) {\n    return a;\n  } else if (a === b) {\n    return a;\n  } else if (a === undefined) {\n    if (typeof b === \"string\") {\n      return b;\n    } else {\n      return new SortableSet(b);\n    }\n  } else if (typeof a === \"string\") {\n    if (typeof b === \"string\") {\n      const set = new SortableSet();\n      set.add(a);\n      set.add(b);\n      return set;\n    } else {\n      const set = new SortableSet(b);\n      set.add(a);\n      return set;\n    }\n  } else {\n    if (typeof b === \"string\") {\n      a.add(b);\n      return a;\n    } else {\n      for (const item of b) a.add(item);\n      return a;\n    }\n  }\n};\nexports.mergeRuntimeOwned = mergeRuntimeOwned;\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\nexports.intersectRuntime = (a, b) => {\n  if (a === undefined) {\n    return b;\n  } else if (b === undefined) {\n    return a;\n  } else if (a === b) {\n    return a;\n  } else if (typeof a === \"string\") {\n    if (typeof b === \"string\") {\n      return undefined;\n    } else if (b.has(a)) {\n      return a;\n    } else {\n      return undefined;\n    }\n  } else {\n    if (typeof b === \"string\") {\n      if (a.has(b)) return b;\n      return undefined;\n    } else {\n      const set = new SortableSet();\n      for (const item of b) {\n        if (a.has(item)) set.add(item);\n      }\n      if (set.size === 0) return undefined;\n      if (set.size === 1) for (const item of set) return item;\n      return set;\n    }\n  }\n};\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} result\n */\nconst subtractRuntime = (a, b) => {\n  if (a === undefined) {\n    return undefined;\n  } else if (b === undefined) {\n    return a;\n  } else if (a === b) {\n    return undefined;\n  } else if (typeof a === \"string\") {\n    if (typeof b === \"string\") {\n      return a;\n    } else if (b.has(a)) {\n      return undefined;\n    } else {\n      return a;\n    }\n  } else {\n    if (typeof b === \"string\") {\n      if (!a.has(b)) return a;\n      if (a.size === 2) {\n        for (const item of a) {\n          if (item !== b) return item;\n        }\n      }\n      const set = new SortableSet(a);\n      set.delete(b);\n    } else {\n      const set = new SortableSet();\n      for (const item of a) {\n        if (!b.has(item)) set.add(item);\n      }\n      if (set.size === 0) return undefined;\n      if (set.size === 1) for (const item of set) return item;\n      return set;\n    }\n  }\n};\nexports.subtractRuntime = subtractRuntime;\n\n/**\n * @param {RuntimeCondition} a first\n * @param {RuntimeCondition} b second\n * @param {RuntimeSpec} runtime runtime\n * @returns {RuntimeCondition} result\n */\nexports.subtractRuntimeCondition = (a, b, runtime) => {\n  if (b === true) return false;\n  if (b === false) return a;\n  if (a === false) return false;\n  const result = subtractRuntime(a === true ? runtime : a, b);\n  return result === undefined ? false : result;\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime\n * @param {function(RuntimeSpec): boolean} filter filter function\n * @returns {boolean | RuntimeSpec} true/false if filter is constant for all runtimes, otherwise runtimes that are active\n */\nexports.filterRuntime = (runtime, filter) => {\n  if (runtime === undefined) return filter(undefined);\n  if (typeof runtime === \"string\") return filter(runtime);\n  let some = false;\n  let every = true;\n  let result = undefined;\n  for (const r of runtime) {\n    const v = filter(r);\n    if (v) {\n      some = true;\n      result = mergeRuntimeOwned(result, r);\n    } else {\n      every = false;\n    }\n  }\n  if (!some) return false;\n  if (every) return true;\n  return result;\n};\n\n/**\n * @template T\n * @typedef {Map<string, T>} RuntimeSpecMapInnerMap\n * */\n\n/**\n * @template T\n */\nclass RuntimeSpecMap {\n  /**\n   * @param {RuntimeSpecMap<T>=} clone copy form this\n   */\n  constructor(clone) {\n    this._mode = clone ? clone._mode : 0; // 0 = empty, 1 = single entry, 2 = map\n    /** @type {RuntimeSpec} */\n    this._singleRuntime = clone ? clone._singleRuntime : undefined;\n    /** @type {T | undefined} */\n    this._singleValue = clone ? clone._singleValue : undefined;\n    /** @type {RuntimeSpecMapInnerMap<T> | undefined} */\n    this._map = clone && clone._map ? new Map(clone._map) : undefined;\n  }\n\n  /**\n   * @param {RuntimeSpec} runtime the runtimes\n   * @returns {T | undefined} value\n   */\n  get(runtime) {\n    switch (this._mode) {\n      case 0:\n        return undefined;\n      case 1:\n        return runtimeEqual(this._singleRuntime, runtime) ? this._singleValue : undefined;\n      default:\n        return /** @type {RuntimeSpecMapInnerMap<T>} */this._map.get(getRuntimeKey(runtime));\n    }\n  }\n\n  /**\n   * @param {RuntimeSpec} runtime the runtimes\n   * @returns {boolean} true, when the runtime is stored\n   */\n  has(runtime) {\n    switch (this._mode) {\n      case 0:\n        return false;\n      case 1:\n        return runtimeEqual(this._singleRuntime, runtime);\n      default:\n        return /** @type {RuntimeSpecMapInnerMap<T>} */this._map.has(getRuntimeKey(runtime));\n    }\n  }\n\n  /**\n   * @param {RuntimeSpec} runtime the runtimes\n   * @param {T} value the value\n   */\n  set(runtime, value) {\n    switch (this._mode) {\n      case 0:\n        this._mode = 1;\n        this._singleRuntime = runtime;\n        this._singleValue = value;\n        break;\n      case 1:\n        if (runtimeEqual(this._singleRuntime, runtime)) {\n          this._singleValue = value;\n          break;\n        }\n        this._mode = 2;\n        this._map = new Map();\n        this._map.set(getRuntimeKey(this._singleRuntime), /** @type {T} */this._singleValue);\n        this._singleRuntime = undefined;\n        this._singleValue = undefined;\n      /* falls through */\n      default:\n        /** @type {RuntimeSpecMapInnerMap<T>} */\n        this._map.set(getRuntimeKey(runtime), value);\n    }\n  }\n\n  /**\n   * @param {RuntimeSpec} runtime the runtimes\n   * @param {() => TODO} computer function to compute the value\n   * @returns {TODO} true, when the runtime was deleted\n   */\n  provide(runtime, computer) {\n    switch (this._mode) {\n      case 0:\n        this._mode = 1;\n        this._singleRuntime = runtime;\n        return this._singleValue = computer();\n      case 1:\n        {\n          if (runtimeEqual(this._singleRuntime, runtime)) {\n            return /** @type {T} */this._singleValue;\n          }\n          this._mode = 2;\n          this._map = new Map();\n          this._map.set(getRuntimeKey(this._singleRuntime), /** @type {T} */this._singleValue);\n          this._singleRuntime = undefined;\n          this._singleValue = undefined;\n          const newValue = computer();\n          this._map.set(getRuntimeKey(runtime), newValue);\n          return newValue;\n        }\n      default:\n        {\n          const key = getRuntimeKey(runtime);\n          const value = /** @type {Map<string, T>} */this._map.get(key);\n          if (value !== undefined) return value;\n          const newValue = computer();\n          /** @type {Map<string, T>} */\n          this._map.set(key, newValue);\n          return newValue;\n        }\n    }\n  }\n\n  /**\n   * @param {RuntimeSpec} runtime the runtimes\n   */\n  delete(runtime) {\n    switch (this._mode) {\n      case 0:\n        return;\n      case 1:\n        if (runtimeEqual(this._singleRuntime, runtime)) {\n          this._mode = 0;\n          this._singleRuntime = undefined;\n          this._singleValue = undefined;\n        }\n        return;\n      default:\n        /** @type {RuntimeSpecMapInnerMap<T>} */\n        this._map.delete(getRuntimeKey(runtime));\n    }\n  }\n\n  /**\n   * @param {RuntimeSpec} runtime the runtimes\n   * @param {function(T | undefined): T} fn function to update the value\n   */\n  update(runtime, fn) {\n    switch (this._mode) {\n      case 0:\n        throw new Error(\"runtime passed to update must exist\");\n      case 1:\n        {\n          if (runtimeEqual(this._singleRuntime, runtime)) {\n            this._singleValue = fn(this._singleValue);\n            break;\n          }\n          const newValue = fn(undefined);\n          if (newValue !== undefined) {\n            this._mode = 2;\n            this._map = new Map();\n            this._map.set(getRuntimeKey(this._singleRuntime), /** @type {T} */this._singleValue);\n            this._singleRuntime = undefined;\n            this._singleValue = undefined;\n            this._map.set(getRuntimeKey(runtime), newValue);\n          }\n          break;\n        }\n      default:\n        {\n          const key = getRuntimeKey(runtime);\n          const oldValue = /** @type {Map<string, T>} */this._map.get(key);\n          const newValue = fn(oldValue);\n          if (newValue !== oldValue) /** @type {RuntimeSpecMapInnerMap<T>} */\n            this._map.set(key, newValue);\n        }\n    }\n  }\n  keys() {\n    switch (this._mode) {\n      case 0:\n        return [];\n      case 1:\n        return [this._singleRuntime];\n      default:\n        return Array.from( /** @type {RuntimeSpecMapInnerMap<T>} */\n        this._map.keys(), keyToRuntime);\n    }\n  }\n  values() {\n    switch (this._mode) {\n      case 0:\n        return [][Symbol.iterator]();\n      case 1:\n        return [( /** @type {T} */this._singleValue)][Symbol.iterator]();\n      default:\n        return /** @type {Map<string, T>} */this._map.values();\n    }\n  }\n  get size() {\n    if ( /** @type {number} */this._mode <= 1) return this._mode;\n    return /** @type {Map<string, T>} */this._map.size;\n  }\n}\nexports.RuntimeSpecMap = RuntimeSpecMap;\nclass RuntimeSpecSet {\n  /**\n   * @param {Iterable<RuntimeSpec>=} iterable iterable\n   */\n  constructor(iterable) {\n    /** @type {Map<string, RuntimeSpec>} */\n    this._map = new Map();\n    if (iterable) {\n      for (const item of iterable) {\n        this.add(item);\n      }\n    }\n  }\n\n  /**\n   * @param {RuntimeSpec} runtime runtime\n   */\n  add(runtime) {\n    this._map.set(getRuntimeKey(runtime), runtime);\n  }\n\n  /**\n   * @param {RuntimeSpec} runtime runtime\n   * @returns {boolean} true, when the runtime exists\n   */\n  has(runtime) {\n    return this._map.has(getRuntimeKey(runtime));\n  }\n  [Symbol.iterator]() {\n    return this._map.values();\n  }\n  get size() {\n    return this._map.size;\n  }\n}\nexports.RuntimeSpecSet = RuntimeSpecSet;","map":{"version":3,"names":["SortableSet","require","exports","getEntryRuntime","compilation","name","options","dependOn","runtime","entry","entries","get","result","undefined","queue","Set","dep","add","mergeRuntimeOwned","forEachRuntime","fn","deterministicOrder","sort","r","getRuntimesKey","set","Array","from","join","getRuntimeKey","getFromUnorderedCache","keyToRuntime","key","items","split","length","getRuntimesString","runtimeToString","runtimeConditionToString","runtimeCondition","runtimeEqual","a","b","size","aIt","Symbol","iterator","bIt","aV","next","done","bV","value","compareRuntime","aKey","bKey","mergeRuntime","has","item","deepMergeRuntime","runtimes","isArray","merged","mergeRuntimeCondition","mergeRuntimeConditionNonFalse","intersectRuntime","subtractRuntime","delete","subtractRuntimeCondition","filterRuntime","filter","some","every","v","RuntimeSpecMap","constructor","clone","_mode","_singleRuntime","_singleValue","_map","Map","provide","computer","newValue","update","Error","oldValue","keys","values","RuntimeSpecSet","iterable"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/util/runtime.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst SortableSet = require(\"./SortableSet\");\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Entrypoint\").EntryOptions} EntryOptions */\n\n/** @typedef {string | SortableSet<string> | undefined} RuntimeSpec */\n/** @typedef {RuntimeSpec | boolean} RuntimeCondition */\n\n/**\n * @param {Compilation} compilation the compilation\n * @param {string} name name of the entry\n * @param {EntryOptions=} options optionally already received entry options\n * @returns {RuntimeSpec} runtime\n */\nexports.getEntryRuntime = (compilation, name, options) => {\n\tlet dependOn;\n\tlet runtime;\n\tif (options) {\n\t\t({ dependOn, runtime } = options);\n\t} else {\n\t\tconst entry = compilation.entries.get(name);\n\t\tif (!entry) return name;\n\t\t({ dependOn, runtime } = entry.options);\n\t}\n\tif (dependOn) {\n\t\t/** @type {RuntimeSpec} */\n\t\tlet result = undefined;\n\t\tconst queue = new Set(dependOn);\n\t\tfor (const name of queue) {\n\t\t\tconst dep = compilation.entries.get(name);\n\t\t\tif (!dep) continue;\n\t\t\tconst { dependOn, runtime } = dep.options;\n\t\t\tif (dependOn) {\n\t\t\t\tfor (const name of dependOn) {\n\t\t\t\t\tqueue.add(name);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult = mergeRuntimeOwned(result, runtime || name);\n\t\t\t}\n\t\t}\n\t\treturn result || name;\n\t} else {\n\t\treturn runtime || name;\n\t}\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime\n * @param {function(string | undefined): void} fn functor\n * @param {boolean} deterministicOrder enforce a deterministic order\n * @returns {void}\n */\nconst forEachRuntime = (runtime, fn, deterministicOrder = false) => {\n\tif (runtime === undefined) {\n\t\tfn(undefined);\n\t} else if (typeof runtime === \"string\") {\n\t\tfn(runtime);\n\t} else {\n\t\tif (deterministicOrder) runtime.sort();\n\t\tfor (const r of runtime) {\n\t\t\tfn(r);\n\t\t}\n\t}\n};\nexports.forEachRuntime = forEachRuntime;\n\n/**\n * @template T\n * @param {SortableSet<T>} set set\n * @returns {string} runtime key\n */\nconst getRuntimesKey = set => {\n\tset.sort();\n\treturn Array.from(set).join(\"\\n\");\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime(s)\n * @returns {string} key of runtimes\n */\nconst getRuntimeKey = runtime => {\n\tif (runtime === undefined) return \"*\";\n\tif (typeof runtime === \"string\") return runtime;\n\treturn runtime.getFromUnorderedCache(getRuntimesKey);\n};\nexports.getRuntimeKey = getRuntimeKey;\n\n/**\n * @param {string} key key of runtimes\n * @returns {RuntimeSpec} runtime(s)\n */\nconst keyToRuntime = key => {\n\tif (key === \"*\") return undefined;\n\tconst items = key.split(\"\\n\");\n\tif (items.length === 1) return items[0];\n\treturn new SortableSet(items);\n};\nexports.keyToRuntime = keyToRuntime;\n\n/**\n * @template T\n * @param {SortableSet<T>} set set\n * @returns {string} runtime string\n */\nconst getRuntimesString = set => {\n\tset.sort();\n\treturn Array.from(set).join(\"+\");\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime(s)\n * @returns {string} readable version\n */\nconst runtimeToString = runtime => {\n\tif (runtime === undefined) return \"*\";\n\tif (typeof runtime === \"string\") return runtime;\n\treturn runtime.getFromUnorderedCache(getRuntimesString);\n};\nexports.runtimeToString = runtimeToString;\n\n/**\n * @param {RuntimeCondition} runtimeCondition runtime condition\n * @returns {string} readable version\n */\nexports.runtimeConditionToString = runtimeCondition => {\n\tif (runtimeCondition === true) return \"true\";\n\tif (runtimeCondition === false) return \"false\";\n\treturn runtimeToString(runtimeCondition);\n};\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {boolean} true, when they are equal\n */\nconst runtimeEqual = (a, b) => {\n\tif (a === b) {\n\t\treturn true;\n\t} else if (\n\t\ta === undefined ||\n\t\tb === undefined ||\n\t\ttypeof a === \"string\" ||\n\t\ttypeof b === \"string\"\n\t) {\n\t\treturn false;\n\t} else if (a.size !== b.size) {\n\t\treturn false;\n\t} else {\n\t\ta.sort();\n\t\tb.sort();\n\t\tconst aIt = a[Symbol.iterator]();\n\t\tconst bIt = b[Symbol.iterator]();\n\t\tfor (;;) {\n\t\t\tconst aV = aIt.next();\n\t\t\tif (aV.done) return true;\n\t\t\tconst bV = bIt.next();\n\t\t\tif (aV.value !== bV.value) return false;\n\t\t}\n\t}\n};\nexports.runtimeEqual = runtimeEqual;\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {-1|0|1} compare\n */\nexports.compareRuntime = (a, b) => {\n\tif (a === b) {\n\t\treturn 0;\n\t} else if (a === undefined) {\n\t\treturn -1;\n\t} else if (b === undefined) {\n\t\treturn 1;\n\t} else {\n\t\tconst aKey = getRuntimeKey(a);\n\t\tconst bKey = getRuntimeKey(b);\n\t\tif (aKey < bKey) return -1;\n\t\tif (aKey > bKey) return 1;\n\t\treturn 0;\n\t}\n};\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\nconst mergeRuntime = (a, b) => {\n\tif (a === undefined) {\n\t\treturn b;\n\t} else if (b === undefined) {\n\t\treturn a;\n\t} else if (a === b) {\n\t\treturn a;\n\t} else if (typeof a === \"string\") {\n\t\tif (typeof b === \"string\") {\n\t\t\tconst set = new SortableSet();\n\t\t\tset.add(a);\n\t\t\tset.add(b);\n\t\t\treturn set;\n\t\t} else if (b.has(a)) {\n\t\t\treturn b;\n\t\t} else {\n\t\t\tconst set = new SortableSet(b);\n\t\t\tset.add(a);\n\t\t\treturn set;\n\t\t}\n\t} else {\n\t\tif (typeof b === \"string\") {\n\t\t\tif (a.has(b)) return a;\n\t\t\tconst set = new SortableSet(a);\n\t\t\tset.add(b);\n\t\t\treturn set;\n\t\t} else {\n\t\t\tconst set = new SortableSet(a);\n\t\t\tfor (const item of b) set.add(item);\n\t\t\tif (set.size === a.size) return a;\n\t\t\treturn set;\n\t\t}\n\t}\n};\nexports.mergeRuntime = mergeRuntime;\n\n/**\n * @param {RuntimeSpec[] | undefined} runtimes first\n * @param {RuntimeSpec} runtime second\n * @returns {RuntimeSpec} merged\n */\nexports.deepMergeRuntime = (runtimes, runtime) => {\n\tif (!Array.isArray(runtimes)) {\n\t\treturn runtime;\n\t}\n\tlet merged = runtime;\n\tfor (const r of runtimes) {\n\t\tmerged = mergeRuntime(runtime, r);\n\t}\n\treturn merged;\n};\n\n/**\n * @param {RuntimeCondition} a first\n * @param {RuntimeCondition} b second\n * @param {RuntimeSpec} runtime full runtime\n * @returns {RuntimeCondition} result\n */\nexports.mergeRuntimeCondition = (a, b, runtime) => {\n\tif (a === false) return b;\n\tif (b === false) return a;\n\tif (a === true || b === true) return true;\n\tconst merged = mergeRuntime(a, b);\n\tif (merged === undefined) return undefined;\n\tif (typeof merged === \"string\") {\n\t\tif (typeof runtime === \"string\" && merged === runtime) return true;\n\t\treturn merged;\n\t}\n\tif (typeof runtime === \"string\" || runtime === undefined) return merged;\n\tif (merged.size === runtime.size) return true;\n\treturn merged;\n};\n\n/**\n * @param {RuntimeSpec | true} a first\n * @param {RuntimeSpec | true} b second\n * @param {RuntimeSpec} runtime full runtime\n * @returns {RuntimeSpec | true} result\n */\nexports.mergeRuntimeConditionNonFalse = (a, b, runtime) => {\n\tif (a === true || b === true) return true;\n\tconst merged = mergeRuntime(a, b);\n\tif (merged === undefined) return undefined;\n\tif (typeof merged === \"string\") {\n\t\tif (typeof runtime === \"string\" && merged === runtime) return true;\n\t\treturn merged;\n\t}\n\tif (typeof runtime === \"string\" || runtime === undefined) return merged;\n\tif (merged.size === runtime.size) return true;\n\treturn merged;\n};\n\n/**\n * @param {RuntimeSpec} a first (may be modified)\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\nconst mergeRuntimeOwned = (a, b) => {\n\tif (b === undefined) {\n\t\treturn a;\n\t} else if (a === b) {\n\t\treturn a;\n\t} else if (a === undefined) {\n\t\tif (typeof b === \"string\") {\n\t\t\treturn b;\n\t\t} else {\n\t\t\treturn new SortableSet(b);\n\t\t}\n\t} else if (typeof a === \"string\") {\n\t\tif (typeof b === \"string\") {\n\t\t\tconst set = new SortableSet();\n\t\t\tset.add(a);\n\t\t\tset.add(b);\n\t\t\treturn set;\n\t\t} else {\n\t\t\tconst set = new SortableSet(b);\n\t\t\tset.add(a);\n\t\t\treturn set;\n\t\t}\n\t} else {\n\t\tif (typeof b === \"string\") {\n\t\t\ta.add(b);\n\t\t\treturn a;\n\t\t} else {\n\t\t\tfor (const item of b) a.add(item);\n\t\t\treturn a;\n\t\t}\n\t}\n};\nexports.mergeRuntimeOwned = mergeRuntimeOwned;\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\nexports.intersectRuntime = (a, b) => {\n\tif (a === undefined) {\n\t\treturn b;\n\t} else if (b === undefined) {\n\t\treturn a;\n\t} else if (a === b) {\n\t\treturn a;\n\t} else if (typeof a === \"string\") {\n\t\tif (typeof b === \"string\") {\n\t\t\treturn undefined;\n\t\t} else if (b.has(a)) {\n\t\t\treturn a;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t} else {\n\t\tif (typeof b === \"string\") {\n\t\t\tif (a.has(b)) return b;\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst set = new SortableSet();\n\t\t\tfor (const item of b) {\n\t\t\t\tif (a.has(item)) set.add(item);\n\t\t\t}\n\t\t\tif (set.size === 0) return undefined;\n\t\t\tif (set.size === 1) for (const item of set) return item;\n\t\t\treturn set;\n\t\t}\n\t}\n};\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} result\n */\nconst subtractRuntime = (a, b) => {\n\tif (a === undefined) {\n\t\treturn undefined;\n\t} else if (b === undefined) {\n\t\treturn a;\n\t} else if (a === b) {\n\t\treturn undefined;\n\t} else if (typeof a === \"string\") {\n\t\tif (typeof b === \"string\") {\n\t\t\treturn a;\n\t\t} else if (b.has(a)) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\treturn a;\n\t\t}\n\t} else {\n\t\tif (typeof b === \"string\") {\n\t\t\tif (!a.has(b)) return a;\n\t\t\tif (a.size === 2) {\n\t\t\t\tfor (const item of a) {\n\t\t\t\t\tif (item !== b) return item;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst set = new SortableSet(a);\n\t\t\tset.delete(b);\n\t\t} else {\n\t\t\tconst set = new SortableSet();\n\t\t\tfor (const item of a) {\n\t\t\t\tif (!b.has(item)) set.add(item);\n\t\t\t}\n\t\t\tif (set.size === 0) return undefined;\n\t\t\tif (set.size === 1) for (const item of set) return item;\n\t\t\treturn set;\n\t\t}\n\t}\n};\nexports.subtractRuntime = subtractRuntime;\n\n/**\n * @param {RuntimeCondition} a first\n * @param {RuntimeCondition} b second\n * @param {RuntimeSpec} runtime runtime\n * @returns {RuntimeCondition} result\n */\nexports.subtractRuntimeCondition = (a, b, runtime) => {\n\tif (b === true) return false;\n\tif (b === false) return a;\n\tif (a === false) return false;\n\tconst result = subtractRuntime(a === true ? runtime : a, b);\n\treturn result === undefined ? false : result;\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime\n * @param {function(RuntimeSpec): boolean} filter filter function\n * @returns {boolean | RuntimeSpec} true/false if filter is constant for all runtimes, otherwise runtimes that are active\n */\nexports.filterRuntime = (runtime, filter) => {\n\tif (runtime === undefined) return filter(undefined);\n\tif (typeof runtime === \"string\") return filter(runtime);\n\tlet some = false;\n\tlet every = true;\n\tlet result = undefined;\n\tfor (const r of runtime) {\n\t\tconst v = filter(r);\n\t\tif (v) {\n\t\t\tsome = true;\n\t\t\tresult = mergeRuntimeOwned(result, r);\n\t\t} else {\n\t\t\tevery = false;\n\t\t}\n\t}\n\tif (!some) return false;\n\tif (every) return true;\n\treturn result;\n};\n\n/**\n * @template T\n * @typedef {Map<string, T>} RuntimeSpecMapInnerMap\n * */\n\n/**\n * @template T\n */\nclass RuntimeSpecMap {\n\t/**\n\t * @param {RuntimeSpecMap<T>=} clone copy form this\n\t */\n\tconstructor(clone) {\n\t\tthis._mode = clone ? clone._mode : 0; // 0 = empty, 1 = single entry, 2 = map\n\t\t/** @type {RuntimeSpec} */\n\t\tthis._singleRuntime = clone ? clone._singleRuntime : undefined;\n\t\t/** @type {T | undefined} */\n\t\tthis._singleValue = clone ? clone._singleValue : undefined;\n\t\t/** @type {RuntimeSpecMapInnerMap<T> | undefined} */\n\t\tthis._map = clone && clone._map ? new Map(clone._map) : undefined;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtimes\n\t * @returns {T | undefined} value\n\t */\n\tget(runtime) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\treturn undefined;\n\t\t\tcase 1:\n\t\t\t\treturn runtimeEqual(this._singleRuntime, runtime)\n\t\t\t\t\t? this._singleValue\n\t\t\t\t\t: undefined;\n\t\t\tdefault:\n\t\t\t\treturn /** @type {RuntimeSpecMapInnerMap<T>} */ (this._map).get(\n\t\t\t\t\tgetRuntimeKey(runtime)\n\t\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtimes\n\t * @returns {boolean} true, when the runtime is stored\n\t */\n\thas(runtime) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\treturn false;\n\t\t\tcase 1:\n\t\t\t\treturn runtimeEqual(this._singleRuntime, runtime);\n\t\t\tdefault:\n\t\t\t\treturn /** @type {RuntimeSpecMapInnerMap<T>} */ (this._map).has(\n\t\t\t\t\tgetRuntimeKey(runtime)\n\t\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtimes\n\t * @param {T} value the value\n\t */\n\tset(runtime, value) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\tthis._mode = 1;\n\t\t\t\tthis._singleRuntime = runtime;\n\t\t\t\tthis._singleValue = value;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (runtimeEqual(this._singleRuntime, runtime)) {\n\t\t\t\t\tthis._singleValue = value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis._mode = 2;\n\t\t\t\tthis._map = new Map();\n\t\t\t\tthis._map.set(\n\t\t\t\t\tgetRuntimeKey(this._singleRuntime),\n\t\t\t\t\t/** @type {T} */ (this._singleValue)\n\t\t\t\t);\n\t\t\t\tthis._singleRuntime = undefined;\n\t\t\t\tthis._singleValue = undefined;\n\t\t\t/* falls through */\n\t\t\tdefault:\n\t\t\t\t/** @type {RuntimeSpecMapInnerMap<T>} */\n\t\t\t\t(this._map).set(getRuntimeKey(runtime), value);\n\t\t}\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtimes\n\t * @param {() => TODO} computer function to compute the value\n\t * @returns {TODO} true, when the runtime was deleted\n\t */\n\tprovide(runtime, computer) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\tthis._mode = 1;\n\t\t\t\tthis._singleRuntime = runtime;\n\t\t\t\treturn (this._singleValue = computer());\n\t\t\tcase 1: {\n\t\t\t\tif (runtimeEqual(this._singleRuntime, runtime)) {\n\t\t\t\t\treturn /** @type {T} */ (this._singleValue);\n\t\t\t\t}\n\t\t\t\tthis._mode = 2;\n\t\t\t\tthis._map = new Map();\n\t\t\t\tthis._map.set(\n\t\t\t\t\tgetRuntimeKey(this._singleRuntime),\n\t\t\t\t\t/** @type {T} */ (this._singleValue)\n\t\t\t\t);\n\t\t\t\tthis._singleRuntime = undefined;\n\t\t\t\tthis._singleValue = undefined;\n\t\t\t\tconst newValue = computer();\n\t\t\t\tthis._map.set(getRuntimeKey(runtime), newValue);\n\t\t\t\treturn newValue;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tconst key = getRuntimeKey(runtime);\n\t\t\t\tconst value = /** @type {Map<string, T>} */ (this._map).get(key);\n\t\t\t\tif (value !== undefined) return value;\n\t\t\t\tconst newValue = computer();\n\t\t\t\t/** @type {Map<string, T>} */\n\t\t\t\t(this._map).set(key, newValue);\n\t\t\t\treturn newValue;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtimes\n\t */\n\tdelete(runtime) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\treturn;\n\t\t\tcase 1:\n\t\t\t\tif (runtimeEqual(this._singleRuntime, runtime)) {\n\t\t\t\t\tthis._mode = 0;\n\t\t\t\t\tthis._singleRuntime = undefined;\n\t\t\t\t\tthis._singleValue = undefined;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\tdefault:\n\t\t\t\t/** @type {RuntimeSpecMapInnerMap<T>} */\n\t\t\t\t(this._map).delete(getRuntimeKey(runtime));\n\t\t}\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtimes\n\t * @param {function(T | undefined): T} fn function to update the value\n\t */\n\tupdate(runtime, fn) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\tthrow new Error(\"runtime passed to update must exist\");\n\t\t\tcase 1: {\n\t\t\t\tif (runtimeEqual(this._singleRuntime, runtime)) {\n\t\t\t\t\tthis._singleValue = fn(this._singleValue);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst newValue = fn(undefined);\n\t\t\t\tif (newValue !== undefined) {\n\t\t\t\t\tthis._mode = 2;\n\t\t\t\t\tthis._map = new Map();\n\t\t\t\t\tthis._map.set(\n\t\t\t\t\t\tgetRuntimeKey(this._singleRuntime),\n\t\t\t\t\t\t/** @type {T} */ (this._singleValue)\n\t\t\t\t\t);\n\t\t\t\t\tthis._singleRuntime = undefined;\n\t\t\t\t\tthis._singleValue = undefined;\n\t\t\t\t\tthis._map.set(getRuntimeKey(runtime), newValue);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tconst key = getRuntimeKey(runtime);\n\t\t\t\tconst oldValue = /** @type {Map<string, T>} */ (this._map).get(key);\n\t\t\t\tconst newValue = fn(oldValue);\n\t\t\t\tif (newValue !== oldValue)\n\t\t\t\t\t/** @type {RuntimeSpecMapInnerMap<T>} */\n\t\t\t\t\t(this._map).set(key, newValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tkeys() {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\treturn [];\n\t\t\tcase 1:\n\t\t\t\treturn [this._singleRuntime];\n\t\t\tdefault:\n\t\t\t\treturn Array.from(\n\t\t\t\t\t/** @type {RuntimeSpecMapInnerMap<T>} */\n\t\t\t\t\t(this._map).keys(),\n\t\t\t\t\tkeyToRuntime\n\t\t\t\t);\n\t\t}\n\t}\n\n\tvalues() {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\treturn [][Symbol.iterator]();\n\t\t\tcase 1:\n\t\t\t\treturn [/** @type {T} */ (this._singleValue)][Symbol.iterator]();\n\t\t\tdefault:\n\t\t\t\treturn /** @type {Map<string, T>} */ (this._map).values();\n\t\t}\n\t}\n\n\tget size() {\n\t\tif (/** @type {number} */ (this._mode) <= 1) return this._mode;\n\t\treturn /** @type {Map<string, T>} */ (this._map).size;\n\t}\n}\n\nexports.RuntimeSpecMap = RuntimeSpecMap;\n\nclass RuntimeSpecSet {\n\t/**\n\t * @param {Iterable<RuntimeSpec>=} iterable iterable\n\t */\n\tconstructor(iterable) {\n\t\t/** @type {Map<string, RuntimeSpec>} */\n\t\tthis._map = new Map();\n\t\tif (iterable) {\n\t\t\tfor (const item of iterable) {\n\t\t\t\tthis.add(item);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime runtime\n\t */\n\tadd(runtime) {\n\t\tthis._map.set(getRuntimeKey(runtime), runtime);\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime runtime\n\t * @returns {boolean} true, when the runtime exists\n\t */\n\thas(runtime) {\n\t\treturn this._map.has(getRuntimeKey(runtime));\n\t}\n\n\t[Symbol.iterator]() {\n\t\treturn this._map.values();\n\t}\n\n\tget size() {\n\t\treturn this._map.size;\n\t}\n}\n\nexports.RuntimeSpecSet = RuntimeSpecSet;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nclass HookCodeFactory {\n  constructor(config) {\n    this.config = config;\n    this.options = undefined;\n    this._args = undefined;\n  }\n  create(options) {\n    this.init(options);\n    let fn;\n    switch (this.options.type) {\n      case \"sync\":\n        fn = new Function(this.args(), '\"use strict\";\\n' + this.header() + this.contentWithInterceptors({\n          onError: err => `throw ${err};\\n`,\n          onResult: result => `return ${result};\\n`,\n          resultReturns: true,\n          onDone: () => \"\",\n          rethrowIfPossible: true\n        }));\n        break;\n      case \"async\":\n        fn = new Function(this.args({\n          after: \"_callback\"\n        }), '\"use strict\";\\n' + this.header() + this.contentWithInterceptors({\n          onError: err => `_callback(${err});\\n`,\n          onResult: result => `_callback(null, ${result});\\n`,\n          onDone: () => \"_callback();\\n\"\n        }));\n        break;\n      case \"promise\":\n        let errorHelperUsed = false;\n        const content = this.contentWithInterceptors({\n          onError: err => {\n            errorHelperUsed = true;\n            return `_error(${err});\\n`;\n          },\n          onResult: result => `_resolve(${result});\\n`,\n          onDone: () => \"_resolve();\\n\"\n        });\n        let code = \"\";\n        code += '\"use strict\";\\n';\n        code += this.header();\n        code += \"return new Promise((function(_resolve, _reject) {\\n\";\n        if (errorHelperUsed) {\n          code += \"var _sync = true;\\n\";\n          code += \"function _error(_err) {\\n\";\n          code += \"if(_sync)\\n\";\n          code += \"_resolve(Promise.resolve().then((function() { throw _err; })));\\n\";\n          code += \"else\\n\";\n          code += \"_reject(_err);\\n\";\n          code += \"};\\n\";\n        }\n        code += content;\n        if (errorHelperUsed) {\n          code += \"_sync = false;\\n\";\n        }\n        code += \"}));\\n\";\n        fn = new Function(this.args(), code);\n        break;\n    }\n    this.deinit();\n    return fn;\n  }\n  setup(instance, options) {\n    instance._x = options.taps.map(t => t.fn);\n  }\n\n  /**\n   * @param {{ type: \"sync\" | \"promise\" | \"async\", taps: Array<Tap>, interceptors: Array<Interceptor> }} options\n   */\n  init(options) {\n    this.options = options;\n    this._args = options.args.slice();\n  }\n  deinit() {\n    this.options = undefined;\n    this._args = undefined;\n  }\n  contentWithInterceptors(options) {\n    if (this.options.interceptors.length > 0) {\n      const onError = options.onError;\n      const onResult = options.onResult;\n      const onDone = options.onDone;\n      let code = \"\";\n      for (let i = 0; i < this.options.interceptors.length; i++) {\n        const interceptor = this.options.interceptors[i];\n        if (interceptor.call) {\n          code += `${this.getInterceptor(i)}.call(${this.args({\n            before: interceptor.context ? \"_context\" : undefined\n          })});\\n`;\n        }\n      }\n      code += this.content(Object.assign(options, {\n        onError: onError && (err => {\n          let code = \"\";\n          for (let i = 0; i < this.options.interceptors.length; i++) {\n            const interceptor = this.options.interceptors[i];\n            if (interceptor.error) {\n              code += `${this.getInterceptor(i)}.error(${err});\\n`;\n            }\n          }\n          code += onError(err);\n          return code;\n        }),\n        onResult: onResult && (result => {\n          let code = \"\";\n          for (let i = 0; i < this.options.interceptors.length; i++) {\n            const interceptor = this.options.interceptors[i];\n            if (interceptor.result) {\n              code += `${this.getInterceptor(i)}.result(${result});\\n`;\n            }\n          }\n          code += onResult(result);\n          return code;\n        }),\n        onDone: onDone && (() => {\n          let code = \"\";\n          for (let i = 0; i < this.options.interceptors.length; i++) {\n            const interceptor = this.options.interceptors[i];\n            if (interceptor.done) {\n              code += `${this.getInterceptor(i)}.done();\\n`;\n            }\n          }\n          code += onDone();\n          return code;\n        })\n      }));\n      return code;\n    } else {\n      return this.content(options);\n    }\n  }\n  header() {\n    let code = \"\";\n    if (this.needContext()) {\n      code += \"var _context = {};\\n\";\n    } else {\n      code += \"var _context;\\n\";\n    }\n    code += \"var _x = this._x;\\n\";\n    if (this.options.interceptors.length > 0) {\n      code += \"var _taps = this.taps;\\n\";\n      code += \"var _interceptors = this.interceptors;\\n\";\n    }\n    return code;\n  }\n  needContext() {\n    for (const tap of this.options.taps) if (tap.context) return true;\n    return false;\n  }\n  callTap(tapIndex, {\n    onError,\n    onResult,\n    onDone,\n    rethrowIfPossible\n  }) {\n    let code = \"\";\n    let hasTapCached = false;\n    for (let i = 0; i < this.options.interceptors.length; i++) {\n      const interceptor = this.options.interceptors[i];\n      if (interceptor.tap) {\n        if (!hasTapCached) {\n          code += `var _tap${tapIndex} = ${this.getTap(tapIndex)};\\n`;\n          hasTapCached = true;\n        }\n        code += `${this.getInterceptor(i)}.tap(${interceptor.context ? \"_context, \" : \"\"}_tap${tapIndex});\\n`;\n      }\n    }\n    code += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};\\n`;\n    const tap = this.options.taps[tapIndex];\n    switch (tap.type) {\n      case \"sync\":\n        if (!rethrowIfPossible) {\n          code += `var _hasError${tapIndex} = false;\\n`;\n          code += \"try {\\n\";\n        }\n        if (onResult) {\n          code += `var _result${tapIndex} = _fn${tapIndex}(${this.args({\n            before: tap.context ? \"_context\" : undefined\n          })});\\n`;\n        } else {\n          code += `_fn${tapIndex}(${this.args({\n            before: tap.context ? \"_context\" : undefined\n          })});\\n`;\n        }\n        if (!rethrowIfPossible) {\n          code += \"} catch(_err) {\\n\";\n          code += `_hasError${tapIndex} = true;\\n`;\n          code += onError(\"_err\");\n          code += \"}\\n\";\n          code += `if(!_hasError${tapIndex}) {\\n`;\n        }\n        if (onResult) {\n          code += onResult(`_result${tapIndex}`);\n        }\n        if (onDone) {\n          code += onDone();\n        }\n        if (!rethrowIfPossible) {\n          code += \"}\\n\";\n        }\n        break;\n      case \"async\":\n        let cbCode = \"\";\n        if (onResult) cbCode += `(function(_err${tapIndex}, _result${tapIndex}) {\\n`;else cbCode += `(function(_err${tapIndex}) {\\n`;\n        cbCode += `if(_err${tapIndex}) {\\n`;\n        cbCode += onError(`_err${tapIndex}`);\n        cbCode += \"} else {\\n\";\n        if (onResult) {\n          cbCode += onResult(`_result${tapIndex}`);\n        }\n        if (onDone) {\n          cbCode += onDone();\n        }\n        cbCode += \"}\\n\";\n        cbCode += \"})\";\n        code += `_fn${tapIndex}(${this.args({\n          before: tap.context ? \"_context\" : undefined,\n          after: cbCode\n        })});\\n`;\n        break;\n      case \"promise\":\n        code += `var _hasResult${tapIndex} = false;\\n`;\n        code += `var _promise${tapIndex} = _fn${tapIndex}(${this.args({\n          before: tap.context ? \"_context\" : undefined\n        })});\\n`;\n        code += `if (!_promise${tapIndex} || !_promise${tapIndex}.then)\\n`;\n        code += `  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${tapIndex} + ')');\\n`;\n        code += `_promise${tapIndex}.then((function(_result${tapIndex}) {\\n`;\n        code += `_hasResult${tapIndex} = true;\\n`;\n        if (onResult) {\n          code += onResult(`_result${tapIndex}`);\n        }\n        if (onDone) {\n          code += onDone();\n        }\n        code += `}), function(_err${tapIndex}) {\\n`;\n        code += `if(_hasResult${tapIndex}) throw _err${tapIndex};\\n`;\n        code += onError(`_err${tapIndex}`);\n        code += \"});\\n\";\n        break;\n    }\n    return code;\n  }\n  callTapsSeries({\n    onError,\n    onResult,\n    resultReturns,\n    onDone,\n    doneReturns,\n    rethrowIfPossible\n  }) {\n    if (this.options.taps.length === 0) return onDone();\n    const firstAsync = this.options.taps.findIndex(t => t.type !== \"sync\");\n    const somethingReturns = resultReturns || doneReturns;\n    let code = \"\";\n    let current = onDone;\n    let unrollCounter = 0;\n    for (let j = this.options.taps.length - 1; j >= 0; j--) {\n      const i = j;\n      const unroll = current !== onDone && (this.options.taps[i].type !== \"sync\" || unrollCounter++ > 20);\n      if (unroll) {\n        unrollCounter = 0;\n        code += `function _next${i}() {\\n`;\n        code += current();\n        code += `}\\n`;\n        current = () => `${somethingReturns ? \"return \" : \"\"}_next${i}();\\n`;\n      }\n      const done = current;\n      const doneBreak = skipDone => {\n        if (skipDone) return \"\";\n        return onDone();\n      };\n      const content = this.callTap(i, {\n        onError: error => onError(i, error, done, doneBreak),\n        onResult: onResult && (result => {\n          return onResult(i, result, done, doneBreak);\n        }),\n        onDone: !onResult && done,\n        rethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)\n      });\n      current = () => content;\n    }\n    code += current();\n    return code;\n  }\n  callTapsLooping({\n    onError,\n    onDone,\n    rethrowIfPossible\n  }) {\n    if (this.options.taps.length === 0) return onDone();\n    const syncOnly = this.options.taps.every(t => t.type === \"sync\");\n    let code = \"\";\n    if (!syncOnly) {\n      code += \"var _looper = (function() {\\n\";\n      code += \"var _loopAsync = false;\\n\";\n    }\n    code += \"var _loop;\\n\";\n    code += \"do {\\n\";\n    code += \"_loop = false;\\n\";\n    for (let i = 0; i < this.options.interceptors.length; i++) {\n      const interceptor = this.options.interceptors[i];\n      if (interceptor.loop) {\n        code += `${this.getInterceptor(i)}.loop(${this.args({\n          before: interceptor.context ? \"_context\" : undefined\n        })});\\n`;\n      }\n    }\n    code += this.callTapsSeries({\n      onError,\n      onResult: (i, result, next, doneBreak) => {\n        let code = \"\";\n        code += `if(${result} !== undefined) {\\n`;\n        code += \"_loop = true;\\n\";\n        if (!syncOnly) code += \"if(_loopAsync) _looper();\\n\";\n        code += doneBreak(true);\n        code += `} else {\\n`;\n        code += next();\n        code += `}\\n`;\n        return code;\n      },\n      onDone: onDone && (() => {\n        let code = \"\";\n        code += \"if(!_loop) {\\n\";\n        code += onDone();\n        code += \"}\\n\";\n        return code;\n      }),\n      rethrowIfPossible: rethrowIfPossible && syncOnly\n    });\n    code += \"} while(_loop);\\n\";\n    if (!syncOnly) {\n      code += \"_loopAsync = true;\\n\";\n      code += \"});\\n\";\n      code += \"_looper();\\n\";\n    }\n    return code;\n  }\n  callTapsParallel({\n    onError,\n    onResult,\n    onDone,\n    rethrowIfPossible,\n    onTap = (i, run) => run()\n  }) {\n    if (this.options.taps.length <= 1) {\n      return this.callTapsSeries({\n        onError,\n        onResult,\n        onDone,\n        rethrowIfPossible\n      });\n    }\n    let code = \"\";\n    code += \"do {\\n\";\n    code += `var _counter = ${this.options.taps.length};\\n`;\n    if (onDone) {\n      code += \"var _done = (function() {\\n\";\n      code += onDone();\n      code += \"});\\n\";\n    }\n    for (let i = 0; i < this.options.taps.length; i++) {\n      const done = () => {\n        if (onDone) return \"if(--_counter === 0) _done();\\n\";else return \"--_counter;\";\n      };\n      const doneBreak = skipDone => {\n        if (skipDone || !onDone) return \"_counter = 0;\\n\";else return \"_counter = 0;\\n_done();\\n\";\n      };\n      code += \"if(_counter <= 0) break;\\n\";\n      code += onTap(i, () => this.callTap(i, {\n        onError: error => {\n          let code = \"\";\n          code += \"if(_counter > 0) {\\n\";\n          code += onError(i, error, done, doneBreak);\n          code += \"}\\n\";\n          return code;\n        },\n        onResult: onResult && (result => {\n          let code = \"\";\n          code += \"if(_counter > 0) {\\n\";\n          code += onResult(i, result, done, doneBreak);\n          code += \"}\\n\";\n          return code;\n        }),\n        onDone: !onResult && (() => {\n          return done();\n        }),\n        rethrowIfPossible\n      }), done, doneBreak);\n    }\n    code += \"} while(false);\\n\";\n    return code;\n  }\n  args({\n    before,\n    after\n  } = {}) {\n    let allArgs = this._args;\n    if (before) allArgs = [before].concat(allArgs);\n    if (after) allArgs = allArgs.concat(after);\n    if (allArgs.length === 0) {\n      return \"\";\n    } else {\n      return allArgs.join(\", \");\n    }\n  }\n  getTapFn(idx) {\n    return `_x[${idx}]`;\n  }\n  getTap(idx) {\n    return `_taps[${idx}]`;\n  }\n  getInterceptor(idx) {\n    return `_interceptors[${idx}]`;\n  }\n}\nmodule.exports = HookCodeFactory;","map":{"version":3,"names":["HookCodeFactory","constructor","config","options","undefined","_args","create","init","fn","type","Function","args","header","contentWithInterceptors","onError","err","onResult","result","resultReturns","onDone","rethrowIfPossible","after","errorHelperUsed","content","code","deinit","setup","instance","_x","taps","map","t","slice","interceptors","length","i","interceptor","call","getInterceptor","before","context","Object","assign","error","done","needContext","tap","callTap","tapIndex","hasTapCached","getTap","getTapFn","cbCode","callTapsSeries","doneReturns","firstAsync","findIndex","somethingReturns","current","unrollCounter","j","unroll","doneBreak","skipDone","callTapsLooping","syncOnly","every","loop","next","callTapsParallel","onTap","run","allArgs","concat","join","idx","module","exports"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/tapable/lib/HookCodeFactory.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nclass HookCodeFactory {\n\tconstructor(config) {\n\t\tthis.config = config;\n\t\tthis.options = undefined;\n\t\tthis._args = undefined;\n\t}\n\n\tcreate(options) {\n\t\tthis.init(options);\n\t\tlet fn;\n\t\tswitch (this.options.type) {\n\t\t\tcase \"sync\":\n\t\t\t\tfn = new Function(\n\t\t\t\t\tthis.args(),\n\t\t\t\t\t'\"use strict\";\\n' +\n\t\t\t\t\t\tthis.header() +\n\t\t\t\t\t\tthis.contentWithInterceptors({\n\t\t\t\t\t\t\tonError: err => `throw ${err};\\n`,\n\t\t\t\t\t\t\tonResult: result => `return ${result};\\n`,\n\t\t\t\t\t\t\tresultReturns: true,\n\t\t\t\t\t\t\tonDone: () => \"\",\n\t\t\t\t\t\t\trethrowIfPossible: true\n\t\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"async\":\n\t\t\t\tfn = new Function(\n\t\t\t\t\tthis.args({\n\t\t\t\t\t\tafter: \"_callback\"\n\t\t\t\t\t}),\n\t\t\t\t\t'\"use strict\";\\n' +\n\t\t\t\t\t\tthis.header() +\n\t\t\t\t\t\tthis.contentWithInterceptors({\n\t\t\t\t\t\t\tonError: err => `_callback(${err});\\n`,\n\t\t\t\t\t\t\tonResult: result => `_callback(null, ${result});\\n`,\n\t\t\t\t\t\t\tonDone: () => \"_callback();\\n\"\n\t\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"promise\":\n\t\t\t\tlet errorHelperUsed = false;\n\t\t\t\tconst content = this.contentWithInterceptors({\n\t\t\t\t\tonError: err => {\n\t\t\t\t\t\terrorHelperUsed = true;\n\t\t\t\t\t\treturn `_error(${err});\\n`;\n\t\t\t\t\t},\n\t\t\t\t\tonResult: result => `_resolve(${result});\\n`,\n\t\t\t\t\tonDone: () => \"_resolve();\\n\"\n\t\t\t\t});\n\t\t\t\tlet code = \"\";\n\t\t\t\tcode += '\"use strict\";\\n';\n\t\t\t\tcode += this.header();\n\t\t\t\tcode += \"return new Promise((function(_resolve, _reject) {\\n\";\n\t\t\t\tif (errorHelperUsed) {\n\t\t\t\t\tcode += \"var _sync = true;\\n\";\n\t\t\t\t\tcode += \"function _error(_err) {\\n\";\n\t\t\t\t\tcode += \"if(_sync)\\n\";\n\t\t\t\t\tcode +=\n\t\t\t\t\t\t\"_resolve(Promise.resolve().then((function() { throw _err; })));\\n\";\n\t\t\t\t\tcode += \"else\\n\";\n\t\t\t\t\tcode += \"_reject(_err);\\n\";\n\t\t\t\t\tcode += \"};\\n\";\n\t\t\t\t}\n\t\t\t\tcode += content;\n\t\t\t\tif (errorHelperUsed) {\n\t\t\t\t\tcode += \"_sync = false;\\n\";\n\t\t\t\t}\n\t\t\t\tcode += \"}));\\n\";\n\t\t\t\tfn = new Function(this.args(), code);\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.deinit();\n\t\treturn fn;\n\t}\n\n\tsetup(instance, options) {\n\t\tinstance._x = options.taps.map(t => t.fn);\n\t}\n\n\t/**\n\t * @param {{ type: \"sync\" | \"promise\" | \"async\", taps: Array<Tap>, interceptors: Array<Interceptor> }} options\n\t */\n\tinit(options) {\n\t\tthis.options = options;\n\t\tthis._args = options.args.slice();\n\t}\n\n\tdeinit() {\n\t\tthis.options = undefined;\n\t\tthis._args = undefined;\n\t}\n\n\tcontentWithInterceptors(options) {\n\t\tif (this.options.interceptors.length > 0) {\n\t\t\tconst onError = options.onError;\n\t\t\tconst onResult = options.onResult;\n\t\t\tconst onDone = options.onDone;\n\t\t\tlet code = \"\";\n\t\t\tfor (let i = 0; i < this.options.interceptors.length; i++) {\n\t\t\t\tconst interceptor = this.options.interceptors[i];\n\t\t\t\tif (interceptor.call) {\n\t\t\t\t\tcode += `${this.getInterceptor(i)}.call(${this.args({\n\t\t\t\t\t\tbefore: interceptor.context ? \"_context\" : undefined\n\t\t\t\t\t})});\\n`;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcode += this.content(\n\t\t\t\tObject.assign(options, {\n\t\t\t\t\tonError:\n\t\t\t\t\t\tonError &&\n\t\t\t\t\t\t(err => {\n\t\t\t\t\t\t\tlet code = \"\";\n\t\t\t\t\t\t\tfor (let i = 0; i < this.options.interceptors.length; i++) {\n\t\t\t\t\t\t\t\tconst interceptor = this.options.interceptors[i];\n\t\t\t\t\t\t\t\tif (interceptor.error) {\n\t\t\t\t\t\t\t\t\tcode += `${this.getInterceptor(i)}.error(${err});\\n`;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcode += onError(err);\n\t\t\t\t\t\t\treturn code;\n\t\t\t\t\t\t}),\n\t\t\t\t\tonResult:\n\t\t\t\t\t\tonResult &&\n\t\t\t\t\t\t(result => {\n\t\t\t\t\t\t\tlet code = \"\";\n\t\t\t\t\t\t\tfor (let i = 0; i < this.options.interceptors.length; i++) {\n\t\t\t\t\t\t\t\tconst interceptor = this.options.interceptors[i];\n\t\t\t\t\t\t\t\tif (interceptor.result) {\n\t\t\t\t\t\t\t\t\tcode += `${this.getInterceptor(i)}.result(${result});\\n`;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcode += onResult(result);\n\t\t\t\t\t\t\treturn code;\n\t\t\t\t\t\t}),\n\t\t\t\t\tonDone:\n\t\t\t\t\t\tonDone &&\n\t\t\t\t\t\t(() => {\n\t\t\t\t\t\t\tlet code = \"\";\n\t\t\t\t\t\t\tfor (let i = 0; i < this.options.interceptors.length; i++) {\n\t\t\t\t\t\t\t\tconst interceptor = this.options.interceptors[i];\n\t\t\t\t\t\t\t\tif (interceptor.done) {\n\t\t\t\t\t\t\t\t\tcode += `${this.getInterceptor(i)}.done();\\n`;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcode += onDone();\n\t\t\t\t\t\t\treturn code;\n\t\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t);\n\t\t\treturn code;\n\t\t} else {\n\t\t\treturn this.content(options);\n\t\t}\n\t}\n\n\theader() {\n\t\tlet code = \"\";\n\t\tif (this.needContext()) {\n\t\t\tcode += \"var _context = {};\\n\";\n\t\t} else {\n\t\t\tcode += \"var _context;\\n\";\n\t\t}\n\t\tcode += \"var _x = this._x;\\n\";\n\t\tif (this.options.interceptors.length > 0) {\n\t\t\tcode += \"var _taps = this.taps;\\n\";\n\t\t\tcode += \"var _interceptors = this.interceptors;\\n\";\n\t\t}\n\t\treturn code;\n\t}\n\n\tneedContext() {\n\t\tfor (const tap of this.options.taps) if (tap.context) return true;\n\t\treturn false;\n\t}\n\n\tcallTap(tapIndex, { onError, onResult, onDone, rethrowIfPossible }) {\n\t\tlet code = \"\";\n\t\tlet hasTapCached = false;\n\t\tfor (let i = 0; i < this.options.interceptors.length; i++) {\n\t\t\tconst interceptor = this.options.interceptors[i];\n\t\t\tif (interceptor.tap) {\n\t\t\t\tif (!hasTapCached) {\n\t\t\t\t\tcode += `var _tap${tapIndex} = ${this.getTap(tapIndex)};\\n`;\n\t\t\t\t\thasTapCached = true;\n\t\t\t\t}\n\t\t\t\tcode += `${this.getInterceptor(i)}.tap(${\n\t\t\t\t\tinterceptor.context ? \"_context, \" : \"\"\n\t\t\t\t}_tap${tapIndex});\\n`;\n\t\t\t}\n\t\t}\n\t\tcode += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};\\n`;\n\t\tconst tap = this.options.taps[tapIndex];\n\t\tswitch (tap.type) {\n\t\t\tcase \"sync\":\n\t\t\t\tif (!rethrowIfPossible) {\n\t\t\t\t\tcode += `var _hasError${tapIndex} = false;\\n`;\n\t\t\t\t\tcode += \"try {\\n\";\n\t\t\t\t}\n\t\t\t\tif (onResult) {\n\t\t\t\t\tcode += `var _result${tapIndex} = _fn${tapIndex}(${this.args({\n\t\t\t\t\t\tbefore: tap.context ? \"_context\" : undefined\n\t\t\t\t\t})});\\n`;\n\t\t\t\t} else {\n\t\t\t\t\tcode += `_fn${tapIndex}(${this.args({\n\t\t\t\t\t\tbefore: tap.context ? \"_context\" : undefined\n\t\t\t\t\t})});\\n`;\n\t\t\t\t}\n\t\t\t\tif (!rethrowIfPossible) {\n\t\t\t\t\tcode += \"} catch(_err) {\\n\";\n\t\t\t\t\tcode += `_hasError${tapIndex} = true;\\n`;\n\t\t\t\t\tcode += onError(\"_err\");\n\t\t\t\t\tcode += \"}\\n\";\n\t\t\t\t\tcode += `if(!_hasError${tapIndex}) {\\n`;\n\t\t\t\t}\n\t\t\t\tif (onResult) {\n\t\t\t\t\tcode += onResult(`_result${tapIndex}`);\n\t\t\t\t}\n\t\t\t\tif (onDone) {\n\t\t\t\t\tcode += onDone();\n\t\t\t\t}\n\t\t\t\tif (!rethrowIfPossible) {\n\t\t\t\t\tcode += \"}\\n\";\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"async\":\n\t\t\t\tlet cbCode = \"\";\n\t\t\t\tif (onResult)\n\t\t\t\t\tcbCode += `(function(_err${tapIndex}, _result${tapIndex}) {\\n`;\n\t\t\t\telse cbCode += `(function(_err${tapIndex}) {\\n`;\n\t\t\t\tcbCode += `if(_err${tapIndex}) {\\n`;\n\t\t\t\tcbCode += onError(`_err${tapIndex}`);\n\t\t\t\tcbCode += \"} else {\\n\";\n\t\t\t\tif (onResult) {\n\t\t\t\t\tcbCode += onResult(`_result${tapIndex}`);\n\t\t\t\t}\n\t\t\t\tif (onDone) {\n\t\t\t\t\tcbCode += onDone();\n\t\t\t\t}\n\t\t\t\tcbCode += \"}\\n\";\n\t\t\t\tcbCode += \"})\";\n\t\t\t\tcode += `_fn${tapIndex}(${this.args({\n\t\t\t\t\tbefore: tap.context ? \"_context\" : undefined,\n\t\t\t\t\tafter: cbCode\n\t\t\t\t})});\\n`;\n\t\t\t\tbreak;\n\t\t\tcase \"promise\":\n\t\t\t\tcode += `var _hasResult${tapIndex} = false;\\n`;\n\t\t\t\tcode += `var _promise${tapIndex} = _fn${tapIndex}(${this.args({\n\t\t\t\t\tbefore: tap.context ? \"_context\" : undefined\n\t\t\t\t})});\\n`;\n\t\t\t\tcode += `if (!_promise${tapIndex} || !_promise${tapIndex}.then)\\n`;\n\t\t\t\tcode += `  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${tapIndex} + ')');\\n`;\n\t\t\t\tcode += `_promise${tapIndex}.then((function(_result${tapIndex}) {\\n`;\n\t\t\t\tcode += `_hasResult${tapIndex} = true;\\n`;\n\t\t\t\tif (onResult) {\n\t\t\t\t\tcode += onResult(`_result${tapIndex}`);\n\t\t\t\t}\n\t\t\t\tif (onDone) {\n\t\t\t\t\tcode += onDone();\n\t\t\t\t}\n\t\t\t\tcode += `}), function(_err${tapIndex}) {\\n`;\n\t\t\t\tcode += `if(_hasResult${tapIndex}) throw _err${tapIndex};\\n`;\n\t\t\t\tcode += onError(`_err${tapIndex}`);\n\t\t\t\tcode += \"});\\n\";\n\t\t\t\tbreak;\n\t\t}\n\t\treturn code;\n\t}\n\n\tcallTapsSeries({\n\t\tonError,\n\t\tonResult,\n\t\tresultReturns,\n\t\tonDone,\n\t\tdoneReturns,\n\t\trethrowIfPossible\n\t}) {\n\t\tif (this.options.taps.length === 0) return onDone();\n\t\tconst firstAsync = this.options.taps.findIndex(t => t.type !== \"sync\");\n\t\tconst somethingReturns = resultReturns || doneReturns;\n\t\tlet code = \"\";\n\t\tlet current = onDone;\n\t\tlet unrollCounter = 0;\n\t\tfor (let j = this.options.taps.length - 1; j >= 0; j--) {\n\t\t\tconst i = j;\n\t\t\tconst unroll =\n\t\t\t\tcurrent !== onDone &&\n\t\t\t\t(this.options.taps[i].type !== \"sync\" || unrollCounter++ > 20);\n\t\t\tif (unroll) {\n\t\t\t\tunrollCounter = 0;\n\t\t\t\tcode += `function _next${i}() {\\n`;\n\t\t\t\tcode += current();\n\t\t\t\tcode += `}\\n`;\n\t\t\t\tcurrent = () => `${somethingReturns ? \"return \" : \"\"}_next${i}();\\n`;\n\t\t\t}\n\t\t\tconst done = current;\n\t\t\tconst doneBreak = skipDone => {\n\t\t\t\tif (skipDone) return \"\";\n\t\t\t\treturn onDone();\n\t\t\t};\n\t\t\tconst content = this.callTap(i, {\n\t\t\t\tonError: error => onError(i, error, done, doneBreak),\n\t\t\t\tonResult:\n\t\t\t\t\tonResult &&\n\t\t\t\t\t(result => {\n\t\t\t\t\t\treturn onResult(i, result, done, doneBreak);\n\t\t\t\t\t}),\n\t\t\t\tonDone: !onResult && done,\n\t\t\t\trethrowIfPossible:\n\t\t\t\t\trethrowIfPossible && (firstAsync < 0 || i < firstAsync)\n\t\t\t});\n\t\t\tcurrent = () => content;\n\t\t}\n\t\tcode += current();\n\t\treturn code;\n\t}\n\n\tcallTapsLooping({ onError, onDone, rethrowIfPossible }) {\n\t\tif (this.options.taps.length === 0) return onDone();\n\t\tconst syncOnly = this.options.taps.every(t => t.type === \"sync\");\n\t\tlet code = \"\";\n\t\tif (!syncOnly) {\n\t\t\tcode += \"var _looper = (function() {\\n\";\n\t\t\tcode += \"var _loopAsync = false;\\n\";\n\t\t}\n\t\tcode += \"var _loop;\\n\";\n\t\tcode += \"do {\\n\";\n\t\tcode += \"_loop = false;\\n\";\n\t\tfor (let i = 0; i < this.options.interceptors.length; i++) {\n\t\t\tconst interceptor = this.options.interceptors[i];\n\t\t\tif (interceptor.loop) {\n\t\t\t\tcode += `${this.getInterceptor(i)}.loop(${this.args({\n\t\t\t\t\tbefore: interceptor.context ? \"_context\" : undefined\n\t\t\t\t})});\\n`;\n\t\t\t}\n\t\t}\n\t\tcode += this.callTapsSeries({\n\t\t\tonError,\n\t\t\tonResult: (i, result, next, doneBreak) => {\n\t\t\t\tlet code = \"\";\n\t\t\t\tcode += `if(${result} !== undefined) {\\n`;\n\t\t\t\tcode += \"_loop = true;\\n\";\n\t\t\t\tif (!syncOnly) code += \"if(_loopAsync) _looper();\\n\";\n\t\t\t\tcode += doneBreak(true);\n\t\t\t\tcode += `} else {\\n`;\n\t\t\t\tcode += next();\n\t\t\t\tcode += `}\\n`;\n\t\t\t\treturn code;\n\t\t\t},\n\t\t\tonDone:\n\t\t\t\tonDone &&\n\t\t\t\t(() => {\n\t\t\t\t\tlet code = \"\";\n\t\t\t\t\tcode += \"if(!_loop) {\\n\";\n\t\t\t\t\tcode += onDone();\n\t\t\t\t\tcode += \"}\\n\";\n\t\t\t\t\treturn code;\n\t\t\t\t}),\n\t\t\trethrowIfPossible: rethrowIfPossible && syncOnly\n\t\t});\n\t\tcode += \"} while(_loop);\\n\";\n\t\tif (!syncOnly) {\n\t\t\tcode += \"_loopAsync = true;\\n\";\n\t\t\tcode += \"});\\n\";\n\t\t\tcode += \"_looper();\\n\";\n\t\t}\n\t\treturn code;\n\t}\n\n\tcallTapsParallel({\n\t\tonError,\n\t\tonResult,\n\t\tonDone,\n\t\trethrowIfPossible,\n\t\tonTap = (i, run) => run()\n\t}) {\n\t\tif (this.options.taps.length <= 1) {\n\t\t\treturn this.callTapsSeries({\n\t\t\t\tonError,\n\t\t\t\tonResult,\n\t\t\t\tonDone,\n\t\t\t\trethrowIfPossible\n\t\t\t});\n\t\t}\n\t\tlet code = \"\";\n\t\tcode += \"do {\\n\";\n\t\tcode += `var _counter = ${this.options.taps.length};\\n`;\n\t\tif (onDone) {\n\t\t\tcode += \"var _done = (function() {\\n\";\n\t\t\tcode += onDone();\n\t\t\tcode += \"});\\n\";\n\t\t}\n\t\tfor (let i = 0; i < this.options.taps.length; i++) {\n\t\t\tconst done = () => {\n\t\t\t\tif (onDone) return \"if(--_counter === 0) _done();\\n\";\n\t\t\t\telse return \"--_counter;\";\n\t\t\t};\n\t\t\tconst doneBreak = skipDone => {\n\t\t\t\tif (skipDone || !onDone) return \"_counter = 0;\\n\";\n\t\t\t\telse return \"_counter = 0;\\n_done();\\n\";\n\t\t\t};\n\t\t\tcode += \"if(_counter <= 0) break;\\n\";\n\t\t\tcode += onTap(\n\t\t\t\ti,\n\t\t\t\t() =>\n\t\t\t\t\tthis.callTap(i, {\n\t\t\t\t\t\tonError: error => {\n\t\t\t\t\t\t\tlet code = \"\";\n\t\t\t\t\t\t\tcode += \"if(_counter > 0) {\\n\";\n\t\t\t\t\t\t\tcode += onError(i, error, done, doneBreak);\n\t\t\t\t\t\t\tcode += \"}\\n\";\n\t\t\t\t\t\t\treturn code;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tonResult:\n\t\t\t\t\t\t\tonResult &&\n\t\t\t\t\t\t\t(result => {\n\t\t\t\t\t\t\t\tlet code = \"\";\n\t\t\t\t\t\t\t\tcode += \"if(_counter > 0) {\\n\";\n\t\t\t\t\t\t\t\tcode += onResult(i, result, done, doneBreak);\n\t\t\t\t\t\t\t\tcode += \"}\\n\";\n\t\t\t\t\t\t\t\treturn code;\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\tonDone:\n\t\t\t\t\t\t\t!onResult &&\n\t\t\t\t\t\t\t(() => {\n\t\t\t\t\t\t\t\treturn done();\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\trethrowIfPossible\n\t\t\t\t\t}),\n\t\t\t\tdone,\n\t\t\t\tdoneBreak\n\t\t\t);\n\t\t}\n\t\tcode += \"} while(false);\\n\";\n\t\treturn code;\n\t}\n\n\targs({ before, after } = {}) {\n\t\tlet allArgs = this._args;\n\t\tif (before) allArgs = [before].concat(allArgs);\n\t\tif (after) allArgs = allArgs.concat(after);\n\t\tif (allArgs.length === 0) {\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\treturn allArgs.join(\", \");\n\t\t}\n\t}\n\n\tgetTapFn(idx) {\n\t\treturn `_x[${idx}]`;\n\t}\n\n\tgetTap(idx) {\n\t\treturn `_taps[${idx}]`;\n\t}\n\n\tgetInterceptor(idx) {\n\t\treturn `_interceptors[${idx}]`;\n\t}\n}\n\nmodule.exports = HookCodeFactory;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  SyncBailHook\n} = require(\"tapable\");\nconst {\n  RawSource,\n  CachedSource,\n  CompatSource\n} = require(\"webpack-sources\");\nconst Compilation = require(\"../Compilation\");\nconst WebpackError = require(\"../WebpackError\");\nconst {\n  compareSelect,\n  compareStrings\n} = require(\"../util/comparators\");\nconst createHash = require(\"../util/createHash\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Cache\").Etag} Etag */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n\nconst EMPTY_SET = new Set();\n\n/**\n * @template T\n * @param {T | T[]} itemOrItems item or items\n * @param {Set<T>} list list\n */\nconst addToList = (itemOrItems, list) => {\n  if (Array.isArray(itemOrItems)) {\n    for (const item of itemOrItems) {\n      list.add(item);\n    }\n  } else if (itemOrItems) {\n    list.add(itemOrItems);\n  }\n};\n\n/**\n * @template T\n * @param {T[]} input list\n * @param {function(T): Buffer} fn map function\n * @returns {Buffer[]} buffers without duplicates\n */\nconst mapAndDeduplicateBuffers = (input, fn) => {\n  // Buffer.equals compares size first so this should be efficient enough\n  // If it becomes a performance problem we can use a map and group by size\n  // instead of looping over all assets.\n  const result = [];\n  outer: for (const value of input) {\n    const buf = fn(value);\n    for (const other of result) {\n      if (buf.equals(other)) continue outer;\n    }\n    result.push(buf);\n  }\n  return result;\n};\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nconst quoteMeta = str => {\n  return str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\nconst cachedSourceMap = new WeakMap();\n\n/**\n * @param {Source} source source\n * @returns {CachedSource} cached source\n */\nconst toCachedSource = source => {\n  if (source instanceof CachedSource) {\n    return source;\n  }\n  const entry = cachedSourceMap.get(source);\n  if (entry !== undefined) return entry;\n  const newSource = new CachedSource(CompatSource.from(source));\n  cachedSourceMap.set(source, newSource);\n  return newSource;\n};\n\n/** @typedef {Set<string>} OwnHashes */\n/** @typedef {Set<string>} ReferencedHashes */\n/** @typedef {Set<string>} Hashes */\n\n/**\n * @typedef {Object} AssetInfoForRealContentHash\n * @property {string} name\n * @property {AssetInfo} info\n * @property {Source} source\n * @property {RawSource | undefined} newSource\n * @property {RawSource | undefined} newSourceWithoutOwn\n * @property {string} content\n * @property {OwnHashes | undefined} ownHashes\n * @property {Promise<void> | undefined} contentComputePromise\n * @property {Promise<void> | undefined} contentComputeWithoutOwnPromise\n * @property {ReferencedHashes | undefined} referencedHashes\n * @property {Hashes} hashes\n */\n\n/**\n * @typedef {Object} CompilationHooks\n * @property {SyncBailHook<[Buffer[], string], string>} updateHash\n */\n\n/** @type {WeakMap<Compilation, CompilationHooks>} */\nconst compilationHooksMap = new WeakMap();\nclass RealContentHashPlugin {\n  /**\n   * @param {Compilation} compilation the compilation\n   * @returns {CompilationHooks} the attached hooks\n   */\n  static getCompilationHooks(compilation) {\n    if (!(compilation instanceof Compilation)) {\n      throw new TypeError(\"The 'compilation' argument must be an instance of Compilation\");\n    }\n    let hooks = compilationHooksMap.get(compilation);\n    if (hooks === undefined) {\n      hooks = {\n        updateHash: new SyncBailHook([\"content\", \"oldHash\"])\n      };\n      compilationHooksMap.set(compilation, hooks);\n    }\n    return hooks;\n  }\n\n  /**\n   * @param {Object} options options object\n   * @param {string | Hash} options.hashFunction the hash function to use\n   * @param {string} options.hashDigest the hash digest to use\n   */\n  constructor({\n    hashFunction,\n    hashDigest\n  }) {\n    this._hashFunction = hashFunction;\n    this._hashDigest = hashDigest;\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"RealContentHashPlugin\", compilation => {\n      const cacheAnalyse = compilation.getCache(\"RealContentHashPlugin|analyse\");\n      const cacheGenerate = compilation.getCache(\"RealContentHashPlugin|generate\");\n      const hooks = RealContentHashPlugin.getCompilationHooks(compilation);\n      compilation.hooks.processAssets.tapPromise({\n        name: \"RealContentHashPlugin\",\n        stage: Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH\n      }, async () => {\n        const assets = compilation.getAssets();\n        /** @type {AssetInfoForRealContentHash[]} */\n        const assetsWithInfo = [];\n        /** @type {Map<string, [AssetInfoForRealContentHash]>} */\n        const hashToAssets = new Map();\n        for (const {\n          source,\n          info,\n          name\n        } of assets) {\n          const cachedSource = toCachedSource(source);\n          const content = /** @type {string} */cachedSource.source();\n          /** @type {Hashes} */\n          const hashes = new Set();\n          addToList(info.contenthash, hashes);\n          /** @type {AssetInfoForRealContentHash} */\n          const data = {\n            name,\n            info,\n            source: cachedSource,\n            newSource: undefined,\n            newSourceWithoutOwn: undefined,\n            content,\n            ownHashes: undefined,\n            contentComputePromise: undefined,\n            contentComputeWithoutOwnPromise: undefined,\n            referencedHashes: undefined,\n            hashes\n          };\n          assetsWithInfo.push(data);\n          for (const hash of hashes) {\n            const list = hashToAssets.get(hash);\n            if (list === undefined) {\n              hashToAssets.set(hash, [data]);\n            } else {\n              list.push(data);\n            }\n          }\n        }\n        if (hashToAssets.size === 0) return;\n        const hashRegExp = new RegExp(Array.from(hashToAssets.keys(), quoteMeta).join(\"|\"), \"g\");\n        await Promise.all(assetsWithInfo.map(async asset => {\n          const {\n            name,\n            source,\n            content,\n            hashes\n          } = asset;\n          if (Buffer.isBuffer(content)) {\n            asset.referencedHashes = EMPTY_SET;\n            asset.ownHashes = EMPTY_SET;\n            return;\n          }\n          const etag = cacheAnalyse.mergeEtags(cacheAnalyse.getLazyHashedEtag(source), Array.from(hashes).join(\"|\"));\n          [asset.referencedHashes, asset.ownHashes] = await cacheAnalyse.providePromise(name, etag, () => {\n            const referencedHashes = new Set();\n            let ownHashes = new Set();\n            const inContent = content.match(hashRegExp);\n            if (inContent) {\n              for (const hash of inContent) {\n                if (hashes.has(hash)) {\n                  ownHashes.add(hash);\n                  continue;\n                }\n                referencedHashes.add(hash);\n              }\n            }\n            return [referencedHashes, ownHashes];\n          });\n        }));\n        /**\n         * @param {string} hash the hash\n         * @returns {undefined | ReferencedHashes} the referenced hashes\n         */\n        const getDependencies = hash => {\n          const assets = hashToAssets.get(hash);\n          if (!assets) {\n            const referencingAssets = assetsWithInfo.filter(asset => /** @type {ReferencedHashes} */asset.referencedHashes.has(hash));\n            const err = new WebpackError(`RealContentHashPlugin\nSome kind of unexpected caching problem occurred.\nAn asset was cached with a reference to another asset (${hash}) that's not in the compilation anymore.\nEither the asset was incorrectly cached, or the referenced asset should also be restored from cache.\nReferenced by:\n${referencingAssets.map(a => {\n              const match = new RegExp(`.{0,20}${quoteMeta(hash)}.{0,20}`).exec(a.content);\n              return ` - ${a.name}: ...${match ? match[0] : \"???\"}...`;\n            }).join(\"\\n\")}`);\n            compilation.errors.push(err);\n            return undefined;\n          }\n          const hashes = new Set();\n          for (const {\n            referencedHashes,\n            ownHashes\n          } of assets) {\n            if (!( /** @type {OwnHashes} */ownHashes.has(hash))) {\n              for (const hash of ( /** @type {OwnHashes} */ownHashes)) {\n                hashes.add(hash);\n              }\n            }\n            for (const hash of ( /** @type {ReferencedHashes} */\n            referencedHashes)) {\n              hashes.add(hash);\n            }\n          }\n          return hashes;\n        };\n        /**\n         * @param {string} hash the hash\n         * @returns {string} the hash info\n         */\n        const hashInfo = hash => {\n          const assets = hashToAssets.get(hash);\n          return `${hash} (${Array.from( /** @type {AssetInfoForRealContentHash[]} */assets, a => a.name)})`;\n        };\n        const hashesInOrder = new Set();\n        for (const hash of hashToAssets.keys()) {\n          /**\n           * @param {string} hash the hash\n           * @param {Set<string>} stack stack of hashes\n           */\n          const add = (hash, stack) => {\n            const deps = getDependencies(hash);\n            if (!deps) return;\n            stack.add(hash);\n            for (const dep of deps) {\n              if (hashesInOrder.has(dep)) continue;\n              if (stack.has(dep)) {\n                throw new Error(`Circular hash dependency ${Array.from(stack, hashInfo).join(\" -> \")} -> ${hashInfo(dep)}`);\n              }\n              add(dep, stack);\n            }\n            hashesInOrder.add(hash);\n            stack.delete(hash);\n          };\n          if (hashesInOrder.has(hash)) continue;\n          add(hash, new Set());\n        }\n        const hashToNewHash = new Map();\n        /**\n         * @param {AssetInfoForRealContentHash} asset asset info\n         * @returns {Etag} etag\n         */\n        const getEtag = asset => cacheGenerate.mergeEtags(cacheGenerate.getLazyHashedEtag(asset.source), Array.from( /** @type {ReferencedHashes} */asset.referencedHashes, hash => hashToNewHash.get(hash)).join(\"|\"));\n        /**\n         * @param {AssetInfoForRealContentHash} asset asset info\n         * @returns {Promise<void>}\n         */\n        const computeNewContent = asset => {\n          if (asset.contentComputePromise) return asset.contentComputePromise;\n          return asset.contentComputePromise = (async () => {\n            if ( /** @type {OwnHashes} */asset.ownHashes.size > 0 || Array.from( /** @type {ReferencedHashes} */\n            asset.referencedHashes).some(hash => hashToNewHash.get(hash) !== hash)) {\n              const identifier = asset.name;\n              const etag = getEtag(asset);\n              asset.newSource = await cacheGenerate.providePromise(identifier, etag, () => {\n                const newContent = asset.content.replace(hashRegExp, hash => hashToNewHash.get(hash));\n                return new RawSource(newContent);\n              });\n            }\n          })();\n        };\n        /**\n         * @param {AssetInfoForRealContentHash} asset asset info\n         * @returns {Promise<void>}\n         */\n        const computeNewContentWithoutOwn = asset => {\n          if (asset.contentComputeWithoutOwnPromise) return asset.contentComputeWithoutOwnPromise;\n          return asset.contentComputeWithoutOwnPromise = (async () => {\n            if ( /** @type {OwnHashes} */asset.ownHashes.size > 0 || Array.from( /** @type {ReferencedHashes} */\n            asset.referencedHashes).some(hash => hashToNewHash.get(hash) !== hash)) {\n              const identifier = asset.name + \"|without-own\";\n              const etag = getEtag(asset);\n              asset.newSourceWithoutOwn = await cacheGenerate.providePromise(identifier, etag, () => {\n                const newContent = asset.content.replace(hashRegExp, hash => {\n                  if ( /** @type {OwnHashes} */asset.ownHashes.has(hash)) {\n                    return \"\";\n                  }\n                  return hashToNewHash.get(hash);\n                });\n                return new RawSource(newContent);\n              });\n            }\n          })();\n        };\n        const comparator = compareSelect(a => a.name, compareStrings);\n        for (const oldHash of hashesInOrder) {\n          const assets = /** @type {AssetInfoForRealContentHash[]} */\n          hashToAssets.get(oldHash);\n          assets.sort(comparator);\n          await Promise.all(assets.map(asset => /** @type {OwnHashes} */asset.ownHashes.has(oldHash) ? computeNewContentWithoutOwn(asset) : computeNewContent(asset)));\n          const assetsContent = mapAndDeduplicateBuffers(assets, asset => {\n            if ( /** @type {OwnHashes} */asset.ownHashes.has(oldHash)) {\n              return asset.newSourceWithoutOwn ? asset.newSourceWithoutOwn.buffer() : asset.source.buffer();\n            } else {\n              return asset.newSource ? asset.newSource.buffer() : asset.source.buffer();\n            }\n          });\n          let newHash = hooks.updateHash.call(assetsContent, oldHash);\n          if (!newHash) {\n            const hash = createHash(this._hashFunction);\n            if (compilation.outputOptions.hashSalt) {\n              hash.update(compilation.outputOptions.hashSalt);\n            }\n            for (const content of assetsContent) {\n              hash.update(content);\n            }\n            const digest = hash.digest(this._hashDigest);\n            newHash = /** @type {string} */digest.slice(0, oldHash.length);\n          }\n          hashToNewHash.set(oldHash, newHash);\n        }\n        await Promise.all(assetsWithInfo.map(async asset => {\n          await computeNewContent(asset);\n          const newName = asset.name.replace(hashRegExp, hash => hashToNewHash.get(hash));\n          const infoUpdate = {};\n          const hash = asset.info.contenthash;\n          infoUpdate.contenthash = Array.isArray(hash) ? hash.map(hash => hashToNewHash.get(hash)) : hashToNewHash.get(hash);\n          if (asset.newSource !== undefined) {\n            compilation.updateAsset(asset.name, asset.newSource, infoUpdate);\n          } else {\n            compilation.updateAsset(asset.name, asset.source, infoUpdate);\n          }\n          if (asset.name !== newName) {\n            compilation.renameAsset(asset.name, newName);\n          }\n        }));\n      });\n    });\n  }\n}\nmodule.exports = RealContentHashPlugin;","map":{"version":3,"names":["SyncBailHook","require","RawSource","CachedSource","CompatSource","Compilation","WebpackError","compareSelect","compareStrings","createHash","EMPTY_SET","Set","addToList","itemOrItems","list","Array","isArray","item","add","mapAndDeduplicateBuffers","input","fn","result","outer","value","buf","other","equals","push","quoteMeta","str","replace","cachedSourceMap","WeakMap","toCachedSource","source","entry","get","undefined","newSource","from","set","compilationHooksMap","RealContentHashPlugin","getCompilationHooks","compilation","TypeError","hooks","updateHash","constructor","hashFunction","hashDigest","_hashFunction","_hashDigest","apply","compiler","tap","cacheAnalyse","getCache","cacheGenerate","processAssets","tapPromise","name","stage","PROCESS_ASSETS_STAGE_OPTIMIZE_HASH","assets","getAssets","assetsWithInfo","hashToAssets","Map","info","cachedSource","content","hashes","contenthash","data","newSourceWithoutOwn","ownHashes","contentComputePromise","contentComputeWithoutOwnPromise","referencedHashes","hash","size","hashRegExp","RegExp","keys","join","Promise","all","map","asset","Buffer","isBuffer","etag","mergeEtags","getLazyHashedEtag","providePromise","inContent","match","has","getDependencies","referencingAssets","filter","err","a","exec","errors","hashInfo","hashesInOrder","stack","deps","dep","Error","delete","hashToNewHash","getEtag","computeNewContent","some","identifier","newContent","computeNewContentWithoutOwn","comparator","oldHash","sort","assetsContent","buffer","newHash","call","outputOptions","hashSalt","update","digest","slice","length","newName","infoUpdate","updateAsset","renameAsset","module","exports"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/optimize/RealContentHashPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { SyncBailHook } = require(\"tapable\");\nconst { RawSource, CachedSource, CompatSource } = require(\"webpack-sources\");\nconst Compilation = require(\"../Compilation\");\nconst WebpackError = require(\"../WebpackError\");\nconst { compareSelect, compareStrings } = require(\"../util/comparators\");\nconst createHash = require(\"../util/createHash\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Cache\").Etag} Etag */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n\nconst EMPTY_SET = new Set();\n\n/**\n * @template T\n * @param {T | T[]} itemOrItems item or items\n * @param {Set<T>} list list\n */\nconst addToList = (itemOrItems, list) => {\n\tif (Array.isArray(itemOrItems)) {\n\t\tfor (const item of itemOrItems) {\n\t\t\tlist.add(item);\n\t\t}\n\t} else if (itemOrItems) {\n\t\tlist.add(itemOrItems);\n\t}\n};\n\n/**\n * @template T\n * @param {T[]} input list\n * @param {function(T): Buffer} fn map function\n * @returns {Buffer[]} buffers without duplicates\n */\nconst mapAndDeduplicateBuffers = (input, fn) => {\n\t// Buffer.equals compares size first so this should be efficient enough\n\t// If it becomes a performance problem we can use a map and group by size\n\t// instead of looping over all assets.\n\tconst result = [];\n\touter: for (const value of input) {\n\t\tconst buf = fn(value);\n\t\tfor (const other of result) {\n\t\t\tif (buf.equals(other)) continue outer;\n\t\t}\n\t\tresult.push(buf);\n\t}\n\treturn result;\n};\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nconst quoteMeta = str => {\n\treturn str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\nconst cachedSourceMap = new WeakMap();\n\n/**\n * @param {Source} source source\n * @returns {CachedSource} cached source\n */\nconst toCachedSource = source => {\n\tif (source instanceof CachedSource) {\n\t\treturn source;\n\t}\n\tconst entry = cachedSourceMap.get(source);\n\tif (entry !== undefined) return entry;\n\tconst newSource = new CachedSource(CompatSource.from(source));\n\tcachedSourceMap.set(source, newSource);\n\treturn newSource;\n};\n\n/** @typedef {Set<string>} OwnHashes */\n/** @typedef {Set<string>} ReferencedHashes */\n/** @typedef {Set<string>} Hashes */\n\n/**\n * @typedef {Object} AssetInfoForRealContentHash\n * @property {string} name\n * @property {AssetInfo} info\n * @property {Source} source\n * @property {RawSource | undefined} newSource\n * @property {RawSource | undefined} newSourceWithoutOwn\n * @property {string} content\n * @property {OwnHashes | undefined} ownHashes\n * @property {Promise<void> | undefined} contentComputePromise\n * @property {Promise<void> | undefined} contentComputeWithoutOwnPromise\n * @property {ReferencedHashes | undefined} referencedHashes\n * @property {Hashes} hashes\n */\n\n/**\n * @typedef {Object} CompilationHooks\n * @property {SyncBailHook<[Buffer[], string], string>} updateHash\n */\n\n/** @type {WeakMap<Compilation, CompilationHooks>} */\nconst compilationHooksMap = new WeakMap();\n\nclass RealContentHashPlugin {\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @returns {CompilationHooks} the attached hooks\n\t */\n\tstatic getCompilationHooks(compilation) {\n\t\tif (!(compilation instanceof Compilation)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t\"The 'compilation' argument must be an instance of Compilation\"\n\t\t\t);\n\t\t}\n\t\tlet hooks = compilationHooksMap.get(compilation);\n\t\tif (hooks === undefined) {\n\t\t\thooks = {\n\t\t\t\tupdateHash: new SyncBailHook([\"content\", \"oldHash\"])\n\t\t\t};\n\t\t\tcompilationHooksMap.set(compilation, hooks);\n\t\t}\n\t\treturn hooks;\n\t}\n\n\t/**\n\t * @param {Object} options options object\n\t * @param {string | Hash} options.hashFunction the hash function to use\n\t * @param {string} options.hashDigest the hash digest to use\n\t */\n\tconstructor({ hashFunction, hashDigest }) {\n\t\tthis._hashFunction = hashFunction;\n\t\tthis._hashDigest = hashDigest;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"RealContentHashPlugin\", compilation => {\n\t\t\tconst cacheAnalyse = compilation.getCache(\n\t\t\t\t\"RealContentHashPlugin|analyse\"\n\t\t\t);\n\t\t\tconst cacheGenerate = compilation.getCache(\n\t\t\t\t\"RealContentHashPlugin|generate\"\n\t\t\t);\n\t\t\tconst hooks = RealContentHashPlugin.getCompilationHooks(compilation);\n\t\t\tcompilation.hooks.processAssets.tapPromise(\n\t\t\t\t{\n\t\t\t\t\tname: \"RealContentHashPlugin\",\n\t\t\t\t\tstage: Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH\n\t\t\t\t},\n\t\t\t\tasync () => {\n\t\t\t\t\tconst assets = compilation.getAssets();\n\t\t\t\t\t/** @type {AssetInfoForRealContentHash[]} */\n\t\t\t\t\tconst assetsWithInfo = [];\n\t\t\t\t\t/** @type {Map<string, [AssetInfoForRealContentHash]>} */\n\t\t\t\t\tconst hashToAssets = new Map();\n\t\t\t\t\tfor (const { source, info, name } of assets) {\n\t\t\t\t\t\tconst cachedSource = toCachedSource(source);\n\t\t\t\t\t\tconst content = /** @type {string} */ (cachedSource.source());\n\t\t\t\t\t\t/** @type {Hashes} */\n\t\t\t\t\t\tconst hashes = new Set();\n\t\t\t\t\t\taddToList(info.contenthash, hashes);\n\t\t\t\t\t\t/** @type {AssetInfoForRealContentHash} */\n\t\t\t\t\t\tconst data = {\n\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\tsource: cachedSource,\n\t\t\t\t\t\t\tnewSource: undefined,\n\t\t\t\t\t\t\tnewSourceWithoutOwn: undefined,\n\t\t\t\t\t\t\tcontent,\n\t\t\t\t\t\t\townHashes: undefined,\n\t\t\t\t\t\t\tcontentComputePromise: undefined,\n\t\t\t\t\t\t\tcontentComputeWithoutOwnPromise: undefined,\n\t\t\t\t\t\t\treferencedHashes: undefined,\n\t\t\t\t\t\t\thashes\n\t\t\t\t\t\t};\n\t\t\t\t\t\tassetsWithInfo.push(data);\n\t\t\t\t\t\tfor (const hash of hashes) {\n\t\t\t\t\t\t\tconst list = hashToAssets.get(hash);\n\t\t\t\t\t\t\tif (list === undefined) {\n\t\t\t\t\t\t\t\thashToAssets.set(hash, [data]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlist.push(data);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (hashToAssets.size === 0) return;\n\t\t\t\t\tconst hashRegExp = new RegExp(\n\t\t\t\t\t\tArray.from(hashToAssets.keys(), quoteMeta).join(\"|\"),\n\t\t\t\t\t\t\"g\"\n\t\t\t\t\t);\n\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\tassetsWithInfo.map(async asset => {\n\t\t\t\t\t\t\tconst { name, source, content, hashes } = asset;\n\t\t\t\t\t\t\tif (Buffer.isBuffer(content)) {\n\t\t\t\t\t\t\t\tasset.referencedHashes = EMPTY_SET;\n\t\t\t\t\t\t\t\tasset.ownHashes = EMPTY_SET;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst etag = cacheAnalyse.mergeEtags(\n\t\t\t\t\t\t\t\tcacheAnalyse.getLazyHashedEtag(source),\n\t\t\t\t\t\t\t\tArray.from(hashes).join(\"|\")\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t[asset.referencedHashes, asset.ownHashes] =\n\t\t\t\t\t\t\t\tawait cacheAnalyse.providePromise(name, etag, () => {\n\t\t\t\t\t\t\t\t\tconst referencedHashes = new Set();\n\t\t\t\t\t\t\t\t\tlet ownHashes = new Set();\n\t\t\t\t\t\t\t\t\tconst inContent = content.match(hashRegExp);\n\t\t\t\t\t\t\t\t\tif (inContent) {\n\t\t\t\t\t\t\t\t\t\tfor (const hash of inContent) {\n\t\t\t\t\t\t\t\t\t\t\tif (hashes.has(hash)) {\n\t\t\t\t\t\t\t\t\t\t\t\townHashes.add(hash);\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treferencedHashes.add(hash);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn [referencedHashes, ownHashes];\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} hash the hash\n\t\t\t\t\t * @returns {undefined | ReferencedHashes} the referenced hashes\n\t\t\t\t\t */\n\t\t\t\t\tconst getDependencies = hash => {\n\t\t\t\t\t\tconst assets = hashToAssets.get(hash);\n\t\t\t\t\t\tif (!assets) {\n\t\t\t\t\t\t\tconst referencingAssets = assetsWithInfo.filter(asset =>\n\t\t\t\t\t\t\t\t/** @type {ReferencedHashes} */ (asset.referencedHashes).has(\n\t\t\t\t\t\t\t\t\thash\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst err = new WebpackError(`RealContentHashPlugin\nSome kind of unexpected caching problem occurred.\nAn asset was cached with a reference to another asset (${hash}) that's not in the compilation anymore.\nEither the asset was incorrectly cached, or the referenced asset should also be restored from cache.\nReferenced by:\n${referencingAssets\n\t.map(a => {\n\t\tconst match = new RegExp(`.{0,20}${quoteMeta(hash)}.{0,20}`).exec(\n\t\t\ta.content\n\t\t);\n\t\treturn ` - ${a.name}: ...${match ? match[0] : \"???\"}...`;\n\t})\n\t.join(\"\\n\")}`);\n\t\t\t\t\t\t\tcompilation.errors.push(err);\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst hashes = new Set();\n\t\t\t\t\t\tfor (const { referencedHashes, ownHashes } of assets) {\n\t\t\t\t\t\t\tif (!(/** @type {OwnHashes} */ (ownHashes).has(hash))) {\n\t\t\t\t\t\t\t\tfor (const hash of /** @type {OwnHashes} */ (ownHashes)) {\n\t\t\t\t\t\t\t\t\thashes.add(hash);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const hash of /** @type {ReferencedHashes} */ (\n\t\t\t\t\t\t\t\treferencedHashes\n\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\thashes.add(hash);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn hashes;\n\t\t\t\t\t};\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} hash the hash\n\t\t\t\t\t * @returns {string} the hash info\n\t\t\t\t\t */\n\t\t\t\t\tconst hashInfo = hash => {\n\t\t\t\t\t\tconst assets = hashToAssets.get(hash);\n\t\t\t\t\t\treturn `${hash} (${Array.from(\n\t\t\t\t\t\t\t/** @type {AssetInfoForRealContentHash[]} */ (assets),\n\t\t\t\t\t\t\ta => a.name\n\t\t\t\t\t\t)})`;\n\t\t\t\t\t};\n\t\t\t\t\tconst hashesInOrder = new Set();\n\t\t\t\t\tfor (const hash of hashToAssets.keys()) {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {string} hash the hash\n\t\t\t\t\t\t * @param {Set<string>} stack stack of hashes\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst add = (hash, stack) => {\n\t\t\t\t\t\t\tconst deps = getDependencies(hash);\n\t\t\t\t\t\t\tif (!deps) return;\n\t\t\t\t\t\t\tstack.add(hash);\n\t\t\t\t\t\t\tfor (const dep of deps) {\n\t\t\t\t\t\t\t\tif (hashesInOrder.has(dep)) continue;\n\t\t\t\t\t\t\t\tif (stack.has(dep)) {\n\t\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\t`Circular hash dependency ${Array.from(\n\t\t\t\t\t\t\t\t\t\t\tstack,\n\t\t\t\t\t\t\t\t\t\t\thashInfo\n\t\t\t\t\t\t\t\t\t\t).join(\" -> \")} -> ${hashInfo(dep)}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tadd(dep, stack);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thashesInOrder.add(hash);\n\t\t\t\t\t\t\tstack.delete(hash);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (hashesInOrder.has(hash)) continue;\n\t\t\t\t\t\tadd(hash, new Set());\n\t\t\t\t\t}\n\t\t\t\t\tconst hashToNewHash = new Map();\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {AssetInfoForRealContentHash} asset asset info\n\t\t\t\t\t * @returns {Etag} etag\n\t\t\t\t\t */\n\t\t\t\t\tconst getEtag = asset =>\n\t\t\t\t\t\tcacheGenerate.mergeEtags(\n\t\t\t\t\t\t\tcacheGenerate.getLazyHashedEtag(asset.source),\n\t\t\t\t\t\t\tArray.from(\n\t\t\t\t\t\t\t\t/** @type {ReferencedHashes} */ (asset.referencedHashes),\n\t\t\t\t\t\t\t\thash => hashToNewHash.get(hash)\n\t\t\t\t\t\t\t).join(\"|\")\n\t\t\t\t\t\t);\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {AssetInfoForRealContentHash} asset asset info\n\t\t\t\t\t * @returns {Promise<void>}\n\t\t\t\t\t */\n\t\t\t\t\tconst computeNewContent = asset => {\n\t\t\t\t\t\tif (asset.contentComputePromise) return asset.contentComputePromise;\n\t\t\t\t\t\treturn (asset.contentComputePromise = (async () => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t/** @type {OwnHashes} */ (asset.ownHashes).size > 0 ||\n\t\t\t\t\t\t\t\tArray.from(\n\t\t\t\t\t\t\t\t\t/** @type {ReferencedHashes} */\n\t\t\t\t\t\t\t\t\t(asset.referencedHashes)\n\t\t\t\t\t\t\t\t).some(hash => hashToNewHash.get(hash) !== hash)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst identifier = asset.name;\n\t\t\t\t\t\t\t\tconst etag = getEtag(asset);\n\t\t\t\t\t\t\t\tasset.newSource = await cacheGenerate.providePromise(\n\t\t\t\t\t\t\t\t\tidentifier,\n\t\t\t\t\t\t\t\t\tetag,\n\t\t\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\t\t\tconst newContent = asset.content.replace(hashRegExp, hash =>\n\t\t\t\t\t\t\t\t\t\t\thashToNewHash.get(hash)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn new RawSource(newContent);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})());\n\t\t\t\t\t};\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {AssetInfoForRealContentHash} asset asset info\n\t\t\t\t\t * @returns {Promise<void>}\n\t\t\t\t\t */\n\t\t\t\t\tconst computeNewContentWithoutOwn = asset => {\n\t\t\t\t\t\tif (asset.contentComputeWithoutOwnPromise)\n\t\t\t\t\t\t\treturn asset.contentComputeWithoutOwnPromise;\n\t\t\t\t\t\treturn (asset.contentComputeWithoutOwnPromise = (async () => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t/** @type {OwnHashes} */ (asset.ownHashes).size > 0 ||\n\t\t\t\t\t\t\t\tArray.from(\n\t\t\t\t\t\t\t\t\t/** @type {ReferencedHashes} */\n\t\t\t\t\t\t\t\t\t(asset.referencedHashes)\n\t\t\t\t\t\t\t\t).some(hash => hashToNewHash.get(hash) !== hash)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst identifier = asset.name + \"|without-own\";\n\t\t\t\t\t\t\t\tconst etag = getEtag(asset);\n\t\t\t\t\t\t\t\tasset.newSourceWithoutOwn = await cacheGenerate.providePromise(\n\t\t\t\t\t\t\t\t\tidentifier,\n\t\t\t\t\t\t\t\t\tetag,\n\t\t\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\t\t\tconst newContent = asset.content.replace(\n\t\t\t\t\t\t\t\t\t\t\thashRegExp,\n\t\t\t\t\t\t\t\t\t\t\thash => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\t/** @type {OwnHashes} */ (asset.ownHashes).has(hash)\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\treturn hashToNewHash.get(hash);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn new RawSource(newContent);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})());\n\t\t\t\t\t};\n\t\t\t\t\tconst comparator = compareSelect(a => a.name, compareStrings);\n\t\t\t\t\tfor (const oldHash of hashesInOrder) {\n\t\t\t\t\t\tconst assets =\n\t\t\t\t\t\t\t/** @type {AssetInfoForRealContentHash[]} */\n\t\t\t\t\t\t\t(hashToAssets.get(oldHash));\n\t\t\t\t\t\tassets.sort(comparator);\n\t\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\t\tassets.map(asset =>\n\t\t\t\t\t\t\t\t/** @type {OwnHashes} */ (asset.ownHashes).has(oldHash)\n\t\t\t\t\t\t\t\t\t? computeNewContentWithoutOwn(asset)\n\t\t\t\t\t\t\t\t\t: computeNewContent(asset)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst assetsContent = mapAndDeduplicateBuffers(assets, asset => {\n\t\t\t\t\t\t\tif (/** @type {OwnHashes} */ (asset.ownHashes).has(oldHash)) {\n\t\t\t\t\t\t\t\treturn asset.newSourceWithoutOwn\n\t\t\t\t\t\t\t\t\t? asset.newSourceWithoutOwn.buffer()\n\t\t\t\t\t\t\t\t\t: asset.source.buffer();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn asset.newSource\n\t\t\t\t\t\t\t\t\t? asset.newSource.buffer()\n\t\t\t\t\t\t\t\t\t: asset.source.buffer();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tlet newHash = hooks.updateHash.call(assetsContent, oldHash);\n\t\t\t\t\t\tif (!newHash) {\n\t\t\t\t\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\t\t\t\t\tif (compilation.outputOptions.hashSalt) {\n\t\t\t\t\t\t\t\thash.update(compilation.outputOptions.hashSalt);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const content of assetsContent) {\n\t\t\t\t\t\t\t\thash.update(content);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst digest = hash.digest(this._hashDigest);\n\t\t\t\t\t\t\tnewHash = /** @type {string} */ (digest.slice(0, oldHash.length));\n\t\t\t\t\t\t}\n\t\t\t\t\t\thashToNewHash.set(oldHash, newHash);\n\t\t\t\t\t}\n\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\tassetsWithInfo.map(async asset => {\n\t\t\t\t\t\t\tawait computeNewContent(asset);\n\t\t\t\t\t\t\tconst newName = asset.name.replace(hashRegExp, hash =>\n\t\t\t\t\t\t\t\thashToNewHash.get(hash)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tconst infoUpdate = {};\n\t\t\t\t\t\t\tconst hash = asset.info.contenthash;\n\t\t\t\t\t\t\tinfoUpdate.contenthash = Array.isArray(hash)\n\t\t\t\t\t\t\t\t? hash.map(hash => hashToNewHash.get(hash))\n\t\t\t\t\t\t\t\t: hashToNewHash.get(hash);\n\n\t\t\t\t\t\t\tif (asset.newSource !== undefined) {\n\t\t\t\t\t\t\t\tcompilation.updateAsset(\n\t\t\t\t\t\t\t\t\tasset.name,\n\t\t\t\t\t\t\t\t\tasset.newSource,\n\t\t\t\t\t\t\t\t\tinfoUpdate\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcompilation.updateAsset(asset.name, asset.source, infoUpdate);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (asset.name !== newName) {\n\t\t\t\t\t\t\t\tcompilation.renameAsset(asset.name, newName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = RealContentHashPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
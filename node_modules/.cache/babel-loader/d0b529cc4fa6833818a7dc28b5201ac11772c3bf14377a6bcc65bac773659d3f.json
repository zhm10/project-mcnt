{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst {\n  AsyncSeriesWaterfallHook,\n  SyncWaterfallHook\n} = require(\"tapable\");\nconst ContextModule = require(\"./ContextModule\");\nconst ModuleFactory = require(\"./ModuleFactory\");\nconst ContextElementDependency = require(\"./dependencies/ContextElementDependency\");\nconst LazySet = require(\"./util/LazySet\");\nconst {\n  cachedSetProperty\n} = require(\"./util/cleverMerge\");\nconst {\n  createFakeHook\n} = require(\"./util/deprecation\");\nconst {\n  join\n} = require(\"./util/fs\");\n\n/** @typedef {import(\"./ContextModule\").ContextModuleOptions} ContextModuleOptions */\n/** @typedef {import(\"./ContextModule\").ResolveDependenciesCallback} ResolveDependenciesCallback */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryCreateData} ModuleFactoryCreateData */\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryResult} ModuleFactoryResult */\n/** @typedef {import(\"./ResolverFactory\")} ResolverFactory */\n/** @typedef {import(\"./dependencies/ContextDependency\")} ContextDependency */\n/** @template T @typedef {import(\"./util/deprecation\").FakeHook<T>} FakeHook<T> */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n\nconst EMPTY_RESOLVE_OPTIONS = {};\nmodule.exports = class ContextModuleFactory extends ModuleFactory {\n  /**\n   * @param {ResolverFactory} resolverFactory resolverFactory\n   */\n  constructor(resolverFactory) {\n    super();\n    /** @type {AsyncSeriesWaterfallHook<[TODO[], ContextModuleOptions]>} */\n    const alternativeRequests = new AsyncSeriesWaterfallHook([\"modules\", \"options\"]);\n    this.hooks = Object.freeze({\n      /** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n      beforeResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n      /** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n      afterResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n      /** @type {SyncWaterfallHook<[string[]]>} */\n      contextModuleFiles: new SyncWaterfallHook([\"files\"]),\n      /** @type {FakeHook<Pick<AsyncSeriesWaterfallHook<[TODO[]]>, \"tap\" | \"tapAsync\" | \"tapPromise\" | \"name\">>} */\n      alternatives: createFakeHook({\n        name: \"alternatives\",\n        /** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"intercept\"]} */\n        intercept: interceptor => {\n          throw new Error(\"Intercepting fake hook ContextModuleFactory.hooks.alternatives is not possible, use ContextModuleFactory.hooks.alternativeRequests instead\");\n        },\n        /** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tap\"]} */\n        tap: (options, fn) => {\n          alternativeRequests.tap(options, fn);\n        },\n        /** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tapAsync\"]} */\n        tapAsync: (options, fn) => {\n          alternativeRequests.tapAsync(options, (items, _options, callback) => fn(items, callback));\n        },\n        /** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tapPromise\"]} */\n        tapPromise: (options, fn) => {\n          alternativeRequests.tapPromise(options, fn);\n        }\n      }, \"ContextModuleFactory.hooks.alternatives has deprecated in favor of ContextModuleFactory.hooks.alternativeRequests with an additional options argument.\", \"DEP_WEBPACK_CONTEXT_MODULE_FACTORY_ALTERNATIVES\"),\n      alternativeRequests\n    });\n    this.resolverFactory = resolverFactory;\n  }\n\n  /**\n   * @param {ModuleFactoryCreateData} data data object\n   * @param {function((Error | null)=, ModuleFactoryResult=): void} callback callback\n   * @returns {void}\n   */\n  create(data, callback) {\n    const context = data.context;\n    const dependencies = data.dependencies;\n    const resolveOptions = data.resolveOptions;\n    const dependency = /** @type {ContextDependency} */dependencies[0];\n    const fileDependencies = new LazySet();\n    const missingDependencies = new LazySet();\n    const contextDependencies = new LazySet();\n    this.hooks.beforeResolve.callAsync({\n      context: context,\n      dependencies: dependencies,\n      layer: data.contextInfo.issuerLayer,\n      resolveOptions,\n      fileDependencies,\n      missingDependencies,\n      contextDependencies,\n      ...dependency.options\n    }, (err, beforeResolveResult) => {\n      if (err) {\n        return callback(err, {\n          fileDependencies,\n          missingDependencies,\n          contextDependencies\n        });\n      }\n\n      // Ignored\n      if (!beforeResolveResult) {\n        return callback(null, {\n          fileDependencies,\n          missingDependencies,\n          contextDependencies\n        });\n      }\n      const context = beforeResolveResult.context;\n      const request = beforeResolveResult.request;\n      const resolveOptions = beforeResolveResult.resolveOptions;\n      let loaders,\n        resource,\n        loadersPrefix = \"\";\n      const idx = request.lastIndexOf(\"!\");\n      if (idx >= 0) {\n        let loadersRequest = request.slice(0, idx + 1);\n        let i;\n        for (i = 0; i < loadersRequest.length && loadersRequest[i] === \"!\"; i++) {\n          loadersPrefix += \"!\";\n        }\n        loadersRequest = loadersRequest.slice(i).replace(/!+$/, \"\").replace(/!!+/g, \"!\");\n        if (loadersRequest === \"\") {\n          loaders = [];\n        } else {\n          loaders = loadersRequest.split(\"!\");\n        }\n        resource = request.slice(idx + 1);\n      } else {\n        loaders = [];\n        resource = request;\n      }\n      const contextResolver = this.resolverFactory.get(\"context\", dependencies.length > 0 ? cachedSetProperty(resolveOptions || EMPTY_RESOLVE_OPTIONS, \"dependencyType\", dependencies[0].category) : resolveOptions);\n      const loaderResolver = this.resolverFactory.get(\"loader\");\n      asyncLib.parallel([callback => {\n        const results = [];\n        const yield_ = obj => results.push(obj);\n        contextResolver.resolve({}, context, resource, {\n          fileDependencies,\n          missingDependencies,\n          contextDependencies,\n          yield: yield_\n        }, err => {\n          if (err) return callback(err);\n          callback(null, results);\n        });\n      }, callback => {\n        asyncLib.map(loaders, (loader, callback) => {\n          loaderResolver.resolve({}, context, loader, {\n            fileDependencies,\n            missingDependencies,\n            contextDependencies\n          }, (err, result) => {\n            if (err) return callback(err);\n            callback(null, result);\n          });\n        }, callback);\n      }], (err, result) => {\n        if (err) {\n          return callback(err, {\n            fileDependencies,\n            missingDependencies,\n            contextDependencies\n          });\n        }\n        let [contextResult, loaderResult] = result;\n        if (contextResult.length > 1) {\n          const first = contextResult[0];\n          contextResult = contextResult.filter(r => r.path);\n          if (contextResult.length === 0) contextResult.push(first);\n        }\n        this.hooks.afterResolve.callAsync({\n          addon: loadersPrefix + loaderResult.join(\"!\") + (loaderResult.length > 0 ? \"!\" : \"\"),\n          resource: contextResult.length > 1 ? contextResult.map(r => r.path) : contextResult[0].path,\n          resolveDependencies: this.resolveDependencies.bind(this),\n          resourceQuery: contextResult[0].query,\n          resourceFragment: contextResult[0].fragment,\n          ...beforeResolveResult\n        }, (err, result) => {\n          if (err) {\n            return callback(err, {\n              fileDependencies,\n              missingDependencies,\n              contextDependencies\n            });\n          }\n\n          // Ignored\n          if (!result) {\n            return callback(null, {\n              fileDependencies,\n              missingDependencies,\n              contextDependencies\n            });\n          }\n          return callback(null, {\n            module: new ContextModule(result.resolveDependencies, result),\n            fileDependencies,\n            missingDependencies,\n            contextDependencies\n          });\n        });\n      });\n    });\n  }\n\n  /**\n   * @param {InputFileSystem} fs file system\n   * @param {ContextModuleOptions} options options\n   * @param {ResolveDependenciesCallback} callback callback function\n   * @returns {void}\n   */\n  resolveDependencies(fs, options, callback) {\n    const cmf = this;\n    const {\n      resource,\n      resourceQuery,\n      resourceFragment,\n      recursive,\n      regExp,\n      include,\n      exclude,\n      referencedExports,\n      category,\n      typePrefix,\n      attributes\n    } = options;\n    if (!regExp || !resource) return callback(null, []);\n    const addDirectoryChecked = (ctx, directory, visited, callback) => {\n      fs.realpath(directory, (err, realPath) => {\n        if (err) return callback(err);\n        if (visited.has(realPath)) return callback(null, []);\n        let recursionStack;\n        addDirectory(ctx, directory, (_, dir, callback) => {\n          if (recursionStack === undefined) {\n            recursionStack = new Set(visited);\n            recursionStack.add(realPath);\n          }\n          addDirectoryChecked(ctx, dir, recursionStack, callback);\n        }, callback);\n      });\n    };\n    const addDirectory = (ctx, directory, addSubDirectory, callback) => {\n      fs.readdir(directory, (err, files) => {\n        if (err) return callback(err);\n        const processedFiles = cmf.hooks.contextModuleFiles.call( /** @type {string[]} */files.map(file => file.normalize(\"NFC\")));\n        if (!processedFiles || processedFiles.length === 0) return callback(null, []);\n        asyncLib.map(processedFiles.filter(p => p.indexOf(\".\") !== 0), (segment, callback) => {\n          const subResource = join(fs, directory, segment);\n          if (!exclude || !subResource.match(exclude)) {\n            fs.stat(subResource, (err, stat) => {\n              if (err) {\n                if (err.code === \"ENOENT\") {\n                  // ENOENT is ok here because the file may have been deleted between\n                  // the readdir and stat calls.\n                  return callback();\n                } else {\n                  return callback(err);\n                }\n              }\n              if (stat.isDirectory()) {\n                if (!recursive) return callback();\n                addSubDirectory(ctx, subResource, callback);\n              } else if (stat.isFile() && (!include || subResource.match(include))) {\n                const obj = {\n                  context: ctx,\n                  request: \".\" + subResource.slice(ctx.length).replace(/\\\\/g, \"/\")\n                };\n                this.hooks.alternativeRequests.callAsync([obj], options, (err, alternatives) => {\n                  if (err) return callback(err);\n                  alternatives = alternatives.filter(obj => regExp.test(obj.request)).map(obj => {\n                    const dep = new ContextElementDependency(`${obj.request}${resourceQuery}${resourceFragment}`, obj.request, typePrefix, category, referencedExports, obj.context, attributes);\n                    dep.optional = true;\n                    return dep;\n                  });\n                  callback(null, alternatives);\n                });\n              } else {\n                callback();\n              }\n            });\n          } else {\n            callback();\n          }\n        }, (err, result) => {\n          if (err) return callback(err);\n          if (!result) return callback(null, []);\n          const flattenedResult = [];\n          for (const item of result) {\n            if (item) flattenedResult.push(...item);\n          }\n          callback(null, flattenedResult);\n        });\n      });\n    };\n    const addSubDirectory = (ctx, dir, callback) => addDirectory(ctx, dir, addSubDirectory, callback);\n    const visitResource = (resource, callback) => {\n      if (typeof fs.realpath === \"function\") {\n        addDirectoryChecked(resource, resource, new Set(), callback);\n      } else {\n        addDirectory(resource, resource, addSubDirectory, callback);\n      }\n    };\n    if (typeof resource === \"string\") {\n      visitResource(resource, callback);\n    } else {\n      asyncLib.map(resource, visitResource, (err, result) => {\n        if (err) return callback(err);\n\n        // result dependencies should have unique userRequest\n        // ordered by resolve result\n        const temp = new Set();\n        const res = [];\n        for (let i = 0; i < result.length; i++) {\n          const inner = result[i];\n          for (const el of inner) {\n            if (temp.has(el.userRequest)) continue;\n            res.push(el);\n            temp.add(el.userRequest);\n          }\n        }\n        callback(null, res);\n      });\n    }\n  }\n};","map":{"version":3,"names":["asyncLib","require","AsyncSeriesWaterfallHook","SyncWaterfallHook","ContextModule","ModuleFactory","ContextElementDependency","LazySet","cachedSetProperty","createFakeHook","join","EMPTY_RESOLVE_OPTIONS","module","exports","ContextModuleFactory","constructor","resolverFactory","alternativeRequests","hooks","Object","freeze","beforeResolve","afterResolve","contextModuleFiles","alternatives","name","intercept","interceptor","Error","tap","options","fn","tapAsync","items","_options","callback","tapPromise","create","data","context","dependencies","resolveOptions","dependency","fileDependencies","missingDependencies","contextDependencies","callAsync","layer","contextInfo","issuerLayer","err","beforeResolveResult","request","loaders","resource","loadersPrefix","idx","lastIndexOf","loadersRequest","slice","i","length","replace","split","contextResolver","get","category","loaderResolver","parallel","results","yield_","obj","push","resolve","yield","map","loader","result","contextResult","loaderResult","first","filter","r","path","addon","resolveDependencies","bind","resourceQuery","query","resourceFragment","fragment","fs","cmf","recursive","regExp","include","exclude","referencedExports","typePrefix","attributes","addDirectoryChecked","ctx","directory","visited","realpath","realPath","has","recursionStack","addDirectory","_","dir","undefined","Set","add","addSubDirectory","readdir","files","processedFiles","call","file","normalize","p","indexOf","segment","subResource","match","stat","code","isDirectory","isFile","test","dep","optional","flattenedResult","item","visitResource","temp","res","inner","el","userRequest"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/ContextModuleFactory.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst { AsyncSeriesWaterfallHook, SyncWaterfallHook } = require(\"tapable\");\nconst ContextModule = require(\"./ContextModule\");\nconst ModuleFactory = require(\"./ModuleFactory\");\nconst ContextElementDependency = require(\"./dependencies/ContextElementDependency\");\nconst LazySet = require(\"./util/LazySet\");\nconst { cachedSetProperty } = require(\"./util/cleverMerge\");\nconst { createFakeHook } = require(\"./util/deprecation\");\nconst { join } = require(\"./util/fs\");\n\n/** @typedef {import(\"./ContextModule\").ContextModuleOptions} ContextModuleOptions */\n/** @typedef {import(\"./ContextModule\").ResolveDependenciesCallback} ResolveDependenciesCallback */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryCreateData} ModuleFactoryCreateData */\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryResult} ModuleFactoryResult */\n/** @typedef {import(\"./ResolverFactory\")} ResolverFactory */\n/** @typedef {import(\"./dependencies/ContextDependency\")} ContextDependency */\n/** @template T @typedef {import(\"./util/deprecation\").FakeHook<T>} FakeHook<T> */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n\nconst EMPTY_RESOLVE_OPTIONS = {};\n\nmodule.exports = class ContextModuleFactory extends ModuleFactory {\n\t/**\n\t * @param {ResolverFactory} resolverFactory resolverFactory\n\t */\n\tconstructor(resolverFactory) {\n\t\tsuper();\n\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[], ContextModuleOptions]>} */\n\t\tconst alternativeRequests = new AsyncSeriesWaterfallHook([\n\t\t\t\"modules\",\n\t\t\t\"options\"\n\t\t]);\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n\t\t\tbeforeResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n\t\t\tafterResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\t\t\t/** @type {SyncWaterfallHook<[string[]]>} */\n\t\t\tcontextModuleFiles: new SyncWaterfallHook([\"files\"]),\n\t\t\t/** @type {FakeHook<Pick<AsyncSeriesWaterfallHook<[TODO[]]>, \"tap\" | \"tapAsync\" | \"tapPromise\" | \"name\">>} */\n\t\t\talternatives: createFakeHook(\n\t\t\t\t{\n\t\t\t\t\tname: \"alternatives\",\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"intercept\"]} */\n\t\t\t\t\tintercept: interceptor => {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\"Intercepting fake hook ContextModuleFactory.hooks.alternatives is not possible, use ContextModuleFactory.hooks.alternativeRequests instead\"\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tap\"]} */\n\t\t\t\t\ttap: (options, fn) => {\n\t\t\t\t\t\talternativeRequests.tap(options, fn);\n\t\t\t\t\t},\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tapAsync\"]} */\n\t\t\t\t\ttapAsync: (options, fn) => {\n\t\t\t\t\t\talternativeRequests.tapAsync(options, (items, _options, callback) =>\n\t\t\t\t\t\t\tfn(items, callback)\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tapPromise\"]} */\n\t\t\t\t\ttapPromise: (options, fn) => {\n\t\t\t\t\t\talternativeRequests.tapPromise(options, fn);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"ContextModuleFactory.hooks.alternatives has deprecated in favor of ContextModuleFactory.hooks.alternativeRequests with an additional options argument.\",\n\t\t\t\t\"DEP_WEBPACK_CONTEXT_MODULE_FACTORY_ALTERNATIVES\"\n\t\t\t),\n\t\t\talternativeRequests\n\t\t});\n\t\tthis.resolverFactory = resolverFactory;\n\t}\n\n\t/**\n\t * @param {ModuleFactoryCreateData} data data object\n\t * @param {function((Error | null)=, ModuleFactoryResult=): void} callback callback\n\t * @returns {void}\n\t */\n\tcreate(data, callback) {\n\t\tconst context = data.context;\n\t\tconst dependencies = data.dependencies;\n\t\tconst resolveOptions = data.resolveOptions;\n\t\tconst dependency = /** @type {ContextDependency} */ (dependencies[0]);\n\t\tconst fileDependencies = new LazySet();\n\t\tconst missingDependencies = new LazySet();\n\t\tconst contextDependencies = new LazySet();\n\t\tthis.hooks.beforeResolve.callAsync(\n\t\t\t{\n\t\t\t\tcontext: context,\n\t\t\t\tdependencies: dependencies,\n\t\t\t\tlayer: data.contextInfo.issuerLayer,\n\t\t\t\tresolveOptions,\n\t\t\t\tfileDependencies,\n\t\t\t\tmissingDependencies,\n\t\t\t\tcontextDependencies,\n\t\t\t\t...dependency.options\n\t\t\t},\n\t\t\t(err, beforeResolveResult) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err, {\n\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Ignored\n\t\t\t\tif (!beforeResolveResult) {\n\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst context = beforeResolveResult.context;\n\t\t\t\tconst request = beforeResolveResult.request;\n\t\t\t\tconst resolveOptions = beforeResolveResult.resolveOptions;\n\n\t\t\t\tlet loaders,\n\t\t\t\t\tresource,\n\t\t\t\t\tloadersPrefix = \"\";\n\t\t\t\tconst idx = request.lastIndexOf(\"!\");\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tlet loadersRequest = request.slice(0, idx + 1);\n\t\t\t\t\tlet i;\n\t\t\t\t\tfor (\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\ti < loadersRequest.length && loadersRequest[i] === \"!\";\n\t\t\t\t\t\ti++\n\t\t\t\t\t) {\n\t\t\t\t\t\tloadersPrefix += \"!\";\n\t\t\t\t\t}\n\t\t\t\t\tloadersRequest = loadersRequest\n\t\t\t\t\t\t.slice(i)\n\t\t\t\t\t\t.replace(/!+$/, \"\")\n\t\t\t\t\t\t.replace(/!!+/g, \"!\");\n\t\t\t\t\tif (loadersRequest === \"\") {\n\t\t\t\t\t\tloaders = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tloaders = loadersRequest.split(\"!\");\n\t\t\t\t\t}\n\t\t\t\t\tresource = request.slice(idx + 1);\n\t\t\t\t} else {\n\t\t\t\t\tloaders = [];\n\t\t\t\t\tresource = request;\n\t\t\t\t}\n\n\t\t\t\tconst contextResolver = this.resolverFactory.get(\n\t\t\t\t\t\"context\",\n\t\t\t\t\tdependencies.length > 0\n\t\t\t\t\t\t? cachedSetProperty(\n\t\t\t\t\t\t\t\tresolveOptions || EMPTY_RESOLVE_OPTIONS,\n\t\t\t\t\t\t\t\t\"dependencyType\",\n\t\t\t\t\t\t\t\tdependencies[0].category\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t: resolveOptions\n\t\t\t\t);\n\t\t\t\tconst loaderResolver = this.resolverFactory.get(\"loader\");\n\n\t\t\t\tasyncLib.parallel(\n\t\t\t\t\t[\n\t\t\t\t\t\tcallback => {\n\t\t\t\t\t\t\tconst results = [];\n\t\t\t\t\t\t\tconst yield_ = obj => results.push(obj);\n\n\t\t\t\t\t\t\tcontextResolver.resolve(\n\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\tresource,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\tcontextDependencies,\n\t\t\t\t\t\t\t\t\tyield: yield_\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\tcallback(null, results);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcallback => {\n\t\t\t\t\t\t\tasyncLib.map(\n\t\t\t\t\t\t\t\tloaders,\n\t\t\t\t\t\t\t\t(loader, callback) => {\n\t\t\t\t\t\t\t\t\tloaderResolver.resolve(\n\t\t\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t\t\tloader,\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treturn callback(err, {\n\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet [contextResult, loaderResult] = result;\n\t\t\t\t\t\tif (contextResult.length > 1) {\n\t\t\t\t\t\t\tconst first = contextResult[0];\n\t\t\t\t\t\t\tcontextResult = contextResult.filter(r => r.path);\n\t\t\t\t\t\t\tif (contextResult.length === 0) contextResult.push(first);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.hooks.afterResolve.callAsync(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\taddon:\n\t\t\t\t\t\t\t\t\tloadersPrefix +\n\t\t\t\t\t\t\t\t\tloaderResult.join(\"!\") +\n\t\t\t\t\t\t\t\t\t(loaderResult.length > 0 ? \"!\" : \"\"),\n\t\t\t\t\t\t\t\tresource:\n\t\t\t\t\t\t\t\t\tcontextResult.length > 1\n\t\t\t\t\t\t\t\t\t\t? contextResult.map(r => r.path)\n\t\t\t\t\t\t\t\t\t\t: contextResult[0].path,\n\t\t\t\t\t\t\t\tresolveDependencies: this.resolveDependencies.bind(this),\n\t\t\t\t\t\t\t\tresourceQuery: contextResult[0].query,\n\t\t\t\t\t\t\t\tresourceFragment: contextResult[0].fragment,\n\t\t\t\t\t\t\t\t...beforeResolveResult\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treturn callback(err, {\n\t\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Ignored\n\t\t\t\t\t\t\t\tif (!result) {\n\t\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\tmodule: new ContextModule(result.resolveDependencies, result),\n\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {InputFileSystem} fs file system\n\t * @param {ContextModuleOptions} options options\n\t * @param {ResolveDependenciesCallback} callback callback function\n\t * @returns {void}\n\t */\n\tresolveDependencies(fs, options, callback) {\n\t\tconst cmf = this;\n\t\tconst {\n\t\t\tresource,\n\t\t\tresourceQuery,\n\t\t\tresourceFragment,\n\t\t\trecursive,\n\t\t\tregExp,\n\t\t\tinclude,\n\t\t\texclude,\n\t\t\treferencedExports,\n\t\t\tcategory,\n\t\t\ttypePrefix,\n\t\t\tattributes\n\t\t} = options;\n\t\tif (!regExp || !resource) return callback(null, []);\n\n\t\tconst addDirectoryChecked = (ctx, directory, visited, callback) => {\n\t\t\tfs.realpath(directory, (err, realPath) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tif (visited.has(realPath)) return callback(null, []);\n\t\t\t\tlet recursionStack;\n\t\t\t\taddDirectory(\n\t\t\t\t\tctx,\n\t\t\t\t\tdirectory,\n\t\t\t\t\t(_, dir, callback) => {\n\t\t\t\t\t\tif (recursionStack === undefined) {\n\t\t\t\t\t\t\trecursionStack = new Set(visited);\n\t\t\t\t\t\t\trecursionStack.add(realPath);\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddDirectoryChecked(ctx, dir, recursionStack, callback);\n\t\t\t\t\t},\n\t\t\t\t\tcallback\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\tconst addDirectory = (ctx, directory, addSubDirectory, callback) => {\n\t\t\tfs.readdir(directory, (err, files) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tconst processedFiles = cmf.hooks.contextModuleFiles.call(\n\t\t\t\t\t/** @type {string[]} */ (files).map(file => file.normalize(\"NFC\"))\n\t\t\t\t);\n\t\t\t\tif (!processedFiles || processedFiles.length === 0)\n\t\t\t\t\treturn callback(null, []);\n\t\t\t\tasyncLib.map(\n\t\t\t\t\tprocessedFiles.filter(p => p.indexOf(\".\") !== 0),\n\t\t\t\t\t(segment, callback) => {\n\t\t\t\t\t\tconst subResource = join(fs, directory, segment);\n\n\t\t\t\t\t\tif (!exclude || !subResource.match(exclude)) {\n\t\t\t\t\t\t\tfs.stat(subResource, (err, stat) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\t\t\t\t\t\t\t// ENOENT is ok here because the file may have been deleted between\n\t\t\t\t\t\t\t\t\t\t// the readdir and stat calls.\n\t\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\t\t\t\t\tif (!recursive) return callback();\n\t\t\t\t\t\t\t\t\taddSubDirectory(ctx, subResource, callback);\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tstat.isFile() &&\n\t\t\t\t\t\t\t\t\t(!include || subResource.match(include))\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\t\t\t\tcontext: ctx,\n\t\t\t\t\t\t\t\t\t\trequest:\n\t\t\t\t\t\t\t\t\t\t\t\".\" + subResource.slice(ctx.length).replace(/\\\\/g, \"/\")\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tthis.hooks.alternativeRequests.callAsync(\n\t\t\t\t\t\t\t\t\t\t[obj],\n\t\t\t\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\t\t\t\t(err, alternatives) => {\n\t\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\t\talternatives = alternatives\n\t\t\t\t\t\t\t\t\t\t\t\t.filter(obj => regExp.test(obj.request))\n\t\t\t\t\t\t\t\t\t\t\t\t.map(obj => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new ContextElementDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`${obj.request}${resourceQuery}${resourceFragment}`,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tobj.request,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttypePrefix,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcategory,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treferencedExports,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tobj.context,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tattributes\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\tdep.optional = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn dep;\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\tcallback(null, alternatives);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\tif (!result) return callback(null, []);\n\n\t\t\t\t\t\tconst flattenedResult = [];\n\n\t\t\t\t\t\tfor (const item of result) {\n\t\t\t\t\t\t\tif (item) flattenedResult.push(...item);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcallback(null, flattenedResult);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\tconst addSubDirectory = (ctx, dir, callback) =>\n\t\t\taddDirectory(ctx, dir, addSubDirectory, callback);\n\n\t\tconst visitResource = (resource, callback) => {\n\t\t\tif (typeof fs.realpath === \"function\") {\n\t\t\t\taddDirectoryChecked(resource, resource, new Set(), callback);\n\t\t\t} else {\n\t\t\t\taddDirectory(resource, resource, addSubDirectory, callback);\n\t\t\t}\n\t\t};\n\n\t\tif (typeof resource === \"string\") {\n\t\t\tvisitResource(resource, callback);\n\t\t} else {\n\t\t\tasyncLib.map(resource, visitResource, (err, result) => {\n\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t// result dependencies should have unique userRequest\n\t\t\t\t// ordered by resolve result\n\t\t\t\tconst temp = new Set();\n\t\t\t\tconst res = [];\n\t\t\t\tfor (let i = 0; i < result.length; i++) {\n\t\t\t\t\tconst inner = result[i];\n\t\t\t\t\tfor (const el of inner) {\n\t\t\t\t\t\tif (temp.has(el.userRequest)) continue;\n\t\t\t\t\t\tres.push(el);\n\t\t\t\t\t\ttemp.add(el.userRequest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcallback(null, res);\n\t\t\t});\n\t\t}\n\t}\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,QAAQ,GAAGC,OAAO,CAAC,WAAW,CAAC;AACrC,MAAM;EAAEC,wBAAwB;EAAEC;AAAkB,CAAC,GAAGF,OAAO,CAAC,SAAS,CAAC;AAC1E,MAAMG,aAAa,GAAGH,OAAO,CAAC,iBAAiB,CAAC;AAChD,MAAMI,aAAa,GAAGJ,OAAO,CAAC,iBAAiB,CAAC;AAChD,MAAMK,wBAAwB,GAAGL,OAAO,CAAC,yCAAyC,CAAC;AACnF,MAAMM,OAAO,GAAGN,OAAO,CAAC,gBAAgB,CAAC;AACzC,MAAM;EAAEO;AAAkB,CAAC,GAAGP,OAAO,CAAC,oBAAoB,CAAC;AAC3D,MAAM;EAAEQ;AAAe,CAAC,GAAGR,OAAO,CAAC,oBAAoB,CAAC;AACxD,MAAM;EAAES;AAAK,CAAC,GAAGT,OAAO,CAAC,WAAW,CAAC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMU,qBAAqB,GAAG,CAAC,CAAC;AAEhCC,MAAM,CAACC,OAAO,GAAG,MAAMC,oBAAoB,SAAST,aAAa,CAAC;EACjE;AACD;AACA;EACCU,WAAWA,CAACC,eAAe,EAAE;IAC5B,KAAK,CAAC,CAAC;IACP;IACA,MAAMC,mBAAmB,GAAG,IAAIf,wBAAwB,CAAC,CACxD,SAAS,EACT,SAAS,CACT,CAAC;IACF,IAAI,CAACgB,KAAK,GAAGC,MAAM,CAACC,MAAM,CAAC;MAC1B;MACAC,aAAa,EAAE,IAAInB,wBAAwB,CAAC,CAAC,MAAM,CAAC,CAAC;MACrD;MACAoB,YAAY,EAAE,IAAIpB,wBAAwB,CAAC,CAAC,MAAM,CAAC,CAAC;MACpD;MACAqB,kBAAkB,EAAE,IAAIpB,iBAAiB,CAAC,CAAC,OAAO,CAAC,CAAC;MACpD;MACAqB,YAAY,EAAEf,cAAc,CAC3B;QACCgB,IAAI,EAAE,cAAc;QACpB;QACAC,SAAS,EAAEC,WAAW,IAAI;UACzB,MAAM,IAAIC,KAAK,CACd,4IACD,CAAC;QACF,CAAC;QACD;QACAC,GAAG,EAAEA,CAACC,OAAO,EAAEC,EAAE,KAAK;UACrBd,mBAAmB,CAACY,GAAG,CAACC,OAAO,EAAEC,EAAE,CAAC;QACrC,CAAC;QACD;QACAC,QAAQ,EAAEA,CAACF,OAAO,EAAEC,EAAE,KAAK;UAC1Bd,mBAAmB,CAACe,QAAQ,CAACF,OAAO,EAAE,CAACG,KAAK,EAAEC,QAAQ,EAAEC,QAAQ,KAC/DJ,EAAE,CAACE,KAAK,EAAEE,QAAQ,CACnB,CAAC;QACF,CAAC;QACD;QACAC,UAAU,EAAEA,CAACN,OAAO,EAAEC,EAAE,KAAK;UAC5Bd,mBAAmB,CAACmB,UAAU,CAACN,OAAO,EAAEC,EAAE,CAAC;QAC5C;MACD,CAAC,EACD,wJAAwJ,EACxJ,iDACD,CAAC;MACDd;IACD,CAAC,CAAC;IACF,IAAI,CAACD,eAAe,GAAGA,eAAe;EACvC;;EAEA;AACD;AACA;AACA;AACA;EACCqB,MAAMA,CAACC,IAAI,EAAEH,QAAQ,EAAE;IACtB,MAAMI,OAAO,GAAGD,IAAI,CAACC,OAAO;IAC5B,MAAMC,YAAY,GAAGF,IAAI,CAACE,YAAY;IACtC,MAAMC,cAAc,GAAGH,IAAI,CAACG,cAAc;IAC1C,MAAMC,UAAU,GAAG,gCAAkCF,YAAY,CAAC,CAAC,CAAE;IACrE,MAAMG,gBAAgB,GAAG,IAAIpC,OAAO,CAAC,CAAC;IACtC,MAAMqC,mBAAmB,GAAG,IAAIrC,OAAO,CAAC,CAAC;IACzC,MAAMsC,mBAAmB,GAAG,IAAItC,OAAO,CAAC,CAAC;IACzC,IAAI,CAACW,KAAK,CAACG,aAAa,CAACyB,SAAS,CACjC;MACCP,OAAO,EAAEA,OAAO;MAChBC,YAAY,EAAEA,YAAY;MAC1BO,KAAK,EAAET,IAAI,CAACU,WAAW,CAACC,WAAW;MACnCR,cAAc;MACdE,gBAAgB;MAChBC,mBAAmB;MACnBC,mBAAmB;MACnB,GAAGH,UAAU,CAACZ;IACf,CAAC,EACD,CAACoB,GAAG,EAAEC,mBAAmB,KAAK;MAC7B,IAAID,GAAG,EAAE;QACR,OAAOf,QAAQ,CAACe,GAAG,EAAE;UACpBP,gBAAgB;UAChBC,mBAAmB;UACnBC;QACD,CAAC,CAAC;MACH;;MAEA;MACA,IAAI,CAACM,mBAAmB,EAAE;QACzB,OAAOhB,QAAQ,CAAC,IAAI,EAAE;UACrBQ,gBAAgB;UAChBC,mBAAmB;UACnBC;QACD,CAAC,CAAC;MACH;MAEA,MAAMN,OAAO,GAAGY,mBAAmB,CAACZ,OAAO;MAC3C,MAAMa,OAAO,GAAGD,mBAAmB,CAACC,OAAO;MAC3C,MAAMX,cAAc,GAAGU,mBAAmB,CAACV,cAAc;MAEzD,IAAIY,OAAO;QACVC,QAAQ;QACRC,aAAa,GAAG,EAAE;MACnB,MAAMC,GAAG,GAAGJ,OAAO,CAACK,WAAW,CAAC,GAAG,CAAC;MACpC,IAAID,GAAG,IAAI,CAAC,EAAE;QACb,IAAIE,cAAc,GAAGN,OAAO,CAACO,KAAK,CAAC,CAAC,EAAEH,GAAG,GAAG,CAAC,CAAC;QAC9C,IAAII,CAAC;QACL,KACCA,CAAC,GAAG,CAAC,EACLA,CAAC,GAAGF,cAAc,CAACG,MAAM,IAAIH,cAAc,CAACE,CAAC,CAAC,KAAK,GAAG,EACtDA,CAAC,EAAE,EACF;UACDL,aAAa,IAAI,GAAG;QACrB;QACAG,cAAc,GAAGA,cAAc,CAC7BC,KAAK,CAACC,CAAC,CAAC,CACRE,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAClBA,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC;QACtB,IAAIJ,cAAc,KAAK,EAAE,EAAE;UAC1BL,OAAO,GAAG,EAAE;QACb,CAAC,MAAM;UACNA,OAAO,GAAGK,cAAc,CAACK,KAAK,CAAC,GAAG,CAAC;QACpC;QACAT,QAAQ,GAAGF,OAAO,CAACO,KAAK,CAACH,GAAG,GAAG,CAAC,CAAC;MAClC,CAAC,MAAM;QACNH,OAAO,GAAG,EAAE;QACZC,QAAQ,GAAGF,OAAO;MACnB;MAEA,MAAMY,eAAe,GAAG,IAAI,CAAChD,eAAe,CAACiD,GAAG,CAC/C,SAAS,EACTzB,YAAY,CAACqB,MAAM,GAAG,CAAC,GACpBrD,iBAAiB,CACjBiC,cAAc,IAAI9B,qBAAqB,EACvC,gBAAgB,EAChB6B,YAAY,CAAC,CAAC,CAAC,CAAC0B,QACjB,CAAC,GACAzB,cACJ,CAAC;MACD,MAAM0B,cAAc,GAAG,IAAI,CAACnD,eAAe,CAACiD,GAAG,CAAC,QAAQ,CAAC;MAEzDjE,QAAQ,CAACoE,QAAQ,CAChB,CACCjC,QAAQ,IAAI;QACX,MAAMkC,OAAO,GAAG,EAAE;QAClB,MAAMC,MAAM,GAAGC,GAAG,IAAIF,OAAO,CAACG,IAAI,CAACD,GAAG,CAAC;QAEvCP,eAAe,CAACS,OAAO,CACtB,CAAC,CAAC,EACFlC,OAAO,EACPe,QAAQ,EACR;UACCX,gBAAgB;UAChBC,mBAAmB;UACnBC,mBAAmB;UACnB6B,KAAK,EAAEJ;QACR,CAAC,EACDpB,GAAG,IAAI;UACN,IAAIA,GAAG,EAAE,OAAOf,QAAQ,CAACe,GAAG,CAAC;UAC7Bf,QAAQ,CAAC,IAAI,EAAEkC,OAAO,CAAC;QACxB,CACD,CAAC;MACF,CAAC,EACDlC,QAAQ,IAAI;QACXnC,QAAQ,CAAC2E,GAAG,CACXtB,OAAO,EACP,CAACuB,MAAM,EAAEzC,QAAQ,KAAK;UACrBgC,cAAc,CAACM,OAAO,CACrB,CAAC,CAAC,EACFlC,OAAO,EACPqC,MAAM,EACN;YACCjC,gBAAgB;YAChBC,mBAAmB;YACnBC;UACD,CAAC,EACD,CAACK,GAAG,EAAE2B,MAAM,KAAK;YAChB,IAAI3B,GAAG,EAAE,OAAOf,QAAQ,CAACe,GAAG,CAAC;YAC7Bf,QAAQ,CAAC,IAAI,EAAE0C,MAAM,CAAC;UACvB,CACD,CAAC;QACF,CAAC,EACD1C,QACD,CAAC;MACF,CAAC,CACD,EACD,CAACe,GAAG,EAAE2B,MAAM,KAAK;QAChB,IAAI3B,GAAG,EAAE;UACR,OAAOf,QAAQ,CAACe,GAAG,EAAE;YACpBP,gBAAgB;YAChBC,mBAAmB;YACnBC;UACD,CAAC,CAAC;QACH;QACA,IAAI,CAACiC,aAAa,EAAEC,YAAY,CAAC,GAAGF,MAAM;QAC1C,IAAIC,aAAa,CAACjB,MAAM,GAAG,CAAC,EAAE;UAC7B,MAAMmB,KAAK,GAAGF,aAAa,CAAC,CAAC,CAAC;UAC9BA,aAAa,GAAGA,aAAa,CAACG,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACC,IAAI,CAAC;UACjD,IAAIL,aAAa,CAACjB,MAAM,KAAK,CAAC,EAAEiB,aAAa,CAACN,IAAI,CAACQ,KAAK,CAAC;QAC1D;QACA,IAAI,CAAC9D,KAAK,CAACI,YAAY,CAACwB,SAAS,CAChC;UACCsC,KAAK,EACJ7B,aAAa,GACbwB,YAAY,CAACrE,IAAI,CAAC,GAAG,CAAC,IACrBqE,YAAY,CAAClB,MAAM,GAAG,CAAC,GAAG,GAAG,GAAG,EAAE,CAAC;UACrCP,QAAQ,EACPwB,aAAa,CAACjB,MAAM,GAAG,CAAC,GACrBiB,aAAa,CAACH,GAAG,CAACO,CAAC,IAAIA,CAAC,CAACC,IAAI,CAAC,GAC9BL,aAAa,CAAC,CAAC,CAAC,CAACK,IAAI;UACzBE,mBAAmB,EAAE,IAAI,CAACA,mBAAmB,CAACC,IAAI,CAAC,IAAI,CAAC;UACxDC,aAAa,EAAET,aAAa,CAAC,CAAC,CAAC,CAACU,KAAK;UACrCC,gBAAgB,EAAEX,aAAa,CAAC,CAAC,CAAC,CAACY,QAAQ;UAC3C,GAAGvC;QACJ,CAAC,EACD,CAACD,GAAG,EAAE2B,MAAM,KAAK;UAChB,IAAI3B,GAAG,EAAE;YACR,OAAOf,QAAQ,CAACe,GAAG,EAAE;cACpBP,gBAAgB;cAChBC,mBAAmB;cACnBC;YACD,CAAC,CAAC;UACH;;UAEA;UACA,IAAI,CAACgC,MAAM,EAAE;YACZ,OAAO1C,QAAQ,CAAC,IAAI,EAAE;cACrBQ,gBAAgB;cAChBC,mBAAmB;cACnBC;YACD,CAAC,CAAC;UACH;UAEA,OAAOV,QAAQ,CAAC,IAAI,EAAE;YACrBvB,MAAM,EAAE,IAAIR,aAAa,CAACyE,MAAM,CAACQ,mBAAmB,EAAER,MAAM,CAAC;YAC7DlC,gBAAgB;YAChBC,mBAAmB;YACnBC;UACD,CAAC,CAAC;QACH,CACD,CAAC;MACF,CACD,CAAC;IACF,CACD,CAAC;EACF;;EAEA;AACD;AACA;AACA;AACA;AACA;EACCwC,mBAAmBA,CAACM,EAAE,EAAE7D,OAAO,EAAEK,QAAQ,EAAE;IAC1C,MAAMyD,GAAG,GAAG,IAAI;IAChB,MAAM;MACLtC,QAAQ;MACRiC,aAAa;MACbE,gBAAgB;MAChBI,SAAS;MACTC,MAAM;MACNC,OAAO;MACPC,OAAO;MACPC,iBAAiB;MACjB/B,QAAQ;MACRgC,UAAU;MACVC;IACD,CAAC,GAAGrE,OAAO;IACX,IAAI,CAACgE,MAAM,IAAI,CAACxC,QAAQ,EAAE,OAAOnB,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC;IAEnD,MAAMiE,mBAAmB,GAAGA,CAACC,GAAG,EAAEC,SAAS,EAAEC,OAAO,EAAEpE,QAAQ,KAAK;MAClEwD,EAAE,CAACa,QAAQ,CAACF,SAAS,EAAE,CAACpD,GAAG,EAAEuD,QAAQ,KAAK;QACzC,IAAIvD,GAAG,EAAE,OAAOf,QAAQ,CAACe,GAAG,CAAC;QAC7B,IAAIqD,OAAO,CAACG,GAAG,CAACD,QAAQ,CAAC,EAAE,OAAOtE,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC;QACpD,IAAIwE,cAAc;QAClBC,YAAY,CACXP,GAAG,EACHC,SAAS,EACT,CAACO,CAAC,EAAEC,GAAG,EAAE3E,QAAQ,KAAK;UACrB,IAAIwE,cAAc,KAAKI,SAAS,EAAE;YACjCJ,cAAc,GAAG,IAAIK,GAAG,CAACT,OAAO,CAAC;YACjCI,cAAc,CAACM,GAAG,CAACR,QAAQ,CAAC;UAC7B;UACAL,mBAAmB,CAACC,GAAG,EAAES,GAAG,EAAEH,cAAc,EAAExE,QAAQ,CAAC;QACxD,CAAC,EACDA,QACD,CAAC;MACF,CAAC,CAAC;IACH,CAAC;IAED,MAAMyE,YAAY,GAAGA,CAACP,GAAG,EAAEC,SAAS,EAAEY,eAAe,EAAE/E,QAAQ,KAAK;MACnEwD,EAAE,CAACwB,OAAO,CAACb,SAAS,EAAE,CAACpD,GAAG,EAAEkE,KAAK,KAAK;QACrC,IAAIlE,GAAG,EAAE,OAAOf,QAAQ,CAACe,GAAG,CAAC;QAC7B,MAAMmE,cAAc,GAAGzB,GAAG,CAAC1E,KAAK,CAACK,kBAAkB,CAAC+F,IAAI,EACvD,uBAAyBF,KAAK,CAAEzC,GAAG,CAAC4C,IAAI,IAAIA,IAAI,CAACC,SAAS,CAAC,KAAK,CAAC,CAClE,CAAC;QACD,IAAI,CAACH,cAAc,IAAIA,cAAc,CAACxD,MAAM,KAAK,CAAC,EACjD,OAAO1B,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC;QAC1BnC,QAAQ,CAAC2E,GAAG,CACX0C,cAAc,CAACpC,MAAM,CAACwC,CAAC,IAAIA,CAAC,CAACC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAChD,CAACC,OAAO,EAAExF,QAAQ,KAAK;UACtB,MAAMyF,WAAW,GAAGlH,IAAI,CAACiF,EAAE,EAAEW,SAAS,EAAEqB,OAAO,CAAC;UAEhD,IAAI,CAAC3B,OAAO,IAAI,CAAC4B,WAAW,CAACC,KAAK,CAAC7B,OAAO,CAAC,EAAE;YAC5CL,EAAE,CAACmC,IAAI,CAACF,WAAW,EAAE,CAAC1E,GAAG,EAAE4E,IAAI,KAAK;cACnC,IAAI5E,GAAG,EAAE;gBACR,IAAIA,GAAG,CAAC6E,IAAI,KAAK,QAAQ,EAAE;kBAC1B;kBACA;kBACA,OAAO5F,QAAQ,CAAC,CAAC;gBAClB,CAAC,MAAM;kBACN,OAAOA,QAAQ,CAACe,GAAG,CAAC;gBACrB;cACD;cAEA,IAAI4E,IAAI,CAACE,WAAW,CAAC,CAAC,EAAE;gBACvB,IAAI,CAACnC,SAAS,EAAE,OAAO1D,QAAQ,CAAC,CAAC;gBACjC+E,eAAe,CAACb,GAAG,EAAEuB,WAAW,EAAEzF,QAAQ,CAAC;cAC5C,CAAC,MAAM,IACN2F,IAAI,CAACG,MAAM,CAAC,CAAC,KACZ,CAAClC,OAAO,IAAI6B,WAAW,CAACC,KAAK,CAAC9B,OAAO,CAAC,CAAC,EACvC;gBACD,MAAMxB,GAAG,GAAG;kBACXhC,OAAO,EAAE8D,GAAG;kBACZjD,OAAO,EACN,GAAG,GAAGwE,WAAW,CAACjE,KAAK,CAAC0C,GAAG,CAACxC,MAAM,CAAC,CAACC,OAAO,CAAC,KAAK,EAAE,GAAG;gBACxD,CAAC;gBAED,IAAI,CAAC5C,KAAK,CAACD,mBAAmB,CAAC6B,SAAS,CACvC,CAACyB,GAAG,CAAC,EACLzC,OAAO,EACP,CAACoB,GAAG,EAAE1B,YAAY,KAAK;kBACtB,IAAI0B,GAAG,EAAE,OAAOf,QAAQ,CAACe,GAAG,CAAC;kBAC7B1B,YAAY,GAAGA,YAAY,CACzByD,MAAM,CAACV,GAAG,IAAIuB,MAAM,CAACoC,IAAI,CAAC3D,GAAG,CAACnB,OAAO,CAAC,CAAC,CACvCuB,GAAG,CAACJ,GAAG,IAAI;oBACX,MAAM4D,GAAG,GAAG,IAAI7H,wBAAwB,CACvC,GAAGiE,GAAG,CAACnB,OAAO,GAAGmC,aAAa,GAAGE,gBAAgB,EAAE,EACnDlB,GAAG,CAACnB,OAAO,EACX8C,UAAU,EACVhC,QAAQ,EACR+B,iBAAiB,EACjB1B,GAAG,CAAChC,OAAO,EACX4D,UACD,CAAC;oBACDgC,GAAG,CAACC,QAAQ,GAAG,IAAI;oBACnB,OAAOD,GAAG;kBACX,CAAC,CAAC;kBACHhG,QAAQ,CAAC,IAAI,EAAEX,YAAY,CAAC;gBAC7B,CACD,CAAC;cACF,CAAC,MAAM;gBACNW,QAAQ,CAAC,CAAC;cACX;YACD,CAAC,CAAC;UACH,CAAC,MAAM;YACNA,QAAQ,CAAC,CAAC;UACX;QACD,CAAC,EACD,CAACe,GAAG,EAAE2B,MAAM,KAAK;UAChB,IAAI3B,GAAG,EAAE,OAAOf,QAAQ,CAACe,GAAG,CAAC;UAE7B,IAAI,CAAC2B,MAAM,EAAE,OAAO1C,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC;UAEtC,MAAMkG,eAAe,GAAG,EAAE;UAE1B,KAAK,MAAMC,IAAI,IAAIzD,MAAM,EAAE;YAC1B,IAAIyD,IAAI,EAAED,eAAe,CAAC7D,IAAI,CAAC,GAAG8D,IAAI,CAAC;UACxC;UAEAnG,QAAQ,CAAC,IAAI,EAAEkG,eAAe,CAAC;QAChC,CACD,CAAC;MACF,CAAC,CAAC;IACH,CAAC;IAED,MAAMnB,eAAe,GAAGA,CAACb,GAAG,EAAES,GAAG,EAAE3E,QAAQ,KAC1CyE,YAAY,CAACP,GAAG,EAAES,GAAG,EAAEI,eAAe,EAAE/E,QAAQ,CAAC;IAElD,MAAMoG,aAAa,GAAGA,CAACjF,QAAQ,EAAEnB,QAAQ,KAAK;MAC7C,IAAI,OAAOwD,EAAE,CAACa,QAAQ,KAAK,UAAU,EAAE;QACtCJ,mBAAmB,CAAC9C,QAAQ,EAAEA,QAAQ,EAAE,IAAI0D,GAAG,CAAC,CAAC,EAAE7E,QAAQ,CAAC;MAC7D,CAAC,MAAM;QACNyE,YAAY,CAACtD,QAAQ,EAAEA,QAAQ,EAAE4D,eAAe,EAAE/E,QAAQ,CAAC;MAC5D;IACD,CAAC;IAED,IAAI,OAAOmB,QAAQ,KAAK,QAAQ,EAAE;MACjCiF,aAAa,CAACjF,QAAQ,EAAEnB,QAAQ,CAAC;IAClC,CAAC,MAAM;MACNnC,QAAQ,CAAC2E,GAAG,CAACrB,QAAQ,EAAEiF,aAAa,EAAE,CAACrF,GAAG,EAAE2B,MAAM,KAAK;QACtD,IAAI3B,GAAG,EAAE,OAAOf,QAAQ,CAACe,GAAG,CAAC;;QAE7B;QACA;QACA,MAAMsF,IAAI,GAAG,IAAIxB,GAAG,CAAC,CAAC;QACtB,MAAMyB,GAAG,GAAG,EAAE;QACd,KAAK,IAAI7E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,MAAM,CAAChB,MAAM,EAAED,CAAC,EAAE,EAAE;UACvC,MAAM8E,KAAK,GAAG7D,MAAM,CAACjB,CAAC,CAAC;UACvB,KAAK,MAAM+E,EAAE,IAAID,KAAK,EAAE;YACvB,IAAIF,IAAI,CAAC9B,GAAG,CAACiC,EAAE,CAACC,WAAW,CAAC,EAAE;YAC9BH,GAAG,CAACjE,IAAI,CAACmE,EAAE,CAAC;YACZH,IAAI,CAACvB,GAAG,CAAC0B,EAAE,CAACC,WAAW,CAAC;UACzB;QACD;QACAzG,QAAQ,CAAC,IAAI,EAAEsG,GAAG,CAAC;MACpB,CAAC,CAAC;IACH;EACD;AACD,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst InitFragment = require(\"../InitFragment\");\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst {\n  first\n} = require(\"../util/SetHelpers\");\nconst {\n  propertyName\n} = require(\"../util/propertyName\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Generator\").GenerateContext} GenerateContext */\n\n/**\n * @param {Iterable<string>} iterable iterable strings\n * @returns {string} result\n */\nconst joinIterableWithComma = iterable => {\n  // This is more performant than Array.from().join(\", \")\n  // as it doesn't create an array\n  let str = \"\";\n  let first = true;\n  for (const item of iterable) {\n    if (first) {\n      first = false;\n    } else {\n      str += \", \";\n    }\n    str += item;\n  }\n  return str;\n};\nconst EMPTY_MAP = new Map();\nconst EMPTY_SET = new Set();\n\n/**\n * @extends {InitFragment<GenerateContext>} Context\n */\nclass HarmonyExportInitFragment extends InitFragment {\n  /**\n   * @param {string} exportsArgument the exports identifier\n   * @param {Map<string, string>} exportMap mapping from used name to exposed variable name\n   * @param {Set<string>} unusedExports list of unused export names\n   */\n  constructor(exportsArgument, exportMap = EMPTY_MAP, unusedExports = EMPTY_SET) {\n    super(undefined, InitFragment.STAGE_HARMONY_EXPORTS, 1, \"harmony-exports\");\n    this.exportsArgument = exportsArgument;\n    this.exportMap = exportMap;\n    this.unusedExports = unusedExports;\n  }\n\n  /**\n   * @param {HarmonyExportInitFragment[]} fragments all fragments to merge\n   * @returns {HarmonyExportInitFragment} merged fragment\n   */\n  mergeAll(fragments) {\n    let exportMap;\n    let exportMapOwned = false;\n    let unusedExports;\n    let unusedExportsOwned = false;\n    for (const fragment of fragments) {\n      if (fragment.exportMap.size !== 0) {\n        if (exportMap === undefined) {\n          exportMap = fragment.exportMap;\n          exportMapOwned = false;\n        } else {\n          if (!exportMapOwned) {\n            exportMap = new Map(exportMap);\n            exportMapOwned = true;\n          }\n          for (const [key, value] of fragment.exportMap) {\n            if (!exportMap.has(key)) exportMap.set(key, value);\n          }\n        }\n      }\n      if (fragment.unusedExports.size !== 0) {\n        if (unusedExports === undefined) {\n          unusedExports = fragment.unusedExports;\n          unusedExportsOwned = false;\n        } else {\n          if (!unusedExportsOwned) {\n            unusedExports = new Set(unusedExports);\n            unusedExportsOwned = true;\n          }\n          for (const value of fragment.unusedExports) {\n            unusedExports.add(value);\n          }\n        }\n      }\n    }\n    return new HarmonyExportInitFragment(this.exportsArgument, exportMap, unusedExports);\n  }\n\n  /**\n   * @param {HarmonyExportInitFragment} other other\n   * @returns {HarmonyExportInitFragment} merged result\n   */\n  merge(other) {\n    let exportMap;\n    if (this.exportMap.size === 0) {\n      exportMap = other.exportMap;\n    } else if (other.exportMap.size === 0) {\n      exportMap = this.exportMap;\n    } else {\n      exportMap = new Map(other.exportMap);\n      for (const [key, value] of this.exportMap) {\n        if (!exportMap.has(key)) exportMap.set(key, value);\n      }\n    }\n    let unusedExports;\n    if (this.unusedExports.size === 0) {\n      unusedExports = other.unusedExports;\n    } else if (other.unusedExports.size === 0) {\n      unusedExports = this.unusedExports;\n    } else {\n      unusedExports = new Set(other.unusedExports);\n      for (const value of this.unusedExports) {\n        unusedExports.add(value);\n      }\n    }\n    return new HarmonyExportInitFragment(this.exportsArgument, exportMap, unusedExports);\n  }\n\n  /**\n   * @param {GenerateContext} context context\n   * @returns {string | Source | undefined} the source code that will be included as initialization code\n   */\n  getContent({\n    runtimeTemplate,\n    runtimeRequirements\n  }) {\n    runtimeRequirements.add(RuntimeGlobals.exports);\n    runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);\n    const unusedPart = this.unusedExports.size > 1 ? `/* unused harmony exports ${joinIterableWithComma(this.unusedExports)} */\\n` : this.unusedExports.size > 0 ? `/* unused harmony export ${first(this.unusedExports)} */\\n` : \"\";\n    const definitions = [];\n    const orderedExportMap = Array.from(this.exportMap).sort(([a], [b]) => a < b ? -1 : 1);\n    for (const [key, value] of orderedExportMap) {\n      definitions.push(`\\n/* harmony export */   ${propertyName(key)}: ${runtimeTemplate.returningFunction(value)}`);\n    }\n    const definePart = this.exportMap.size > 0 ? `/* harmony export */ ${RuntimeGlobals.definePropertyGetters}(${this.exportsArgument}, {${definitions.join(\",\")}\\n/* harmony export */ });\\n` : \"\";\n    return `${definePart}${unusedPart}`;\n  }\n}\nmodule.exports = HarmonyExportInitFragment;","map":{"version":3,"names":["InitFragment","require","RuntimeGlobals","first","propertyName","joinIterableWithComma","iterable","str","item","EMPTY_MAP","Map","EMPTY_SET","Set","HarmonyExportInitFragment","constructor","exportsArgument","exportMap","unusedExports","undefined","STAGE_HARMONY_EXPORTS","mergeAll","fragments","exportMapOwned","unusedExportsOwned","fragment","size","key","value","has","set","add","merge","other","getContent","runtimeTemplate","runtimeRequirements","exports","definePropertyGetters","unusedPart","definitions","orderedExportMap","Array","from","sort","a","b","push","returningFunction","definePart","join","module"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/dependencies/HarmonyExportInitFragment.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst InitFragment = require(\"../InitFragment\");\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst { first } = require(\"../util/SetHelpers\");\nconst { propertyName } = require(\"../util/propertyName\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Generator\").GenerateContext} GenerateContext */\n\n/**\n * @param {Iterable<string>} iterable iterable strings\n * @returns {string} result\n */\nconst joinIterableWithComma = iterable => {\n\t// This is more performant than Array.from().join(\", \")\n\t// as it doesn't create an array\n\tlet str = \"\";\n\tlet first = true;\n\tfor (const item of iterable) {\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t} else {\n\t\t\tstr += \", \";\n\t\t}\n\t\tstr += item;\n\t}\n\treturn str;\n};\n\nconst EMPTY_MAP = new Map();\nconst EMPTY_SET = new Set();\n\n/**\n * @extends {InitFragment<GenerateContext>} Context\n */\nclass HarmonyExportInitFragment extends InitFragment {\n\t/**\n\t * @param {string} exportsArgument the exports identifier\n\t * @param {Map<string, string>} exportMap mapping from used name to exposed variable name\n\t * @param {Set<string>} unusedExports list of unused export names\n\t */\n\tconstructor(\n\t\texportsArgument,\n\t\texportMap = EMPTY_MAP,\n\t\tunusedExports = EMPTY_SET\n\t) {\n\t\tsuper(undefined, InitFragment.STAGE_HARMONY_EXPORTS, 1, \"harmony-exports\");\n\t\tthis.exportsArgument = exportsArgument;\n\t\tthis.exportMap = exportMap;\n\t\tthis.unusedExports = unusedExports;\n\t}\n\n\t/**\n\t * @param {HarmonyExportInitFragment[]} fragments all fragments to merge\n\t * @returns {HarmonyExportInitFragment} merged fragment\n\t */\n\tmergeAll(fragments) {\n\t\tlet exportMap;\n\t\tlet exportMapOwned = false;\n\t\tlet unusedExports;\n\t\tlet unusedExportsOwned = false;\n\n\t\tfor (const fragment of fragments) {\n\t\t\tif (fragment.exportMap.size !== 0) {\n\t\t\t\tif (exportMap === undefined) {\n\t\t\t\t\texportMap = fragment.exportMap;\n\t\t\t\t\texportMapOwned = false;\n\t\t\t\t} else {\n\t\t\t\t\tif (!exportMapOwned) {\n\t\t\t\t\t\texportMap = new Map(exportMap);\n\t\t\t\t\t\texportMapOwned = true;\n\t\t\t\t\t}\n\t\t\t\t\tfor (const [key, value] of fragment.exportMap) {\n\t\t\t\t\t\tif (!exportMap.has(key)) exportMap.set(key, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fragment.unusedExports.size !== 0) {\n\t\t\t\tif (unusedExports === undefined) {\n\t\t\t\t\tunusedExports = fragment.unusedExports;\n\t\t\t\t\tunusedExportsOwned = false;\n\t\t\t\t} else {\n\t\t\t\t\tif (!unusedExportsOwned) {\n\t\t\t\t\t\tunusedExports = new Set(unusedExports);\n\t\t\t\t\t\tunusedExportsOwned = true;\n\t\t\t\t\t}\n\t\t\t\t\tfor (const value of fragment.unusedExports) {\n\t\t\t\t\t\tunusedExports.add(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new HarmonyExportInitFragment(\n\t\t\tthis.exportsArgument,\n\t\t\texportMap,\n\t\t\tunusedExports\n\t\t);\n\t}\n\n\t/**\n\t * @param {HarmonyExportInitFragment} other other\n\t * @returns {HarmonyExportInitFragment} merged result\n\t */\n\tmerge(other) {\n\t\tlet exportMap;\n\t\tif (this.exportMap.size === 0) {\n\t\t\texportMap = other.exportMap;\n\t\t} else if (other.exportMap.size === 0) {\n\t\t\texportMap = this.exportMap;\n\t\t} else {\n\t\t\texportMap = new Map(other.exportMap);\n\t\t\tfor (const [key, value] of this.exportMap) {\n\t\t\t\tif (!exportMap.has(key)) exportMap.set(key, value);\n\t\t\t}\n\t\t}\n\t\tlet unusedExports;\n\t\tif (this.unusedExports.size === 0) {\n\t\t\tunusedExports = other.unusedExports;\n\t\t} else if (other.unusedExports.size === 0) {\n\t\t\tunusedExports = this.unusedExports;\n\t\t} else {\n\t\t\tunusedExports = new Set(other.unusedExports);\n\t\t\tfor (const value of this.unusedExports) {\n\t\t\t\tunusedExports.add(value);\n\t\t\t}\n\t\t}\n\t\treturn new HarmonyExportInitFragment(\n\t\t\tthis.exportsArgument,\n\t\t\texportMap,\n\t\t\tunusedExports\n\t\t);\n\t}\n\n\t/**\n\t * @param {GenerateContext} context context\n\t * @returns {string | Source | undefined} the source code that will be included as initialization code\n\t */\n\tgetContent({ runtimeTemplate, runtimeRequirements }) {\n\t\truntimeRequirements.add(RuntimeGlobals.exports);\n\t\truntimeRequirements.add(RuntimeGlobals.definePropertyGetters);\n\n\t\tconst unusedPart =\n\t\t\tthis.unusedExports.size > 1\n\t\t\t\t? `/* unused harmony exports ${joinIterableWithComma(\n\t\t\t\t\t\tthis.unusedExports\n\t\t\t\t\t)} */\\n`\n\t\t\t\t: this.unusedExports.size > 0\n\t\t\t\t\t? `/* unused harmony export ${first(this.unusedExports)} */\\n`\n\t\t\t\t\t: \"\";\n\t\tconst definitions = [];\n\t\tconst orderedExportMap = Array.from(this.exportMap).sort(([a], [b]) =>\n\t\t\ta < b ? -1 : 1\n\t\t);\n\t\tfor (const [key, value] of orderedExportMap) {\n\t\t\tdefinitions.push(\n\t\t\t\t`\\n/* harmony export */   ${propertyName(\n\t\t\t\t\tkey\n\t\t\t\t)}: ${runtimeTemplate.returningFunction(value)}`\n\t\t\t);\n\t\t}\n\t\tconst definePart =\n\t\t\tthis.exportMap.size > 0\n\t\t\t\t? `/* harmony export */ ${RuntimeGlobals.definePropertyGetters}(${\n\t\t\t\t\t\tthis.exportsArgument\n\t\t\t\t\t}, {${definitions.join(\",\")}\\n/* harmony export */ });\\n`\n\t\t\t\t: \"\";\n\t\treturn `${definePart}${unusedPart}`;\n\t}\n}\n\nmodule.exports = HarmonyExportInitFragment;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
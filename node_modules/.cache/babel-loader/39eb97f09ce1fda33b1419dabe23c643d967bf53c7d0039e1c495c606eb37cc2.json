{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n\n/**\n * @summary Get the subset of ids and their corresponding range in an id chain that should be re-rendered by webpack.\n * Only those in the chain that are actually referring to namespaces or imports should be re-rendered.\n * Deeper member accessors on the imported object should not be re-rendered.  If deeper member accessors are re-rendered,\n * there is a potential loss of meaning with rendering a quoted accessor as an unquoted accessor, or vice versa,\n * because minifiers treat quoted accessors differently.  e.g. import { a } from \"./module\"; a[\"b\"] vs a.b\n * @param {string[]} untrimmedIds chained ids\n * @param {Range} untrimmedRange range encompassing allIds\n * @param {Range[] | undefined} ranges cumulative range of ids for each of allIds\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @param {Dependency} dependency dependency\n * @returns {{trimmedIds: string[], trimmedRange: Range}} computed trimmed ids and cumulative range of those ids\n */\nexports.getTrimmedIdsAndRange = (untrimmedIds, untrimmedRange, ranges, moduleGraph, dependency) => {\n  let trimmedIds = trimIdsToThoseImported(untrimmedIds, moduleGraph, dependency);\n  let trimmedRange = untrimmedRange;\n  if (trimmedIds.length !== untrimmedIds.length) {\n    // The array returned from dep.idRanges is right-aligned with the array returned from dep.names.\n    // Meaning, the two arrays may not always have the same number of elements, but the last element of\n    // dep.idRanges corresponds to [the expression fragment to the left of] the last element of dep.names.\n    // Use this to find the correct replacement range based on the number of ids that were trimmed.\n    const idx = ranges === undefined ? -1 /* trigger failure case below */ : ranges.length + (trimmedIds.length - untrimmedIds.length);\n    if (idx < 0 || idx >= /** @type {Range[]} */ranges.length) {\n      // cspell:ignore minifiers\n      // Should not happen but we can't throw an error here because of backward compatibility with\n      // external plugins in wp5.  Instead, we just disable trimming for now.  This may break some minifiers.\n      trimmedIds = untrimmedIds;\n      // TODO webpack 6 remove the \"trimmedIds = ids\" above and uncomment the following line instead.\n      // throw new Error(\"Missing range starts data for id replacement trimming.\");\n    } else {\n      trimmedRange = /** @type {Range[]} */ranges[idx];\n    }\n  }\n  return {\n    trimmedIds,\n    trimmedRange\n  };\n};\n\n/**\n * @summary Determine which IDs in the id chain are actually referring to namespaces or imports,\n * and which are deeper member accessors on the imported object.\n * @param {string[]} ids untrimmed ids\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @param {Dependency} dependency dependency\n * @returns {string[]} trimmed ids\n */\nfunction trimIdsToThoseImported(ids, moduleGraph, dependency) {\n  /** @type {string[]} */\n  let trimmedIds = [];\n  let currentExportsInfo = moduleGraph.getExportsInfo( /** @type {Module} */moduleGraph.getModule(dependency));\n  for (let i = 0; i < ids.length; i++) {\n    if (i === 0 && ids[i] === \"default\") {\n      continue; // ExportInfo for the next level under default is still at the root ExportsInfo, so don't advance currentExportsInfo\n    }\n    const exportInfo = currentExportsInfo.getExportInfo(ids[i]);\n    if (exportInfo.provided === false) {\n      // json imports have nested ExportInfo for elements that things that are not actually exported, so check .provided\n      trimmedIds = ids.slice(0, i);\n      break;\n    }\n    const nestedInfo = exportInfo.getNestedExportsInfo();\n    if (!nestedInfo) {\n      // once all nested exports are traversed, the next item is the actual import so stop there\n      trimmedIds = ids.slice(0, i + 1);\n      break;\n    }\n    currentExportsInfo = nestedInfo;\n  }\n  // Never trim to nothing.  This can happen for invalid imports (e.g. import { notThere } from \"./module\", or import { anything } from \"./missingModule\")\n  return trimmedIds.length ? trimmedIds : ids;\n}","map":{"version":3,"names":["exports","getTrimmedIdsAndRange","untrimmedIds","untrimmedRange","ranges","moduleGraph","dependency","trimmedIds","trimIdsToThoseImported","trimmedRange","length","idx","undefined","ids","currentExportsInfo","getExportsInfo","getModule","i","exportInfo","getExportInfo","provided","slice","nestedInfo","getNestedExportsInfo"],"sources":["/Volumes/storage/projects/project-mcnt/node_modules/webpack/lib/util/chainedImports.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../javascript/JavascriptParser\").Range} Range */\n\n/**\n * @summary Get the subset of ids and their corresponding range in an id chain that should be re-rendered by webpack.\n * Only those in the chain that are actually referring to namespaces or imports should be re-rendered.\n * Deeper member accessors on the imported object should not be re-rendered.  If deeper member accessors are re-rendered,\n * there is a potential loss of meaning with rendering a quoted accessor as an unquoted accessor, or vice versa,\n * because minifiers treat quoted accessors differently.  e.g. import { a } from \"./module\"; a[\"b\"] vs a.b\n * @param {string[]} untrimmedIds chained ids\n * @param {Range} untrimmedRange range encompassing allIds\n * @param {Range[] | undefined} ranges cumulative range of ids for each of allIds\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @param {Dependency} dependency dependency\n * @returns {{trimmedIds: string[], trimmedRange: Range}} computed trimmed ids and cumulative range of those ids\n */\nexports.getTrimmedIdsAndRange = (\n\tuntrimmedIds,\n\tuntrimmedRange,\n\tranges,\n\tmoduleGraph,\n\tdependency\n) => {\n\tlet trimmedIds = trimIdsToThoseImported(\n\t\tuntrimmedIds,\n\t\tmoduleGraph,\n\t\tdependency\n\t);\n\tlet trimmedRange = untrimmedRange;\n\tif (trimmedIds.length !== untrimmedIds.length) {\n\t\t// The array returned from dep.idRanges is right-aligned with the array returned from dep.names.\n\t\t// Meaning, the two arrays may not always have the same number of elements, but the last element of\n\t\t// dep.idRanges corresponds to [the expression fragment to the left of] the last element of dep.names.\n\t\t// Use this to find the correct replacement range based on the number of ids that were trimmed.\n\t\tconst idx =\n\t\t\tranges === undefined\n\t\t\t\t? -1 /* trigger failure case below */\n\t\t\t\t: ranges.length + (trimmedIds.length - untrimmedIds.length);\n\t\tif (idx < 0 || idx >= /** @type {Range[]} */ (ranges).length) {\n\t\t\t// cspell:ignore minifiers\n\t\t\t// Should not happen but we can't throw an error here because of backward compatibility with\n\t\t\t// external plugins in wp5.  Instead, we just disable trimming for now.  This may break some minifiers.\n\t\t\ttrimmedIds = untrimmedIds;\n\t\t\t// TODO webpack 6 remove the \"trimmedIds = ids\" above and uncomment the following line instead.\n\t\t\t// throw new Error(\"Missing range starts data for id replacement trimming.\");\n\t\t} else {\n\t\t\ttrimmedRange = /** @type {Range[]} */ (ranges)[idx];\n\t\t}\n\t}\n\n\treturn { trimmedIds, trimmedRange };\n};\n\n/**\n * @summary Determine which IDs in the id chain are actually referring to namespaces or imports,\n * and which are deeper member accessors on the imported object.\n * @param {string[]} ids untrimmed ids\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @param {Dependency} dependency dependency\n * @returns {string[]} trimmed ids\n */\nfunction trimIdsToThoseImported(ids, moduleGraph, dependency) {\n\t/** @type {string[]} */\n\tlet trimmedIds = [];\n\tlet currentExportsInfo = moduleGraph.getExportsInfo(\n\t\t/** @type {Module} */ (moduleGraph.getModule(dependency))\n\t);\n\tfor (let i = 0; i < ids.length; i++) {\n\t\tif (i === 0 && ids[i] === \"default\") {\n\t\t\tcontinue; // ExportInfo for the next level under default is still at the root ExportsInfo, so don't advance currentExportsInfo\n\t\t}\n\t\tconst exportInfo = currentExportsInfo.getExportInfo(ids[i]);\n\t\tif (exportInfo.provided === false) {\n\t\t\t// json imports have nested ExportInfo for elements that things that are not actually exported, so check .provided\n\t\t\ttrimmedIds = ids.slice(0, i);\n\t\t\tbreak;\n\t\t}\n\t\tconst nestedInfo = exportInfo.getNestedExportsInfo();\n\t\tif (!nestedInfo) {\n\t\t\t// once all nested exports are traversed, the next item is the actual import so stop there\n\t\t\ttrimmedIds = ids.slice(0, i + 1);\n\t\t\tbreak;\n\t\t}\n\t\tcurrentExportsInfo = nestedInfo;\n\t}\n\t// Never trim to nothing.  This can happen for invalid imports (e.g. import { notThere } from \"./module\", or import { anything } from \"./missingModule\")\n\treturn trimmedIds.length ? trimmedIds : ids;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,OAAO,CAACC,qBAAqB,GAAG,CAC/BC,YAAY,EACZC,cAAc,EACdC,MAAM,EACNC,WAAW,EACXC,UAAU,KACN;EACJ,IAAIC,UAAU,GAAGC,sBAAsB,CACtCN,YAAY,EACZG,WAAW,EACXC,UACD,CAAC;EACD,IAAIG,YAAY,GAAGN,cAAc;EACjC,IAAII,UAAU,CAACG,MAAM,KAAKR,YAAY,CAACQ,MAAM,EAAE;IAC9C;IACA;IACA;IACA;IACA,MAAMC,GAAG,GACRP,MAAM,KAAKQ,SAAS,GACjB,CAAC,CAAC,CAAC,mCACHR,MAAM,CAACM,MAAM,IAAIH,UAAU,CAACG,MAAM,GAAGR,YAAY,CAACQ,MAAM,CAAC;IAC7D,IAAIC,GAAG,GAAG,CAAC,IAAIA,GAAG,IAAI,sBAAwBP,MAAM,CAAEM,MAAM,EAAE;MAC7D;MACA;MACA;MACAH,UAAU,GAAGL,YAAY;MACzB;MACA;IACD,CAAC,MAAM;MACNO,YAAY,GAAG,sBAAwBL,MAAM,CAAEO,GAAG,CAAC;IACpD;EACD;EAEA,OAAO;IAAEJ,UAAU;IAAEE;EAAa,CAAC;AACpC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,sBAAsBA,CAACK,GAAG,EAAER,WAAW,EAAEC,UAAU,EAAE;EAC7D;EACA,IAAIC,UAAU,GAAG,EAAE;EACnB,IAAIO,kBAAkB,GAAGT,WAAW,CAACU,cAAc,EAClD,qBAAuBV,WAAW,CAACW,SAAS,CAACV,UAAU,CACxD,CAAC;EACD,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACH,MAAM,EAAEO,CAAC,EAAE,EAAE;IACpC,IAAIA,CAAC,KAAK,CAAC,IAAIJ,GAAG,CAACI,CAAC,CAAC,KAAK,SAAS,EAAE;MACpC,SAAS,CAAC;IACX;IACA,MAAMC,UAAU,GAAGJ,kBAAkB,CAACK,aAAa,CAACN,GAAG,CAACI,CAAC,CAAC,CAAC;IAC3D,IAAIC,UAAU,CAACE,QAAQ,KAAK,KAAK,EAAE;MAClC;MACAb,UAAU,GAAGM,GAAG,CAACQ,KAAK,CAAC,CAAC,EAAEJ,CAAC,CAAC;MAC5B;IACD;IACA,MAAMK,UAAU,GAAGJ,UAAU,CAACK,oBAAoB,CAAC,CAAC;IACpD,IAAI,CAACD,UAAU,EAAE;MAChB;MACAf,UAAU,GAAGM,GAAG,CAACQ,KAAK,CAAC,CAAC,EAAEJ,CAAC,GAAG,CAAC,CAAC;MAChC;IACD;IACAH,kBAAkB,GAAGQ,UAAU;EAChC;EACA;EACA,OAAOf,UAAU,CAACG,MAAM,GAAGH,UAAU,GAAGM,GAAG;AAC5C","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}